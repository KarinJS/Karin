/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import $protobuf from "protobufjs/minimal.js";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots || ($protobuf.roots = {})

export const kritor = $root.kritor = (() => {

    /**
     * Namespace kritor.
     * @exports kritor
     * @namespace
     */
    const kritor = {};

    kritor.authentication = (function() {

        /**
         * Namespace authentication.
         * @memberof kritor
         * @namespace
         */
        const authentication = {};

        authentication.AuthenticationService = (function() {

            /**
             * Constructs a new AuthenticationService service.
             * @memberof kritor.authentication
             * @classdesc Represents an AuthenticationService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function AuthenticationService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (AuthenticationService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AuthenticationService;

            /**
             * Creates new AuthenticationService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.authentication.AuthenticationService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {AuthenticationService} RPC service. Useful where requests and/or responses are streamed.
             */
            AuthenticationService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.authentication.AuthenticationService#authenticate}.
             * @memberof kritor.authentication.AuthenticationService
             * @typedef AuthenticateCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.authentication.AuthenticateResponse} [response] AuthenticateResponse
             */

            /**
             * Calls Authenticate.
             * @function authenticate
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IAuthenticateRequest} request AuthenticateRequest message or plain object
             * @param {kritor.authentication.AuthenticationService.AuthenticateCallback} callback Node-style callback called with the error, if any, and AuthenticateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AuthenticationService.prototype.authenticate = function authenticate(request, callback) {
                return this.rpcCall(authenticate, $root.kritor.authentication.AuthenticateRequest, $root.kritor.authentication.AuthenticateResponse, request, callback);
            }, "name", { value: "Authenticate" });

            /**
             * Calls Authenticate.
             * @function authenticate
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IAuthenticateRequest} request AuthenticateRequest message or plain object
             * @returns {Promise<kritor.authentication.AuthenticateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.authentication.AuthenticationService#getAuthenticationState}.
             * @memberof kritor.authentication.AuthenticationService
             * @typedef GetAuthenticationStateCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.authentication.GetAuthenticationStateResponse} [response] GetAuthenticationStateResponse
             */

            /**
             * Calls GetAuthenticationState.
             * @function getAuthenticationState
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IGetAuthenticationStateRequest} request GetAuthenticationStateRequest message or plain object
             * @param {kritor.authentication.AuthenticationService.GetAuthenticationStateCallback} callback Node-style callback called with the error, if any, and GetAuthenticationStateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AuthenticationService.prototype.getAuthenticationState = function getAuthenticationState(request, callback) {
                return this.rpcCall(getAuthenticationState, $root.kritor.authentication.GetAuthenticationStateRequest, $root.kritor.authentication.GetAuthenticationStateResponse, request, callback);
            }, "name", { value: "GetAuthenticationState" });

            /**
             * Calls GetAuthenticationState.
             * @function getAuthenticationState
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IGetAuthenticationStateRequest} request GetAuthenticationStateRequest message or plain object
             * @returns {Promise<kritor.authentication.GetAuthenticationStateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.authentication.AuthenticationService#getTicket}.
             * @memberof kritor.authentication.AuthenticationService
             * @typedef GetTicketCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.authentication.GetTicketResponse} [response] GetTicketResponse
             */

            /**
             * Calls GetTicket.
             * @function getTicket
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IGetTicketRequest} request GetTicketRequest message or plain object
             * @param {kritor.authentication.AuthenticationService.GetTicketCallback} callback Node-style callback called with the error, if any, and GetTicketResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AuthenticationService.prototype.getTicket = function getTicket(request, callback) {
                return this.rpcCall(getTicket, $root.kritor.authentication.GetTicketRequest, $root.kritor.authentication.GetTicketResponse, request, callback);
            }, "name", { value: "GetTicket" });

            /**
             * Calls GetTicket.
             * @function getTicket
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IGetTicketRequest} request GetTicketRequest message or plain object
             * @returns {Promise<kritor.authentication.GetTicketResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.authentication.AuthenticationService#addTicket}.
             * @memberof kritor.authentication.AuthenticationService
             * @typedef AddTicketCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.authentication.AddTicketResponse} [response] AddTicketResponse
             */

            /**
             * Calls AddTicket.
             * @function addTicket
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IAddTicketRequest} request AddTicketRequest message or plain object
             * @param {kritor.authentication.AuthenticationService.AddTicketCallback} callback Node-style callback called with the error, if any, and AddTicketResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AuthenticationService.prototype.addTicket = function addTicket(request, callback) {
                return this.rpcCall(addTicket, $root.kritor.authentication.AddTicketRequest, $root.kritor.authentication.AddTicketResponse, request, callback);
            }, "name", { value: "AddTicket" });

            /**
             * Calls AddTicket.
             * @function addTicket
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IAddTicketRequest} request AddTicketRequest message or plain object
             * @returns {Promise<kritor.authentication.AddTicketResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.authentication.AuthenticationService#deleteTicket}.
             * @memberof kritor.authentication.AuthenticationService
             * @typedef DeleteTicketCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.authentication.DeleteTicketResponse} [response] DeleteTicketResponse
             */

            /**
             * Calls DeleteTicket.
             * @function deleteTicket
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IDeleteTicketRequest} request DeleteTicketRequest message or plain object
             * @param {kritor.authentication.AuthenticationService.DeleteTicketCallback} callback Node-style callback called with the error, if any, and DeleteTicketResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AuthenticationService.prototype.deleteTicket = function deleteTicket(request, callback) {
                return this.rpcCall(deleteTicket, $root.kritor.authentication.DeleteTicketRequest, $root.kritor.authentication.DeleteTicketResponse, request, callback);
            }, "name", { value: "DeleteTicket" });

            /**
             * Calls DeleteTicket.
             * @function deleteTicket
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IDeleteTicketRequest} request DeleteTicketRequest message or plain object
             * @returns {Promise<kritor.authentication.DeleteTicketResponse>} Promise
             * @variation 2
             */

            return AuthenticationService;
        })();

        authentication.AuthenticateRequest = (function() {

            /**
             * Properties of an AuthenticateRequest.
             * @memberof kritor.authentication
             * @interface IAuthenticateRequest
             * @property {string|null} [account] AuthenticateRequest account
             * @property {string|null} [ticket] AuthenticateRequest ticket
             */

            /**
             * Constructs a new AuthenticateRequest.
             * @memberof kritor.authentication
             * @classdesc Represents an AuthenticateRequest.
             * @implements IAuthenticateRequest
             * @constructor
             * @param {kritor.authentication.IAuthenticateRequest=} [properties] Properties to set
             */
            function AuthenticateRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AuthenticateRequest account.
             * @member {string} account
             * @memberof kritor.authentication.AuthenticateRequest
             * @instance
             */
            AuthenticateRequest.prototype.account = "";

            /**
             * AuthenticateRequest ticket.
             * @member {string} ticket
             * @memberof kritor.authentication.AuthenticateRequest
             * @instance
             */
            AuthenticateRequest.prototype.ticket = "";

            /**
             * Creates a new AuthenticateRequest instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {kritor.authentication.IAuthenticateRequest=} [properties] Properties to set
             * @returns {kritor.authentication.AuthenticateRequest} AuthenticateRequest instance
             */
            AuthenticateRequest.create = function create(properties) {
                return new AuthenticateRequest(properties);
            };

            /**
             * Encodes the specified AuthenticateRequest message. Does not implicitly {@link kritor.authentication.AuthenticateRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {kritor.authentication.IAuthenticateRequest} message AuthenticateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthenticateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
                if (message.ticket != null && Object.hasOwnProperty.call(message, "ticket"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.ticket);
                return writer;
            };

            /**
             * Encodes the specified AuthenticateRequest message, length delimited. Does not implicitly {@link kritor.authentication.AuthenticateRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {kritor.authentication.IAuthenticateRequest} message AuthenticateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthenticateRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AuthenticateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.AuthenticateRequest} AuthenticateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthenticateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.AuthenticateRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.account = reader.string();
                            break;
                        }
                    case 2: {
                            message.ticket = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AuthenticateRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.AuthenticateRequest} AuthenticateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthenticateRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AuthenticateRequest message.
             * @function verify
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AuthenticateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.account != null && message.hasOwnProperty("account"))
                    if (!$util.isString(message.account))
                        return "account: string expected";
                if (message.ticket != null && message.hasOwnProperty("ticket"))
                    if (!$util.isString(message.ticket))
                        return "ticket: string expected";
                return null;
            };

            /**
             * Creates an AuthenticateRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.AuthenticateRequest} AuthenticateRequest
             */
            AuthenticateRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.AuthenticateRequest)
                    return object;
                let message = new $root.kritor.authentication.AuthenticateRequest();
                if (object.account != null)
                    message.account = String(object.account);
                if (object.ticket != null)
                    message.ticket = String(object.ticket);
                return message;
            };

            /**
             * Creates a plain object from an AuthenticateRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {kritor.authentication.AuthenticateRequest} message AuthenticateRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AuthenticateRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.account = "";
                    object.ticket = "";
                }
                if (message.account != null && message.hasOwnProperty("account"))
                    object.account = message.account;
                if (message.ticket != null && message.hasOwnProperty("ticket"))
                    object.ticket = message.ticket;
                return object;
            };

            /**
             * Converts this AuthenticateRequest to JSON.
             * @function toJSON
             * @memberof kritor.authentication.AuthenticateRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AuthenticateRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AuthenticateRequest
             * @function getTypeUrl
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AuthenticateRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.AuthenticateRequest";
            };

            return AuthenticateRequest;
        })();

        authentication.AuthenticateResponse = (function() {

            /**
             * Properties of an AuthenticateResponse.
             * @memberof kritor.authentication
             * @interface IAuthenticateResponse
             * @property {kritor.authentication.AuthenticateResponse.AuthenticateResponseCode|null} [code] AuthenticateResponse code
             * @property {string|null} [msg] AuthenticateResponse msg
             */

            /**
             * Constructs a new AuthenticateResponse.
             * @memberof kritor.authentication
             * @classdesc Represents an AuthenticateResponse.
             * @implements IAuthenticateResponse
             * @constructor
             * @param {kritor.authentication.IAuthenticateResponse=} [properties] Properties to set
             */
            function AuthenticateResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AuthenticateResponse code.
             * @member {kritor.authentication.AuthenticateResponse.AuthenticateResponseCode} code
             * @memberof kritor.authentication.AuthenticateResponse
             * @instance
             */
            AuthenticateResponse.prototype.code = 0;

            /**
             * AuthenticateResponse msg.
             * @member {string} msg
             * @memberof kritor.authentication.AuthenticateResponse
             * @instance
             */
            AuthenticateResponse.prototype.msg = "";

            /**
             * Creates a new AuthenticateResponse instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {kritor.authentication.IAuthenticateResponse=} [properties] Properties to set
             * @returns {kritor.authentication.AuthenticateResponse} AuthenticateResponse instance
             */
            AuthenticateResponse.create = function create(properties) {
                return new AuthenticateResponse(properties);
            };

            /**
             * Encodes the specified AuthenticateResponse message. Does not implicitly {@link kritor.authentication.AuthenticateResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {kritor.authentication.IAuthenticateResponse} message AuthenticateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthenticateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                return writer;
            };

            /**
             * Encodes the specified AuthenticateResponse message, length delimited. Does not implicitly {@link kritor.authentication.AuthenticateResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {kritor.authentication.IAuthenticateResponse} message AuthenticateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthenticateResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AuthenticateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.AuthenticateResponse} AuthenticateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthenticateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.AuthenticateResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.code = reader.int32();
                            break;
                        }
                    case 2: {
                            message.msg = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AuthenticateResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.AuthenticateResponse} AuthenticateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthenticateResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AuthenticateResponse message.
             * @function verify
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AuthenticateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.msg != null && message.hasOwnProperty("msg"))
                    if (!$util.isString(message.msg))
                        return "msg: string expected";
                return null;
            };

            /**
             * Creates an AuthenticateResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.AuthenticateResponse} AuthenticateResponse
             */
            AuthenticateResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.AuthenticateResponse)
                    return object;
                let message = new $root.kritor.authentication.AuthenticateResponse();
                switch (object.code) {
                default:
                    if (typeof object.code === "number") {
                        message.code = object.code;
                        break;
                    }
                    break;
                case "OK":
                case 0:
                    message.code = 0;
                    break;
                case "NO_ACCOUNT":
                case 1:
                    message.code = 1;
                    break;
                case "NO_TICKET":
                case 2:
                    message.code = 2;
                    break;
                case "LOGIC_ERROR":
                case 3:
                    message.code = 3;
                    break;
                }
                if (object.msg != null)
                    message.msg = String(object.msg);
                return message;
            };

            /**
             * Creates a plain object from an AuthenticateResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {kritor.authentication.AuthenticateResponse} message AuthenticateResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AuthenticateResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.code = options.enums === String ? "OK" : 0;
                    object.msg = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.kritor.authentication.AuthenticateResponse.AuthenticateResponseCode[message.code] === undefined ? message.code : $root.kritor.authentication.AuthenticateResponse.AuthenticateResponseCode[message.code] : message.code;
                if (message.msg != null && message.hasOwnProperty("msg"))
                    object.msg = message.msg;
                return object;
            };

            /**
             * Converts this AuthenticateResponse to JSON.
             * @function toJSON
             * @memberof kritor.authentication.AuthenticateResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AuthenticateResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AuthenticateResponse
             * @function getTypeUrl
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AuthenticateResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.AuthenticateResponse";
            };

            /**
             * AuthenticateResponseCode enum.
             * @name kritor.authentication.AuthenticateResponse.AuthenticateResponseCode
             * @enum {number}
             * @property {number} OK=0 OK value
             * @property {number} NO_ACCOUNT=1 NO_ACCOUNT value
             * @property {number} NO_TICKET=2 NO_TICKET value
             * @property {number} LOGIC_ERROR=3 LOGIC_ERROR value
             */
            AuthenticateResponse.AuthenticateResponseCode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "OK"] = 0;
                values[valuesById[1] = "NO_ACCOUNT"] = 1;
                values[valuesById[2] = "NO_TICKET"] = 2;
                values[valuesById[3] = "LOGIC_ERROR"] = 3;
                return values;
            })();

            return AuthenticateResponse;
        })();

        authentication.GetAuthenticationStateRequest = (function() {

            /**
             * Properties of a GetAuthenticationStateRequest.
             * @memberof kritor.authentication
             * @interface IGetAuthenticationStateRequest
             * @property {string|null} [account] GetAuthenticationStateRequest account
             */

            /**
             * Constructs a new GetAuthenticationStateRequest.
             * @memberof kritor.authentication
             * @classdesc Represents a GetAuthenticationStateRequest.
             * @implements IGetAuthenticationStateRequest
             * @constructor
             * @param {kritor.authentication.IGetAuthenticationStateRequest=} [properties] Properties to set
             */
            function GetAuthenticationStateRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetAuthenticationStateRequest account.
             * @member {string} account
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @instance
             */
            GetAuthenticationStateRequest.prototype.account = "";

            /**
             * Creates a new GetAuthenticationStateRequest instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {kritor.authentication.IGetAuthenticationStateRequest=} [properties] Properties to set
             * @returns {kritor.authentication.GetAuthenticationStateRequest} GetAuthenticationStateRequest instance
             */
            GetAuthenticationStateRequest.create = function create(properties) {
                return new GetAuthenticationStateRequest(properties);
            };

            /**
             * Encodes the specified GetAuthenticationStateRequest message. Does not implicitly {@link kritor.authentication.GetAuthenticationStateRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {kritor.authentication.IGetAuthenticationStateRequest} message GetAuthenticationStateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAuthenticationStateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
                return writer;
            };

            /**
             * Encodes the specified GetAuthenticationStateRequest message, length delimited. Does not implicitly {@link kritor.authentication.GetAuthenticationStateRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {kritor.authentication.IGetAuthenticationStateRequest} message GetAuthenticationStateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAuthenticationStateRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAuthenticationStateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.GetAuthenticationStateRequest} GetAuthenticationStateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAuthenticationStateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.GetAuthenticationStateRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.account = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAuthenticationStateRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.GetAuthenticationStateRequest} GetAuthenticationStateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAuthenticationStateRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAuthenticationStateRequest message.
             * @function verify
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAuthenticationStateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.account != null && message.hasOwnProperty("account"))
                    if (!$util.isString(message.account))
                        return "account: string expected";
                return null;
            };

            /**
             * Creates a GetAuthenticationStateRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.GetAuthenticationStateRequest} GetAuthenticationStateRequest
             */
            GetAuthenticationStateRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.GetAuthenticationStateRequest)
                    return object;
                let message = new $root.kritor.authentication.GetAuthenticationStateRequest();
                if (object.account != null)
                    message.account = String(object.account);
                return message;
            };

            /**
             * Creates a plain object from a GetAuthenticationStateRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {kritor.authentication.GetAuthenticationStateRequest} message GetAuthenticationStateRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAuthenticationStateRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.account = "";
                if (message.account != null && message.hasOwnProperty("account"))
                    object.account = message.account;
                return object;
            };

            /**
             * Converts this GetAuthenticationStateRequest to JSON.
             * @function toJSON
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAuthenticationStateRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetAuthenticationStateRequest
             * @function getTypeUrl
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetAuthenticationStateRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.GetAuthenticationStateRequest";
            };

            return GetAuthenticationStateRequest;
        })();

        authentication.GetAuthenticationStateResponse = (function() {

            /**
             * Properties of a GetAuthenticationStateResponse.
             * @memberof kritor.authentication
             * @interface IGetAuthenticationStateResponse
             * @property {boolean|null} [is_required] GetAuthenticationStateResponse is_required
             */

            /**
             * Constructs a new GetAuthenticationStateResponse.
             * @memberof kritor.authentication
             * @classdesc Represents a GetAuthenticationStateResponse.
             * @implements IGetAuthenticationStateResponse
             * @constructor
             * @param {kritor.authentication.IGetAuthenticationStateResponse=} [properties] Properties to set
             */
            function GetAuthenticationStateResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetAuthenticationStateResponse is_required.
             * @member {boolean} is_required
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @instance
             */
            GetAuthenticationStateResponse.prototype.is_required = false;

            /**
             * Creates a new GetAuthenticationStateResponse instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {kritor.authentication.IGetAuthenticationStateResponse=} [properties] Properties to set
             * @returns {kritor.authentication.GetAuthenticationStateResponse} GetAuthenticationStateResponse instance
             */
            GetAuthenticationStateResponse.create = function create(properties) {
                return new GetAuthenticationStateResponse(properties);
            };

            /**
             * Encodes the specified GetAuthenticationStateResponse message. Does not implicitly {@link kritor.authentication.GetAuthenticationStateResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {kritor.authentication.IGetAuthenticationStateResponse} message GetAuthenticationStateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAuthenticationStateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.is_required != null && Object.hasOwnProperty.call(message, "is_required"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.is_required);
                return writer;
            };

            /**
             * Encodes the specified GetAuthenticationStateResponse message, length delimited. Does not implicitly {@link kritor.authentication.GetAuthenticationStateResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {kritor.authentication.IGetAuthenticationStateResponse} message GetAuthenticationStateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAuthenticationStateResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAuthenticationStateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.GetAuthenticationStateResponse} GetAuthenticationStateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAuthenticationStateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.GetAuthenticationStateResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.is_required = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAuthenticationStateResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.GetAuthenticationStateResponse} GetAuthenticationStateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAuthenticationStateResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAuthenticationStateResponse message.
             * @function verify
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAuthenticationStateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.is_required != null && message.hasOwnProperty("is_required"))
                    if (typeof message.is_required !== "boolean")
                        return "is_required: boolean expected";
                return null;
            };

            /**
             * Creates a GetAuthenticationStateResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.GetAuthenticationStateResponse} GetAuthenticationStateResponse
             */
            GetAuthenticationStateResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.GetAuthenticationStateResponse)
                    return object;
                let message = new $root.kritor.authentication.GetAuthenticationStateResponse();
                if (object.is_required != null)
                    message.is_required = Boolean(object.is_required);
                return message;
            };

            /**
             * Creates a plain object from a GetAuthenticationStateResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {kritor.authentication.GetAuthenticationStateResponse} message GetAuthenticationStateResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAuthenticationStateResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.is_required = false;
                if (message.is_required != null && message.hasOwnProperty("is_required"))
                    object.is_required = message.is_required;
                return object;
            };

            /**
             * Converts this GetAuthenticationStateResponse to JSON.
             * @function toJSON
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAuthenticationStateResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetAuthenticationStateResponse
             * @function getTypeUrl
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetAuthenticationStateResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.GetAuthenticationStateResponse";
            };

            return GetAuthenticationStateResponse;
        })();

        /**
         * TicketOperationResponseCode enum.
         * @name kritor.authentication.TicketOperationResponseCode
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} ERROR=1 ERROR value
         */
        authentication.TicketOperationResponseCode = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "ERROR"] = 1;
            return values;
        })();

        authentication.GetTicketRequest = (function() {

            /**
             * Properties of a GetTicketRequest.
             * @memberof kritor.authentication
             * @interface IGetTicketRequest
             * @property {string|null} [account] GetTicketRequest account
             * @property {string|null} [super_ticket] GetTicketRequest super_ticket
             */

            /**
             * Constructs a new GetTicketRequest.
             * @memberof kritor.authentication
             * @classdesc Represents a GetTicketRequest.
             * @implements IGetTicketRequest
             * @constructor
             * @param {kritor.authentication.IGetTicketRequest=} [properties] Properties to set
             */
            function GetTicketRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetTicketRequest account.
             * @member {string} account
             * @memberof kritor.authentication.GetTicketRequest
             * @instance
             */
            GetTicketRequest.prototype.account = "";

            /**
             * GetTicketRequest super_ticket.
             * @member {string} super_ticket
             * @memberof kritor.authentication.GetTicketRequest
             * @instance
             */
            GetTicketRequest.prototype.super_ticket = "";

            /**
             * Creates a new GetTicketRequest instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {kritor.authentication.IGetTicketRequest=} [properties] Properties to set
             * @returns {kritor.authentication.GetTicketRequest} GetTicketRequest instance
             */
            GetTicketRequest.create = function create(properties) {
                return new GetTicketRequest(properties);
            };

            /**
             * Encodes the specified GetTicketRequest message. Does not implicitly {@link kritor.authentication.GetTicketRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {kritor.authentication.IGetTicketRequest} message GetTicketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTicketRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
                if (message.super_ticket != null && Object.hasOwnProperty.call(message, "super_ticket"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.super_ticket);
                return writer;
            };

            /**
             * Encodes the specified GetTicketRequest message, length delimited. Does not implicitly {@link kritor.authentication.GetTicketRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {kritor.authentication.IGetTicketRequest} message GetTicketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTicketRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetTicketRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.GetTicketRequest} GetTicketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTicketRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.GetTicketRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.account = reader.string();
                            break;
                        }
                    case 2: {
                            message.super_ticket = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetTicketRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.GetTicketRequest} GetTicketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTicketRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetTicketRequest message.
             * @function verify
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetTicketRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.account != null && message.hasOwnProperty("account"))
                    if (!$util.isString(message.account))
                        return "account: string expected";
                if (message.super_ticket != null && message.hasOwnProperty("super_ticket"))
                    if (!$util.isString(message.super_ticket))
                        return "super_ticket: string expected";
                return null;
            };

            /**
             * Creates a GetTicketRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.GetTicketRequest} GetTicketRequest
             */
            GetTicketRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.GetTicketRequest)
                    return object;
                let message = new $root.kritor.authentication.GetTicketRequest();
                if (object.account != null)
                    message.account = String(object.account);
                if (object.super_ticket != null)
                    message.super_ticket = String(object.super_ticket);
                return message;
            };

            /**
             * Creates a plain object from a GetTicketRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {kritor.authentication.GetTicketRequest} message GetTicketRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetTicketRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.account = "";
                    object.super_ticket = "";
                }
                if (message.account != null && message.hasOwnProperty("account"))
                    object.account = message.account;
                if (message.super_ticket != null && message.hasOwnProperty("super_ticket"))
                    object.super_ticket = message.super_ticket;
                return object;
            };

            /**
             * Converts this GetTicketRequest to JSON.
             * @function toJSON
             * @memberof kritor.authentication.GetTicketRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetTicketRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetTicketRequest
             * @function getTypeUrl
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetTicketRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.GetTicketRequest";
            };

            return GetTicketRequest;
        })();

        authentication.GetTicketResponse = (function() {

            /**
             * Properties of a GetTicketResponse.
             * @memberof kritor.authentication
             * @interface IGetTicketResponse
             * @property {kritor.authentication.TicketOperationResponseCode|null} [code] GetTicketResponse code
             * @property {string|null} [msg] GetTicketResponse msg
             * @property {Array.<string>|null} [tickets] GetTicketResponse tickets
             */

            /**
             * Constructs a new GetTicketResponse.
             * @memberof kritor.authentication
             * @classdesc Represents a GetTicketResponse.
             * @implements IGetTicketResponse
             * @constructor
             * @param {kritor.authentication.IGetTicketResponse=} [properties] Properties to set
             */
            function GetTicketResponse(properties) {
                this.tickets = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetTicketResponse code.
             * @member {kritor.authentication.TicketOperationResponseCode} code
             * @memberof kritor.authentication.GetTicketResponse
             * @instance
             */
            GetTicketResponse.prototype.code = 0;

            /**
             * GetTicketResponse msg.
             * @member {string} msg
             * @memberof kritor.authentication.GetTicketResponse
             * @instance
             */
            GetTicketResponse.prototype.msg = "";

            /**
             * GetTicketResponse tickets.
             * @member {Array.<string>} tickets
             * @memberof kritor.authentication.GetTicketResponse
             * @instance
             */
            GetTicketResponse.prototype.tickets = $util.emptyArray;

            /**
             * Creates a new GetTicketResponse instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {kritor.authentication.IGetTicketResponse=} [properties] Properties to set
             * @returns {kritor.authentication.GetTicketResponse} GetTicketResponse instance
             */
            GetTicketResponse.create = function create(properties) {
                return new GetTicketResponse(properties);
            };

            /**
             * Encodes the specified GetTicketResponse message. Does not implicitly {@link kritor.authentication.GetTicketResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {kritor.authentication.IGetTicketResponse} message GetTicketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTicketResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.tickets != null && message.tickets.length)
                    for (let i = 0; i < message.tickets.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.tickets[i]);
                return writer;
            };

            /**
             * Encodes the specified GetTicketResponse message, length delimited. Does not implicitly {@link kritor.authentication.GetTicketResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {kritor.authentication.IGetTicketResponse} message GetTicketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTicketResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetTicketResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.GetTicketResponse} GetTicketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTicketResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.GetTicketResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.code = reader.int32();
                            break;
                        }
                    case 2: {
                            message.msg = reader.string();
                            break;
                        }
                    case 3: {
                            if (!(message.tickets && message.tickets.length))
                                message.tickets = [];
                            message.tickets.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetTicketResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.GetTicketResponse} GetTicketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTicketResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetTicketResponse message.
             * @function verify
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetTicketResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.msg != null && message.hasOwnProperty("msg"))
                    if (!$util.isString(message.msg))
                        return "msg: string expected";
                if (message.tickets != null && message.hasOwnProperty("tickets")) {
                    if (!Array.isArray(message.tickets))
                        return "tickets: array expected";
                    for (let i = 0; i < message.tickets.length; ++i)
                        if (!$util.isString(message.tickets[i]))
                            return "tickets: string[] expected";
                }
                return null;
            };

            /**
             * Creates a GetTicketResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.GetTicketResponse} GetTicketResponse
             */
            GetTicketResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.GetTicketResponse)
                    return object;
                let message = new $root.kritor.authentication.GetTicketResponse();
                switch (object.code) {
                default:
                    if (typeof object.code === "number") {
                        message.code = object.code;
                        break;
                    }
                    break;
                case "OK":
                case 0:
                    message.code = 0;
                    break;
                case "ERROR":
                case 1:
                    message.code = 1;
                    break;
                }
                if (object.msg != null)
                    message.msg = String(object.msg);
                if (object.tickets) {
                    if (!Array.isArray(object.tickets))
                        throw TypeError(".kritor.authentication.GetTicketResponse.tickets: array expected");
                    message.tickets = [];
                    for (let i = 0; i < object.tickets.length; ++i)
                        message.tickets[i] = String(object.tickets[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetTicketResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {kritor.authentication.GetTicketResponse} message GetTicketResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetTicketResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.tickets = [];
                if (options.defaults) {
                    object.code = options.enums === String ? "OK" : 0;
                    object.msg = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.kritor.authentication.TicketOperationResponseCode[message.code] === undefined ? message.code : $root.kritor.authentication.TicketOperationResponseCode[message.code] : message.code;
                if (message.msg != null && message.hasOwnProperty("msg"))
                    object.msg = message.msg;
                if (message.tickets && message.tickets.length) {
                    object.tickets = [];
                    for (let j = 0; j < message.tickets.length; ++j)
                        object.tickets[j] = message.tickets[j];
                }
                return object;
            };

            /**
             * Converts this GetTicketResponse to JSON.
             * @function toJSON
             * @memberof kritor.authentication.GetTicketResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetTicketResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetTicketResponse
             * @function getTypeUrl
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetTicketResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.GetTicketResponse";
            };

            return GetTicketResponse;
        })();

        authentication.AddTicketRequest = (function() {

            /**
             * Properties of an AddTicketRequest.
             * @memberof kritor.authentication
             * @interface IAddTicketRequest
             * @property {string|null} [account] AddTicketRequest account
             * @property {string|null} [super_ticket] AddTicketRequest super_ticket
             * @property {string|null} [ticket] AddTicketRequest ticket
             */

            /**
             * Constructs a new AddTicketRequest.
             * @memberof kritor.authentication
             * @classdesc Represents an AddTicketRequest.
             * @implements IAddTicketRequest
             * @constructor
             * @param {kritor.authentication.IAddTicketRequest=} [properties] Properties to set
             */
            function AddTicketRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddTicketRequest account.
             * @member {string} account
             * @memberof kritor.authentication.AddTicketRequest
             * @instance
             */
            AddTicketRequest.prototype.account = "";

            /**
             * AddTicketRequest super_ticket.
             * @member {string} super_ticket
             * @memberof kritor.authentication.AddTicketRequest
             * @instance
             */
            AddTicketRequest.prototype.super_ticket = "";

            /**
             * AddTicketRequest ticket.
             * @member {string} ticket
             * @memberof kritor.authentication.AddTicketRequest
             * @instance
             */
            AddTicketRequest.prototype.ticket = "";

            /**
             * Creates a new AddTicketRequest instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {kritor.authentication.IAddTicketRequest=} [properties] Properties to set
             * @returns {kritor.authentication.AddTicketRequest} AddTicketRequest instance
             */
            AddTicketRequest.create = function create(properties) {
                return new AddTicketRequest(properties);
            };

            /**
             * Encodes the specified AddTicketRequest message. Does not implicitly {@link kritor.authentication.AddTicketRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {kritor.authentication.IAddTicketRequest} message AddTicketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddTicketRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
                if (message.super_ticket != null && Object.hasOwnProperty.call(message, "super_ticket"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.super_ticket);
                if (message.ticket != null && Object.hasOwnProperty.call(message, "ticket"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.ticket);
                return writer;
            };

            /**
             * Encodes the specified AddTicketRequest message, length delimited. Does not implicitly {@link kritor.authentication.AddTicketRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {kritor.authentication.IAddTicketRequest} message AddTicketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddTicketRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddTicketRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.AddTicketRequest} AddTicketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddTicketRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.AddTicketRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.account = reader.string();
                            break;
                        }
                    case 2: {
                            message.super_ticket = reader.string();
                            break;
                        }
                    case 3: {
                            message.ticket = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddTicketRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.AddTicketRequest} AddTicketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddTicketRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddTicketRequest message.
             * @function verify
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddTicketRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.account != null && message.hasOwnProperty("account"))
                    if (!$util.isString(message.account))
                        return "account: string expected";
                if (message.super_ticket != null && message.hasOwnProperty("super_ticket"))
                    if (!$util.isString(message.super_ticket))
                        return "super_ticket: string expected";
                if (message.ticket != null && message.hasOwnProperty("ticket"))
                    if (!$util.isString(message.ticket))
                        return "ticket: string expected";
                return null;
            };

            /**
             * Creates an AddTicketRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.AddTicketRequest} AddTicketRequest
             */
            AddTicketRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.AddTicketRequest)
                    return object;
                let message = new $root.kritor.authentication.AddTicketRequest();
                if (object.account != null)
                    message.account = String(object.account);
                if (object.super_ticket != null)
                    message.super_ticket = String(object.super_ticket);
                if (object.ticket != null)
                    message.ticket = String(object.ticket);
                return message;
            };

            /**
             * Creates a plain object from an AddTicketRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {kritor.authentication.AddTicketRequest} message AddTicketRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddTicketRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.account = "";
                    object.super_ticket = "";
                    object.ticket = "";
                }
                if (message.account != null && message.hasOwnProperty("account"))
                    object.account = message.account;
                if (message.super_ticket != null && message.hasOwnProperty("super_ticket"))
                    object.super_ticket = message.super_ticket;
                if (message.ticket != null && message.hasOwnProperty("ticket"))
                    object.ticket = message.ticket;
                return object;
            };

            /**
             * Converts this AddTicketRequest to JSON.
             * @function toJSON
             * @memberof kritor.authentication.AddTicketRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddTicketRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddTicketRequest
             * @function getTypeUrl
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddTicketRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.AddTicketRequest";
            };

            return AddTicketRequest;
        })();

        authentication.AddTicketResponse = (function() {

            /**
             * Properties of an AddTicketResponse.
             * @memberof kritor.authentication
             * @interface IAddTicketResponse
             * @property {kritor.authentication.TicketOperationResponseCode|null} [code] AddTicketResponse code
             * @property {string|null} [msg] AddTicketResponse msg
             */

            /**
             * Constructs a new AddTicketResponse.
             * @memberof kritor.authentication
             * @classdesc Represents an AddTicketResponse.
             * @implements IAddTicketResponse
             * @constructor
             * @param {kritor.authentication.IAddTicketResponse=} [properties] Properties to set
             */
            function AddTicketResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddTicketResponse code.
             * @member {kritor.authentication.TicketOperationResponseCode} code
             * @memberof kritor.authentication.AddTicketResponse
             * @instance
             */
            AddTicketResponse.prototype.code = 0;

            /**
             * AddTicketResponse msg.
             * @member {string} msg
             * @memberof kritor.authentication.AddTicketResponse
             * @instance
             */
            AddTicketResponse.prototype.msg = "";

            /**
             * Creates a new AddTicketResponse instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {kritor.authentication.IAddTicketResponse=} [properties] Properties to set
             * @returns {kritor.authentication.AddTicketResponse} AddTicketResponse instance
             */
            AddTicketResponse.create = function create(properties) {
                return new AddTicketResponse(properties);
            };

            /**
             * Encodes the specified AddTicketResponse message. Does not implicitly {@link kritor.authentication.AddTicketResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {kritor.authentication.IAddTicketResponse} message AddTicketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddTicketResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                return writer;
            };

            /**
             * Encodes the specified AddTicketResponse message, length delimited. Does not implicitly {@link kritor.authentication.AddTicketResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {kritor.authentication.IAddTicketResponse} message AddTicketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddTicketResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddTicketResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.AddTicketResponse} AddTicketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddTicketResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.AddTicketResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.code = reader.int32();
                            break;
                        }
                    case 2: {
                            message.msg = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddTicketResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.AddTicketResponse} AddTicketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddTicketResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddTicketResponse message.
             * @function verify
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddTicketResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.msg != null && message.hasOwnProperty("msg"))
                    if (!$util.isString(message.msg))
                        return "msg: string expected";
                return null;
            };

            /**
             * Creates an AddTicketResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.AddTicketResponse} AddTicketResponse
             */
            AddTicketResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.AddTicketResponse)
                    return object;
                let message = new $root.kritor.authentication.AddTicketResponse();
                switch (object.code) {
                default:
                    if (typeof object.code === "number") {
                        message.code = object.code;
                        break;
                    }
                    break;
                case "OK":
                case 0:
                    message.code = 0;
                    break;
                case "ERROR":
                case 1:
                    message.code = 1;
                    break;
                }
                if (object.msg != null)
                    message.msg = String(object.msg);
                return message;
            };

            /**
             * Creates a plain object from an AddTicketResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {kritor.authentication.AddTicketResponse} message AddTicketResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddTicketResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.code = options.enums === String ? "OK" : 0;
                    object.msg = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.kritor.authentication.TicketOperationResponseCode[message.code] === undefined ? message.code : $root.kritor.authentication.TicketOperationResponseCode[message.code] : message.code;
                if (message.msg != null && message.hasOwnProperty("msg"))
                    object.msg = message.msg;
                return object;
            };

            /**
             * Converts this AddTicketResponse to JSON.
             * @function toJSON
             * @memberof kritor.authentication.AddTicketResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddTicketResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddTicketResponse
             * @function getTypeUrl
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddTicketResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.AddTicketResponse";
            };

            return AddTicketResponse;
        })();

        authentication.DeleteTicketRequest = (function() {

            /**
             * Properties of a DeleteTicketRequest.
             * @memberof kritor.authentication
             * @interface IDeleteTicketRequest
             * @property {string|null} [account] DeleteTicketRequest account
             * @property {string|null} [super_ticket] DeleteTicketRequest super_ticket
             * @property {string|null} [ticket] DeleteTicketRequest ticket
             */

            /**
             * Constructs a new DeleteTicketRequest.
             * @memberof kritor.authentication
             * @classdesc Represents a DeleteTicketRequest.
             * @implements IDeleteTicketRequest
             * @constructor
             * @param {kritor.authentication.IDeleteTicketRequest=} [properties] Properties to set
             */
            function DeleteTicketRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteTicketRequest account.
             * @member {string} account
             * @memberof kritor.authentication.DeleteTicketRequest
             * @instance
             */
            DeleteTicketRequest.prototype.account = "";

            /**
             * DeleteTicketRequest super_ticket.
             * @member {string} super_ticket
             * @memberof kritor.authentication.DeleteTicketRequest
             * @instance
             */
            DeleteTicketRequest.prototype.super_ticket = "";

            /**
             * DeleteTicketRequest ticket.
             * @member {string} ticket
             * @memberof kritor.authentication.DeleteTicketRequest
             * @instance
             */
            DeleteTicketRequest.prototype.ticket = "";

            /**
             * Creates a new DeleteTicketRequest instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {kritor.authentication.IDeleteTicketRequest=} [properties] Properties to set
             * @returns {kritor.authentication.DeleteTicketRequest} DeleteTicketRequest instance
             */
            DeleteTicketRequest.create = function create(properties) {
                return new DeleteTicketRequest(properties);
            };

            /**
             * Encodes the specified DeleteTicketRequest message. Does not implicitly {@link kritor.authentication.DeleteTicketRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {kritor.authentication.IDeleteTicketRequest} message DeleteTicketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteTicketRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
                if (message.super_ticket != null && Object.hasOwnProperty.call(message, "super_ticket"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.super_ticket);
                if (message.ticket != null && Object.hasOwnProperty.call(message, "ticket"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.ticket);
                return writer;
            };

            /**
             * Encodes the specified DeleteTicketRequest message, length delimited. Does not implicitly {@link kritor.authentication.DeleteTicketRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {kritor.authentication.IDeleteTicketRequest} message DeleteTicketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteTicketRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteTicketRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.DeleteTicketRequest} DeleteTicketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteTicketRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.DeleteTicketRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.account = reader.string();
                            break;
                        }
                    case 2: {
                            message.super_ticket = reader.string();
                            break;
                        }
                    case 3: {
                            message.ticket = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteTicketRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.DeleteTicketRequest} DeleteTicketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteTicketRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteTicketRequest message.
             * @function verify
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteTicketRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.account != null && message.hasOwnProperty("account"))
                    if (!$util.isString(message.account))
                        return "account: string expected";
                if (message.super_ticket != null && message.hasOwnProperty("super_ticket"))
                    if (!$util.isString(message.super_ticket))
                        return "super_ticket: string expected";
                if (message.ticket != null && message.hasOwnProperty("ticket"))
                    if (!$util.isString(message.ticket))
                        return "ticket: string expected";
                return null;
            };

            /**
             * Creates a DeleteTicketRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.DeleteTicketRequest} DeleteTicketRequest
             */
            DeleteTicketRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.DeleteTicketRequest)
                    return object;
                let message = new $root.kritor.authentication.DeleteTicketRequest();
                if (object.account != null)
                    message.account = String(object.account);
                if (object.super_ticket != null)
                    message.super_ticket = String(object.super_ticket);
                if (object.ticket != null)
                    message.ticket = String(object.ticket);
                return message;
            };

            /**
             * Creates a plain object from a DeleteTicketRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {kritor.authentication.DeleteTicketRequest} message DeleteTicketRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteTicketRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.account = "";
                    object.super_ticket = "";
                    object.ticket = "";
                }
                if (message.account != null && message.hasOwnProperty("account"))
                    object.account = message.account;
                if (message.super_ticket != null && message.hasOwnProperty("super_ticket"))
                    object.super_ticket = message.super_ticket;
                if (message.ticket != null && message.hasOwnProperty("ticket"))
                    object.ticket = message.ticket;
                return object;
            };

            /**
             * Converts this DeleteTicketRequest to JSON.
             * @function toJSON
             * @memberof kritor.authentication.DeleteTicketRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteTicketRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteTicketRequest
             * @function getTypeUrl
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteTicketRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.DeleteTicketRequest";
            };

            return DeleteTicketRequest;
        })();

        authentication.DeleteTicketResponse = (function() {

            /**
             * Properties of a DeleteTicketResponse.
             * @memberof kritor.authentication
             * @interface IDeleteTicketResponse
             * @property {kritor.authentication.TicketOperationResponseCode|null} [code] DeleteTicketResponse code
             * @property {string|null} [msg] DeleteTicketResponse msg
             */

            /**
             * Constructs a new DeleteTicketResponse.
             * @memberof kritor.authentication
             * @classdesc Represents a DeleteTicketResponse.
             * @implements IDeleteTicketResponse
             * @constructor
             * @param {kritor.authentication.IDeleteTicketResponse=} [properties] Properties to set
             */
            function DeleteTicketResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteTicketResponse code.
             * @member {kritor.authentication.TicketOperationResponseCode} code
             * @memberof kritor.authentication.DeleteTicketResponse
             * @instance
             */
            DeleteTicketResponse.prototype.code = 0;

            /**
             * DeleteTicketResponse msg.
             * @member {string} msg
             * @memberof kritor.authentication.DeleteTicketResponse
             * @instance
             */
            DeleteTicketResponse.prototype.msg = "";

            /**
             * Creates a new DeleteTicketResponse instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {kritor.authentication.IDeleteTicketResponse=} [properties] Properties to set
             * @returns {kritor.authentication.DeleteTicketResponse} DeleteTicketResponse instance
             */
            DeleteTicketResponse.create = function create(properties) {
                return new DeleteTicketResponse(properties);
            };

            /**
             * Encodes the specified DeleteTicketResponse message. Does not implicitly {@link kritor.authentication.DeleteTicketResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {kritor.authentication.IDeleteTicketResponse} message DeleteTicketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteTicketResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                return writer;
            };

            /**
             * Encodes the specified DeleteTicketResponse message, length delimited. Does not implicitly {@link kritor.authentication.DeleteTicketResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {kritor.authentication.IDeleteTicketResponse} message DeleteTicketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteTicketResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteTicketResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.DeleteTicketResponse} DeleteTicketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteTicketResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.DeleteTicketResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.code = reader.int32();
                            break;
                        }
                    case 2: {
                            message.msg = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteTicketResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.DeleteTicketResponse} DeleteTicketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteTicketResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteTicketResponse message.
             * @function verify
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteTicketResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.msg != null && message.hasOwnProperty("msg"))
                    if (!$util.isString(message.msg))
                        return "msg: string expected";
                return null;
            };

            /**
             * Creates a DeleteTicketResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.DeleteTicketResponse} DeleteTicketResponse
             */
            DeleteTicketResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.DeleteTicketResponse)
                    return object;
                let message = new $root.kritor.authentication.DeleteTicketResponse();
                switch (object.code) {
                default:
                    if (typeof object.code === "number") {
                        message.code = object.code;
                        break;
                    }
                    break;
                case "OK":
                case 0:
                    message.code = 0;
                    break;
                case "ERROR":
                case 1:
                    message.code = 1;
                    break;
                }
                if (object.msg != null)
                    message.msg = String(object.msg);
                return message;
            };

            /**
             * Creates a plain object from a DeleteTicketResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {kritor.authentication.DeleteTicketResponse} message DeleteTicketResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteTicketResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.code = options.enums === String ? "OK" : 0;
                    object.msg = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.kritor.authentication.TicketOperationResponseCode[message.code] === undefined ? message.code : $root.kritor.authentication.TicketOperationResponseCode[message.code] : message.code;
                if (message.msg != null && message.hasOwnProperty("msg"))
                    object.msg = message.msg;
                return object;
            };

            /**
             * Converts this DeleteTicketResponse to JSON.
             * @function toJSON
             * @memberof kritor.authentication.DeleteTicketResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteTicketResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteTicketResponse
             * @function getTypeUrl
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteTicketResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.DeleteTicketResponse";
            };

            return DeleteTicketResponse;
        })();

        return authentication;
    })();

    kritor.common = (function() {

        /**
         * Namespace common.
         * @memberof kritor
         * @namespace
         */
        const common = {};

        /**
         * Scene enum.
         * @name kritor.common.Scene
         * @enum {number}
         * @property {number} GROUP=0 GROUP value
         * @property {number} FRIEND=1 FRIEND value
         * @property {number} GUILD=2 GUILD value
         * @property {number} STRANGER_FROM_GROUP=10 STRANGER_FROM_GROUP value
         * @property {number} NEARBY=5 NEARBY value
         * @property {number} STRANGER=9 STRANGER value
         */
        common.Scene = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "GROUP"] = 0;
            values[valuesById[1] = "FRIEND"] = 1;
            values[valuesById[2] = "GUILD"] = 2;
            values[valuesById[10] = "STRANGER_FROM_GROUP"] = 10;
            values[valuesById[5] = "NEARBY"] = 5;
            values[valuesById[9] = "STRANGER"] = 9;
            return values;
        })();

        common.Contact = (function() {

            /**
             * Properties of a Contact.
             * @memberof kritor.common
             * @interface IContact
             * @property {kritor.common.Scene|null} [scene] Contact scene
             * @property {string|null} [peer] Contact peer
             * @property {string|null} [sub_peer] Contact sub_peer
             */

            /**
             * Constructs a new Contact.
             * @memberof kritor.common
             * @classdesc Represents a Contact.
             * @implements IContact
             * @constructor
             * @param {kritor.common.IContact=} [properties] Properties to set
             */
            function Contact(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Contact scene.
             * @member {kritor.common.Scene} scene
             * @memberof kritor.common.Contact
             * @instance
             */
            Contact.prototype.scene = 0;

            /**
             * Contact peer.
             * @member {string} peer
             * @memberof kritor.common.Contact
             * @instance
             */
            Contact.prototype.peer = "";

            /**
             * Contact sub_peer.
             * @member {string|null|undefined} sub_peer
             * @memberof kritor.common.Contact
             * @instance
             */
            Contact.prototype.sub_peer = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Contact _sub_peer.
             * @member {"sub_peer"|undefined} _sub_peer
             * @memberof kritor.common.Contact
             * @instance
             */
            Object.defineProperty(Contact.prototype, "_sub_peer", {
                get: $util.oneOfGetter($oneOfFields = ["sub_peer"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Contact instance using the specified properties.
             * @function create
             * @memberof kritor.common.Contact
             * @static
             * @param {kritor.common.IContact=} [properties] Properties to set
             * @returns {kritor.common.Contact} Contact instance
             */
            Contact.create = function create(properties) {
                return new Contact(properties);
            };

            /**
             * Encodes the specified Contact message. Does not implicitly {@link kritor.common.Contact.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.Contact
             * @static
             * @param {kritor.common.IContact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contact.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scene != null && Object.hasOwnProperty.call(message, "scene"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.scene);
                if (message.peer != null && Object.hasOwnProperty.call(message, "peer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.peer);
                if (message.sub_peer != null && Object.hasOwnProperty.call(message, "sub_peer"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.sub_peer);
                return writer;
            };

            /**
             * Encodes the specified Contact message, length delimited. Does not implicitly {@link kritor.common.Contact.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.Contact
             * @static
             * @param {kritor.common.IContact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contact.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Contact message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contact.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.Contact();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.scene = reader.int32();
                            break;
                        }
                    case 2: {
                            message.peer = reader.string();
                            break;
                        }
                    case 3: {
                            message.sub_peer = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Contact message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contact.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Contact message.
             * @function verify
             * @memberof kritor.common.Contact
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Contact.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.scene != null && message.hasOwnProperty("scene"))
                    switch (message.scene) {
                    default:
                        return "scene: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 5:
                    case 9:
                        break;
                    }
                if (message.peer != null && message.hasOwnProperty("peer"))
                    if (!$util.isString(message.peer))
                        return "peer: string expected";
                if (message.sub_peer != null && message.hasOwnProperty("sub_peer")) {
                    properties._sub_peer = 1;
                    if (!$util.isString(message.sub_peer))
                        return "sub_peer: string expected";
                }
                return null;
            };

            /**
             * Creates a Contact message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.Contact
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.Contact} Contact
             */
            Contact.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.Contact)
                    return object;
                let message = new $root.kritor.common.Contact();
                switch (object.scene) {
                default:
                    if (typeof object.scene === "number") {
                        message.scene = object.scene;
                        break;
                    }
                    break;
                case "GROUP":
                case 0:
                    message.scene = 0;
                    break;
                case "FRIEND":
                case 1:
                    message.scene = 1;
                    break;
                case "GUILD":
                case 2:
                    message.scene = 2;
                    break;
                case "STRANGER_FROM_GROUP":
                case 10:
                    message.scene = 10;
                    break;
                case "NEARBY":
                case 5:
                    message.scene = 5;
                    break;
                case "STRANGER":
                case 9:
                    message.scene = 9;
                    break;
                }
                if (object.peer != null)
                    message.peer = String(object.peer);
                if (object.sub_peer != null)
                    message.sub_peer = String(object.sub_peer);
                return message;
            };

            /**
             * Creates a plain object from a Contact message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.Contact
             * @static
             * @param {kritor.common.Contact} message Contact
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Contact.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.scene = options.enums === String ? "GROUP" : 0;
                    object.peer = "";
                }
                if (message.scene != null && message.hasOwnProperty("scene"))
                    object.scene = options.enums === String ? $root.kritor.common.Scene[message.scene] === undefined ? message.scene : $root.kritor.common.Scene[message.scene] : message.scene;
                if (message.peer != null && message.hasOwnProperty("peer"))
                    object.peer = message.peer;
                if (message.sub_peer != null && message.hasOwnProperty("sub_peer")) {
                    object.sub_peer = message.sub_peer;
                    if (options.oneofs)
                        object._sub_peer = "sub_peer";
                }
                return object;
            };

            /**
             * Converts this Contact to JSON.
             * @function toJSON
             * @memberof kritor.common.Contact
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Contact.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Contact
             * @function getTypeUrl
             * @memberof kritor.common.Contact
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Contact.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.Contact";
            };

            return Contact;
        })();

        common.Sender = (function() {

            /**
             * Properties of a Sender.
             * @memberof kritor.common
             * @interface ISender
             * @property {string|null} [uid] Sender uid
             * @property {number|Long|null} [uin] Sender uin
             * @property {string|null} [nick] Sender nick
             */

            /**
             * Constructs a new Sender.
             * @memberof kritor.common
             * @classdesc Represents a Sender.
             * @implements ISender
             * @constructor
             * @param {kritor.common.ISender=} [properties] Properties to set
             */
            function Sender(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sender uid.
             * @member {string} uid
             * @memberof kritor.common.Sender
             * @instance
             */
            Sender.prototype.uid = "";

            /**
             * Sender uin.
             * @member {number|Long|null|undefined} uin
             * @memberof kritor.common.Sender
             * @instance
             */
            Sender.prototype.uin = null;

            /**
             * Sender nick.
             * @member {string|null|undefined} nick
             * @memberof kritor.common.Sender
             * @instance
             */
            Sender.prototype.nick = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Sender _uin.
             * @member {"uin"|undefined} _uin
             * @memberof kritor.common.Sender
             * @instance
             */
            Object.defineProperty(Sender.prototype, "_uin", {
                get: $util.oneOfGetter($oneOfFields = ["uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Sender _nick.
             * @member {"nick"|undefined} _nick
             * @memberof kritor.common.Sender
             * @instance
             */
            Object.defineProperty(Sender.prototype, "_nick", {
                get: $util.oneOfGetter($oneOfFields = ["nick"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Sender instance using the specified properties.
             * @function create
             * @memberof kritor.common.Sender
             * @static
             * @param {kritor.common.ISender=} [properties] Properties to set
             * @returns {kritor.common.Sender} Sender instance
             */
            Sender.create = function create(properties) {
                return new Sender(properties);
            };

            /**
             * Encodes the specified Sender message. Does not implicitly {@link kritor.common.Sender.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.Sender
             * @static
             * @param {kritor.common.ISender} message Sender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sender.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.nick);
                return writer;
            };

            /**
             * Encodes the specified Sender message, length delimited. Does not implicitly {@link kritor.common.Sender.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.Sender
             * @static
             * @param {kritor.common.ISender} message Sender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sender.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sender message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.Sender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.Sender} Sender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sender.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.Sender();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.nick = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sender message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.Sender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.Sender} Sender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sender.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Sender message.
             * @function verify
             * @memberof kritor.common.Sender
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Sender.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    properties._uin = 1;
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                }
                if (message.nick != null && message.hasOwnProperty("nick")) {
                    properties._nick = 1;
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                }
                return null;
            };

            /**
             * Creates a Sender message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.Sender
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.Sender} Sender
             */
            Sender.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.Sender)
                    return object;
                let message = new $root.kritor.common.Sender();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.nick != null)
                    message.nick = String(object.nick);
                return message;
            };

            /**
             * Creates a plain object from a Sender message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.Sender
             * @static
             * @param {kritor.common.Sender} message Sender
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sender.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.uid = "";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                    if (options.oneofs)
                        object._uin = "uin";
                }
                if (message.nick != null && message.hasOwnProperty("nick")) {
                    object.nick = message.nick;
                    if (options.oneofs)
                        object._nick = "nick";
                }
                return object;
            };

            /**
             * Converts this Sender to JSON.
             * @function toJSON
             * @memberof kritor.common.Sender
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sender.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Sender
             * @function getTypeUrl
             * @memberof kritor.common.Sender
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Sender.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.Sender";
            };

            return Sender;
        })();

        common.PushMessageBody = (function() {

            /**
             * Properties of a PushMessageBody.
             * @memberof kritor.common
             * @interface IPushMessageBody
             * @property {number|null} [time] PushMessageBody time
             * @property {string|null} [message_id] PushMessageBody message_id
             * @property {number|Long|null} [message_seq] PushMessageBody message_seq
             * @property {kritor.common.IContact|null} [contact] PushMessageBody contact
             * @property {kritor.common.ISender|null} [sender] PushMessageBody sender
             * @property {Array.<kritor.common.IElement>|null} [elements] PushMessageBody elements
             */

            /**
             * Constructs a new PushMessageBody.
             * @memberof kritor.common
             * @classdesc Represents a PushMessageBody.
             * @implements IPushMessageBody
             * @constructor
             * @param {kritor.common.IPushMessageBody=} [properties] Properties to set
             */
            function PushMessageBody(properties) {
                this.elements = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PushMessageBody time.
             * @member {number} time
             * @memberof kritor.common.PushMessageBody
             * @instance
             */
            PushMessageBody.prototype.time = 0;

            /**
             * PushMessageBody message_id.
             * @member {string} message_id
             * @memberof kritor.common.PushMessageBody
             * @instance
             */
            PushMessageBody.prototype.message_id = "";

            /**
             * PushMessageBody message_seq.
             * @member {number|Long} message_seq
             * @memberof kritor.common.PushMessageBody
             * @instance
             */
            PushMessageBody.prototype.message_seq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * PushMessageBody contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.common.PushMessageBody
             * @instance
             */
            PushMessageBody.prototype.contact = null;

            /**
             * PushMessageBody sender.
             * @member {kritor.common.ISender|null|undefined} sender
             * @memberof kritor.common.PushMessageBody
             * @instance
             */
            PushMessageBody.prototype.sender = null;

            /**
             * PushMessageBody elements.
             * @member {Array.<kritor.common.IElement>} elements
             * @memberof kritor.common.PushMessageBody
             * @instance
             */
            PushMessageBody.prototype.elements = $util.emptyArray;

            /**
             * Creates a new PushMessageBody instance using the specified properties.
             * @function create
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {kritor.common.IPushMessageBody=} [properties] Properties to set
             * @returns {kritor.common.PushMessageBody} PushMessageBody instance
             */
            PushMessageBody.create = function create(properties) {
                return new PushMessageBody(properties);
            };

            /**
             * Encodes the specified PushMessageBody message. Does not implicitly {@link kritor.common.PushMessageBody.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {kritor.common.IPushMessageBody} message PushMessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushMessageBody.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.time);
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message_id);
                if (message.message_seq != null && Object.hasOwnProperty.call(message, "message_seq"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.message_seq);
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    $root.kritor.common.Sender.encode(message.sender, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.elements != null && message.elements.length)
                    for (let i = 0; i < message.elements.length; ++i)
                        $root.kritor.common.Element.encode(message.elements[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PushMessageBody message, length delimited. Does not implicitly {@link kritor.common.PushMessageBody.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {kritor.common.IPushMessageBody} message PushMessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushMessageBody.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PushMessageBody message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.PushMessageBody} PushMessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushMessageBody.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.PushMessageBody();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.time = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.message_id = reader.string();
                            break;
                        }
                    case 3: {
                            message.message_seq = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.sender = $root.kritor.common.Sender.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            if (!(message.elements && message.elements.length))
                                message.elements = [];
                            message.elements.push($root.kritor.common.Element.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PushMessageBody message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.PushMessageBody} PushMessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushMessageBody.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PushMessageBody message.
             * @function verify
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PushMessageBody.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time))
                        return "time: integer expected";
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                if (message.message_seq != null && message.hasOwnProperty("message_seq"))
                    if (!$util.isInteger(message.message_seq) && !(message.message_seq && $util.isInteger(message.message_seq.low) && $util.isInteger(message.message_seq.high)))
                        return "message_seq: integer|Long expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.sender != null && message.hasOwnProperty("sender")) {
                    let error = $root.kritor.common.Sender.verify(message.sender);
                    if (error)
                        return "sender." + error;
                }
                if (message.elements != null && message.hasOwnProperty("elements")) {
                    if (!Array.isArray(message.elements))
                        return "elements: array expected";
                    for (let i = 0; i < message.elements.length; ++i) {
                        let error = $root.kritor.common.Element.verify(message.elements[i]);
                        if (error)
                            return "elements." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a PushMessageBody message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.PushMessageBody} PushMessageBody
             */
            PushMessageBody.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.PushMessageBody)
                    return object;
                let message = new $root.kritor.common.PushMessageBody();
                if (object.time != null)
                    message.time = object.time >>> 0;
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                if (object.message_seq != null)
                    if ($util.Long)
                        (message.message_seq = $util.Long.fromValue(object.message_seq)).unsigned = true;
                    else if (typeof object.message_seq === "string")
                        message.message_seq = parseInt(object.message_seq, 10);
                    else if (typeof object.message_seq === "number")
                        message.message_seq = object.message_seq;
                    else if (typeof object.message_seq === "object")
                        message.message_seq = new $util.LongBits(object.message_seq.low >>> 0, object.message_seq.high >>> 0).toNumber(true);
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.common.PushMessageBody.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.sender != null) {
                    if (typeof object.sender !== "object")
                        throw TypeError(".kritor.common.PushMessageBody.sender: object expected");
                    message.sender = $root.kritor.common.Sender.fromObject(object.sender);
                }
                if (object.elements) {
                    if (!Array.isArray(object.elements))
                        throw TypeError(".kritor.common.PushMessageBody.elements: array expected");
                    message.elements = [];
                    for (let i = 0; i < object.elements.length; ++i) {
                        if (typeof object.elements[i] !== "object")
                            throw TypeError(".kritor.common.PushMessageBody.elements: object expected");
                        message.elements[i] = $root.kritor.common.Element.fromObject(object.elements[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a PushMessageBody message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {kritor.common.PushMessageBody} message PushMessageBody
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PushMessageBody.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.elements = [];
                if (options.defaults) {
                    object.time = 0;
                    object.message_id = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.message_seq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.message_seq = options.longs === String ? "0" : 0;
                    object.contact = null;
                    object.sender = null;
                }
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = message.time;
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    object.message_id = message.message_id;
                if (message.message_seq != null && message.hasOwnProperty("message_seq"))
                    if (typeof message.message_seq === "number")
                        object.message_seq = options.longs === String ? String(message.message_seq) : message.message_seq;
                    else
                        object.message_seq = options.longs === String ? $util.Long.prototype.toString.call(message.message_seq) : options.longs === Number ? new $util.LongBits(message.message_seq.low >>> 0, message.message_seq.high >>> 0).toNumber(true) : message.message_seq;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.sender != null && message.hasOwnProperty("sender"))
                    object.sender = $root.kritor.common.Sender.toObject(message.sender, options);
                if (message.elements && message.elements.length) {
                    object.elements = [];
                    for (let j = 0; j < message.elements.length; ++j)
                        object.elements[j] = $root.kritor.common.Element.toObject(message.elements[j], options);
                }
                return object;
            };

            /**
             * Converts this PushMessageBody to JSON.
             * @function toJSON
             * @memberof kritor.common.PushMessageBody
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PushMessageBody.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PushMessageBody
             * @function getTypeUrl
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PushMessageBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.PushMessageBody";
            };

            return PushMessageBody;
        })();

        common.ForwardMessageBody = (function() {

            /**
             * Properties of a ForwardMessageBody.
             * @memberof kritor.common
             * @interface IForwardMessageBody
             * @property {string|null} [message_id] ForwardMessageBody message_id
             * @property {kritor.common.IPushMessageBody|null} [message] ForwardMessageBody message
             */

            /**
             * Constructs a new ForwardMessageBody.
             * @memberof kritor.common
             * @classdesc Represents a ForwardMessageBody.
             * @implements IForwardMessageBody
             * @constructor
             * @param {kritor.common.IForwardMessageBody=} [properties] Properties to set
             */
            function ForwardMessageBody(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForwardMessageBody message_id.
             * @member {string|null|undefined} message_id
             * @memberof kritor.common.ForwardMessageBody
             * @instance
             */
            ForwardMessageBody.prototype.message_id = null;

            /**
             * ForwardMessageBody message.
             * @member {kritor.common.IPushMessageBody|null|undefined} message
             * @memberof kritor.common.ForwardMessageBody
             * @instance
             */
            ForwardMessageBody.prototype.message = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ForwardMessageBody forward_message.
             * @member {"message_id"|"message"|undefined} forward_message
             * @memberof kritor.common.ForwardMessageBody
             * @instance
             */
            Object.defineProperty(ForwardMessageBody.prototype, "forward_message", {
                get: $util.oneOfGetter($oneOfFields = ["message_id", "message"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ForwardMessageBody instance using the specified properties.
             * @function create
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {kritor.common.IForwardMessageBody=} [properties] Properties to set
             * @returns {kritor.common.ForwardMessageBody} ForwardMessageBody instance
             */
            ForwardMessageBody.create = function create(properties) {
                return new ForwardMessageBody(properties);
            };

            /**
             * Encodes the specified ForwardMessageBody message. Does not implicitly {@link kritor.common.ForwardMessageBody.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {kritor.common.IForwardMessageBody} message ForwardMessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardMessageBody.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.message_id);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.kritor.common.PushMessageBody.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ForwardMessageBody message, length delimited. Does not implicitly {@link kritor.common.ForwardMessageBody.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {kritor.common.IForwardMessageBody} message ForwardMessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardMessageBody.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForwardMessageBody message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ForwardMessageBody} ForwardMessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardMessageBody.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ForwardMessageBody();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.message_id = reader.string();
                            break;
                        }
                    case 2: {
                            message.message = $root.kritor.common.PushMessageBody.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForwardMessageBody message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ForwardMessageBody} ForwardMessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardMessageBody.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForwardMessageBody message.
             * @function verify
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForwardMessageBody.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.message_id != null && message.hasOwnProperty("message_id")) {
                    properties.forward_message = 1;
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                }
                if (message.message != null && message.hasOwnProperty("message")) {
                    if (properties.forward_message === 1)
                        return "forward_message: multiple values";
                    properties.forward_message = 1;
                    {
                        let error = $root.kritor.common.PushMessageBody.verify(message.message);
                        if (error)
                            return "message." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ForwardMessageBody message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ForwardMessageBody} ForwardMessageBody
             */
            ForwardMessageBody.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ForwardMessageBody)
                    return object;
                let message = new $root.kritor.common.ForwardMessageBody();
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".kritor.common.ForwardMessageBody.message: object expected");
                    message.message = $root.kritor.common.PushMessageBody.fromObject(object.message);
                }
                return message;
            };

            /**
             * Creates a plain object from a ForwardMessageBody message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {kritor.common.ForwardMessageBody} message ForwardMessageBody
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForwardMessageBody.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.message_id != null && message.hasOwnProperty("message_id")) {
                    object.message_id = message.message_id;
                    if (options.oneofs)
                        object.forward_message = "message_id";
                }
                if (message.message != null && message.hasOwnProperty("message")) {
                    object.message = $root.kritor.common.PushMessageBody.toObject(message.message, options);
                    if (options.oneofs)
                        object.forward_message = "message";
                }
                return object;
            };

            /**
             * Converts this ForwardMessageBody to JSON.
             * @function toJSON
             * @memberof kritor.common.ForwardMessageBody
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForwardMessageBody.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ForwardMessageBody
             * @function getTypeUrl
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ForwardMessageBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ForwardMessageBody";
            };

            return ForwardMessageBody;
        })();

        common.EssenceMessageBody = (function() {

            /**
             * Properties of an EssenceMessageBody.
             * @memberof kritor.common
             * @interface IEssenceMessageBody
             * @property {number|null} [group_id] EssenceMessageBody group_id
             * @property {string|null} [sender_uid] EssenceMessageBody sender_uid
             * @property {number|Long|null} [sender_uin] EssenceMessageBody sender_uin
             * @property {string|null} [sender_nick] EssenceMessageBody sender_nick
             * @property {number|Long|null} [operator_uid] EssenceMessageBody operator_uid
             * @property {number|Long|null} [operator_uin] EssenceMessageBody operator_uin
             * @property {string|null} [operator_nick] EssenceMessageBody operator_nick
             * @property {number|null} [operation_time] EssenceMessageBody operation_time
             * @property {number|null} [message_time] EssenceMessageBody message_time
             * @property {string|null} [message_id] EssenceMessageBody message_id
             * @property {number|Long|null} [message_seq] EssenceMessageBody message_seq
             * @property {string|null} [json_elements] EssenceMessageBody json_elements
             */

            /**
             * Constructs a new EssenceMessageBody.
             * @memberof kritor.common
             * @classdesc Represents an EssenceMessageBody.
             * @implements IEssenceMessageBody
             * @constructor
             * @param {kritor.common.IEssenceMessageBody=} [properties] Properties to set
             */
            function EssenceMessageBody(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EssenceMessageBody group_id.
             * @member {number} group_id
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.group_id = 0;

            /**
             * EssenceMessageBody sender_uid.
             * @member {string} sender_uid
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.sender_uid = "";

            /**
             * EssenceMessageBody sender_uin.
             * @member {number|Long} sender_uin
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.sender_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessageBody sender_nick.
             * @member {string} sender_nick
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.sender_nick = "";

            /**
             * EssenceMessageBody operator_uid.
             * @member {number|Long} operator_uid
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.operator_uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessageBody operator_uin.
             * @member {number|Long} operator_uin
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.operator_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessageBody operator_nick.
             * @member {string} operator_nick
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.operator_nick = "";

            /**
             * EssenceMessageBody operation_time.
             * @member {number} operation_time
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.operation_time = 0;

            /**
             * EssenceMessageBody message_time.
             * @member {number} message_time
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.message_time = 0;

            /**
             * EssenceMessageBody message_id.
             * @member {string} message_id
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.message_id = "";

            /**
             * EssenceMessageBody message_seq.
             * @member {number|Long} message_seq
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.message_seq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessageBody json_elements.
             * @member {string} json_elements
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.json_elements = "";

            /**
             * Creates a new EssenceMessageBody instance using the specified properties.
             * @function create
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {kritor.common.IEssenceMessageBody=} [properties] Properties to set
             * @returns {kritor.common.EssenceMessageBody} EssenceMessageBody instance
             */
            EssenceMessageBody.create = function create(properties) {
                return new EssenceMessageBody(properties);
            };

            /**
             * Encodes the specified EssenceMessageBody message. Does not implicitly {@link kritor.common.EssenceMessageBody.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {kritor.common.IEssenceMessageBody} message EssenceMessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EssenceMessageBody.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.group_id);
                if (message.sender_uid != null && Object.hasOwnProperty.call(message, "sender_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.sender_uid);
                if (message.sender_uin != null && Object.hasOwnProperty.call(message, "sender_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.sender_uin);
                if (message.sender_nick != null && Object.hasOwnProperty.call(message, "sender_nick"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.sender_nick);
                if (message.operator_uid != null && Object.hasOwnProperty.call(message, "operator_uid"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.operator_uid);
                if (message.operator_uin != null && Object.hasOwnProperty.call(message, "operator_uin"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.operator_uin);
                if (message.operator_nick != null && Object.hasOwnProperty.call(message, "operator_nick"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.operator_nick);
                if (message.operation_time != null && Object.hasOwnProperty.call(message, "operation_time"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.operation_time);
                if (message.message_time != null && Object.hasOwnProperty.call(message, "message_time"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.message_time);
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.message_id);
                if (message.message_seq != null && Object.hasOwnProperty.call(message, "message_seq"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.message_seq);
                if (message.json_elements != null && Object.hasOwnProperty.call(message, "json_elements"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.json_elements);
                return writer;
            };

            /**
             * Encodes the specified EssenceMessageBody message, length delimited. Does not implicitly {@link kritor.common.EssenceMessageBody.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {kritor.common.IEssenceMessageBody} message EssenceMessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EssenceMessageBody.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EssenceMessageBody message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.EssenceMessageBody} EssenceMessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EssenceMessageBody.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.EssenceMessageBody();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.sender_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.sender_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.sender_nick = reader.string();
                            break;
                        }
                    case 5: {
                            message.operator_uid = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.operator_uin = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.operator_nick = reader.string();
                            break;
                        }
                    case 8: {
                            message.operation_time = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.message_time = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.message_id = reader.string();
                            break;
                        }
                    case 11: {
                            message.message_seq = reader.uint64();
                            break;
                        }
                    case 12: {
                            message.json_elements = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EssenceMessageBody message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.EssenceMessageBody} EssenceMessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EssenceMessageBody.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EssenceMessageBody message.
             * @function verify
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EssenceMessageBody.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id))
                        return "group_id: integer expected";
                if (message.sender_uid != null && message.hasOwnProperty("sender_uid"))
                    if (!$util.isString(message.sender_uid))
                        return "sender_uid: string expected";
                if (message.sender_uin != null && message.hasOwnProperty("sender_uin"))
                    if (!$util.isInteger(message.sender_uin) && !(message.sender_uin && $util.isInteger(message.sender_uin.low) && $util.isInteger(message.sender_uin.high)))
                        return "sender_uin: integer|Long expected";
                if (message.sender_nick != null && message.hasOwnProperty("sender_nick"))
                    if (!$util.isString(message.sender_nick))
                        return "sender_nick: string expected";
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    if (!$util.isInteger(message.operator_uid) && !(message.operator_uid && $util.isInteger(message.operator_uid.low) && $util.isInteger(message.operator_uid.high)))
                        return "operator_uid: integer|Long expected";
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (!$util.isInteger(message.operator_uin) && !(message.operator_uin && $util.isInteger(message.operator_uin.low) && $util.isInteger(message.operator_uin.high)))
                        return "operator_uin: integer|Long expected";
                if (message.operator_nick != null && message.hasOwnProperty("operator_nick"))
                    if (!$util.isString(message.operator_nick))
                        return "operator_nick: string expected";
                if (message.operation_time != null && message.hasOwnProperty("operation_time"))
                    if (!$util.isInteger(message.operation_time))
                        return "operation_time: integer expected";
                if (message.message_time != null && message.hasOwnProperty("message_time"))
                    if (!$util.isInteger(message.message_time))
                        return "message_time: integer expected";
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                if (message.message_seq != null && message.hasOwnProperty("message_seq"))
                    if (!$util.isInteger(message.message_seq) && !(message.message_seq && $util.isInteger(message.message_seq.low) && $util.isInteger(message.message_seq.high)))
                        return "message_seq: integer|Long expected";
                if (message.json_elements != null && message.hasOwnProperty("json_elements"))
                    if (!$util.isString(message.json_elements))
                        return "json_elements: string expected";
                return null;
            };

            /**
             * Creates an EssenceMessageBody message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.EssenceMessageBody} EssenceMessageBody
             */
            EssenceMessageBody.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.EssenceMessageBody)
                    return object;
                let message = new $root.kritor.common.EssenceMessageBody();
                if (object.group_id != null)
                    message.group_id = object.group_id >>> 0;
                if (object.sender_uid != null)
                    message.sender_uid = String(object.sender_uid);
                if (object.sender_uin != null)
                    if ($util.Long)
                        (message.sender_uin = $util.Long.fromValue(object.sender_uin)).unsigned = true;
                    else if (typeof object.sender_uin === "string")
                        message.sender_uin = parseInt(object.sender_uin, 10);
                    else if (typeof object.sender_uin === "number")
                        message.sender_uin = object.sender_uin;
                    else if (typeof object.sender_uin === "object")
                        message.sender_uin = new $util.LongBits(object.sender_uin.low >>> 0, object.sender_uin.high >>> 0).toNumber(true);
                if (object.sender_nick != null)
                    message.sender_nick = String(object.sender_nick);
                if (object.operator_uid != null)
                    if ($util.Long)
                        (message.operator_uid = $util.Long.fromValue(object.operator_uid)).unsigned = true;
                    else if (typeof object.operator_uid === "string")
                        message.operator_uid = parseInt(object.operator_uid, 10);
                    else if (typeof object.operator_uid === "number")
                        message.operator_uid = object.operator_uid;
                    else if (typeof object.operator_uid === "object")
                        message.operator_uid = new $util.LongBits(object.operator_uid.low >>> 0, object.operator_uid.high >>> 0).toNumber(true);
                if (object.operator_uin != null)
                    if ($util.Long)
                        (message.operator_uin = $util.Long.fromValue(object.operator_uin)).unsigned = true;
                    else if (typeof object.operator_uin === "string")
                        message.operator_uin = parseInt(object.operator_uin, 10);
                    else if (typeof object.operator_uin === "number")
                        message.operator_uin = object.operator_uin;
                    else if (typeof object.operator_uin === "object")
                        message.operator_uin = new $util.LongBits(object.operator_uin.low >>> 0, object.operator_uin.high >>> 0).toNumber(true);
                if (object.operator_nick != null)
                    message.operator_nick = String(object.operator_nick);
                if (object.operation_time != null)
                    message.operation_time = object.operation_time >>> 0;
                if (object.message_time != null)
                    message.message_time = object.message_time >>> 0;
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                if (object.message_seq != null)
                    if ($util.Long)
                        (message.message_seq = $util.Long.fromValue(object.message_seq)).unsigned = true;
                    else if (typeof object.message_seq === "string")
                        message.message_seq = parseInt(object.message_seq, 10);
                    else if (typeof object.message_seq === "number")
                        message.message_seq = object.message_seq;
                    else if (typeof object.message_seq === "object")
                        message.message_seq = new $util.LongBits(object.message_seq.low >>> 0, object.message_seq.high >>> 0).toNumber(true);
                if (object.json_elements != null)
                    message.json_elements = String(object.json_elements);
                return message;
            };

            /**
             * Creates a plain object from an EssenceMessageBody message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {kritor.common.EssenceMessageBody} message EssenceMessageBody
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EssenceMessageBody.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.group_id = 0;
                    object.sender_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.sender_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sender_uin = options.longs === String ? "0" : 0;
                    object.sender_nick = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator_uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator_uid = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator_uin = options.longs === String ? "0" : 0;
                    object.operator_nick = "";
                    object.operation_time = 0;
                    object.message_time = 0;
                    object.message_id = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.message_seq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.message_seq = options.longs === String ? "0" : 0;
                    object.json_elements = "";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    object.group_id = message.group_id;
                if (message.sender_uid != null && message.hasOwnProperty("sender_uid"))
                    object.sender_uid = message.sender_uid;
                if (message.sender_uin != null && message.hasOwnProperty("sender_uin"))
                    if (typeof message.sender_uin === "number")
                        object.sender_uin = options.longs === String ? String(message.sender_uin) : message.sender_uin;
                    else
                        object.sender_uin = options.longs === String ? $util.Long.prototype.toString.call(message.sender_uin) : options.longs === Number ? new $util.LongBits(message.sender_uin.low >>> 0, message.sender_uin.high >>> 0).toNumber(true) : message.sender_uin;
                if (message.sender_nick != null && message.hasOwnProperty("sender_nick"))
                    object.sender_nick = message.sender_nick;
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    if (typeof message.operator_uid === "number")
                        object.operator_uid = options.longs === String ? String(message.operator_uid) : message.operator_uid;
                    else
                        object.operator_uid = options.longs === String ? $util.Long.prototype.toString.call(message.operator_uid) : options.longs === Number ? new $util.LongBits(message.operator_uid.low >>> 0, message.operator_uid.high >>> 0).toNumber(true) : message.operator_uid;
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (typeof message.operator_uin === "number")
                        object.operator_uin = options.longs === String ? String(message.operator_uin) : message.operator_uin;
                    else
                        object.operator_uin = options.longs === String ? $util.Long.prototype.toString.call(message.operator_uin) : options.longs === Number ? new $util.LongBits(message.operator_uin.low >>> 0, message.operator_uin.high >>> 0).toNumber(true) : message.operator_uin;
                if (message.operator_nick != null && message.hasOwnProperty("operator_nick"))
                    object.operator_nick = message.operator_nick;
                if (message.operation_time != null && message.hasOwnProperty("operation_time"))
                    object.operation_time = message.operation_time;
                if (message.message_time != null && message.hasOwnProperty("message_time"))
                    object.message_time = message.message_time;
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    object.message_id = message.message_id;
                if (message.message_seq != null && message.hasOwnProperty("message_seq"))
                    if (typeof message.message_seq === "number")
                        object.message_seq = options.longs === String ? String(message.message_seq) : message.message_seq;
                    else
                        object.message_seq = options.longs === String ? $util.Long.prototype.toString.call(message.message_seq) : options.longs === Number ? new $util.LongBits(message.message_seq.low >>> 0, message.message_seq.high >>> 0).toNumber(true) : message.message_seq;
                if (message.json_elements != null && message.hasOwnProperty("json_elements"))
                    object.json_elements = message.json_elements;
                return object;
            };

            /**
             * Converts this EssenceMessageBody to JSON.
             * @function toJSON
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EssenceMessageBody.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EssenceMessageBody
             * @function getTypeUrl
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EssenceMessageBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.EssenceMessageBody";
            };

            return EssenceMessageBody;
        })();

        common.Element = (function() {

            /**
             * Properties of an Element.
             * @memberof kritor.common
             * @interface IElement
             * @property {kritor.common.Element.ElementType|null} [type] Element type
             * @property {kritor.common.ITextElement|null} [text] Element text
             * @property {kritor.common.IAtElement|null} [at] Element at
             * @property {kritor.common.IFaceElement|null} [face] Element face
             * @property {kritor.common.IBubbleFaceElement|null} [bubble_face] Element bubble_face
             * @property {kritor.common.IReplyElement|null} [reply] Element reply
             * @property {kritor.common.IImageElement|null} [image] Element image
             * @property {kritor.common.IVoiceElement|null} [voice] Element voice
             * @property {kritor.common.IVideoElement|null} [video] Element video
             * @property {kritor.common.IBasketballElement|null} [basketball] Element basketball
             * @property {kritor.common.IDiceElement|null} [dice] Element dice
             * @property {kritor.common.IRpsElement|null} [rps] Element rps
             * @property {kritor.common.IPokeElement|null} [poke] Element poke
             * @property {kritor.common.IMusicElement|null} [music] Element music
             * @property {kritor.common.IWeatherElement|null} [weather] Element weather
             * @property {kritor.common.ILocationElement|null} [location] Element location
             * @property {kritor.common.IShareElement|null} [share] Element share
             * @property {kritor.common.IGiftElement|null} [gift] Element gift
             * @property {kritor.common.IMarketFaceElement|null} [market_face] Element market_face
             * @property {kritor.common.IForwardElement|null} [forward] Element forward
             * @property {kritor.common.IContactElement|null} [contact] Element contact
             * @property {kritor.common.IJsonElement|null} [json] Element json
             * @property {kritor.common.IXmlElement|null} [xml] Element xml
             * @property {kritor.common.IFileElement|null} [file] Element file
             * @property {kritor.common.IMarkdownElement|null} [markdown] Element markdown
             * @property {kritor.common.IKeyboardElement|null} [keyboard] Element keyboard
             */

            /**
             * Constructs a new Element.
             * @memberof kritor.common
             * @classdesc Represents an Element.
             * @implements IElement
             * @constructor
             * @param {kritor.common.IElement=} [properties] Properties to set
             */
            function Element(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Element type.
             * @member {kritor.common.Element.ElementType} type
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.type = 0;

            /**
             * Element text.
             * @member {kritor.common.ITextElement|null|undefined} text
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.text = null;

            /**
             * Element at.
             * @member {kritor.common.IAtElement|null|undefined} at
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.at = null;

            /**
             * Element face.
             * @member {kritor.common.IFaceElement|null|undefined} face
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.face = null;

            /**
             * Element bubble_face.
             * @member {kritor.common.IBubbleFaceElement|null|undefined} bubble_face
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.bubble_face = null;

            /**
             * Element reply.
             * @member {kritor.common.IReplyElement|null|undefined} reply
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.reply = null;

            /**
             * Element image.
             * @member {kritor.common.IImageElement|null|undefined} image
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.image = null;

            /**
             * Element voice.
             * @member {kritor.common.IVoiceElement|null|undefined} voice
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.voice = null;

            /**
             * Element video.
             * @member {kritor.common.IVideoElement|null|undefined} video
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.video = null;

            /**
             * Element basketball.
             * @member {kritor.common.IBasketballElement|null|undefined} basketball
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.basketball = null;

            /**
             * Element dice.
             * @member {kritor.common.IDiceElement|null|undefined} dice
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.dice = null;

            /**
             * Element rps.
             * @member {kritor.common.IRpsElement|null|undefined} rps
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.rps = null;

            /**
             * Element poke.
             * @member {kritor.common.IPokeElement|null|undefined} poke
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.poke = null;

            /**
             * Element music.
             * @member {kritor.common.IMusicElement|null|undefined} music
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.music = null;

            /**
             * Element weather.
             * @member {kritor.common.IWeatherElement|null|undefined} weather
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.weather = null;

            /**
             * Element location.
             * @member {kritor.common.ILocationElement|null|undefined} location
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.location = null;

            /**
             * Element share.
             * @member {kritor.common.IShareElement|null|undefined} share
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.share = null;

            /**
             * Element gift.
             * @member {kritor.common.IGiftElement|null|undefined} gift
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.gift = null;

            /**
             * Element market_face.
             * @member {kritor.common.IMarketFaceElement|null|undefined} market_face
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.market_face = null;

            /**
             * Element forward.
             * @member {kritor.common.IForwardElement|null|undefined} forward
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.forward = null;

            /**
             * Element contact.
             * @member {kritor.common.IContactElement|null|undefined} contact
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.contact = null;

            /**
             * Element json.
             * @member {kritor.common.IJsonElement|null|undefined} json
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.json = null;

            /**
             * Element xml.
             * @member {kritor.common.IXmlElement|null|undefined} xml
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.xml = null;

            /**
             * Element file.
             * @member {kritor.common.IFileElement|null|undefined} file
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.file = null;

            /**
             * Element markdown.
             * @member {kritor.common.IMarkdownElement|null|undefined} markdown
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.markdown = null;

            /**
             * Element keyboard.
             * @member {kritor.common.IKeyboardElement|null|undefined} keyboard
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.keyboard = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Element data.
             * @member {"text"|"at"|"face"|"bubble_face"|"reply"|"image"|"voice"|"video"|"basketball"|"dice"|"rps"|"poke"|"music"|"weather"|"location"|"share"|"gift"|"market_face"|"forward"|"contact"|"json"|"xml"|"file"|"markdown"|"keyboard"|undefined} data
             * @memberof kritor.common.Element
             * @instance
             */
            Object.defineProperty(Element.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["text", "at", "face", "bubble_face", "reply", "image", "voice", "video", "basketball", "dice", "rps", "poke", "music", "weather", "location", "share", "gift", "market_face", "forward", "contact", "json", "xml", "file", "markdown", "keyboard"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Element instance using the specified properties.
             * @function create
             * @memberof kritor.common.Element
             * @static
             * @param {kritor.common.IElement=} [properties] Properties to set
             * @returns {kritor.common.Element} Element instance
             */
            Element.create = function create(properties) {
                return new Element(properties);
            };

            /**
             * Encodes the specified Element message. Does not implicitly {@link kritor.common.Element.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.Element
             * @static
             * @param {kritor.common.IElement} message Element message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Element.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    $root.kritor.common.TextElement.encode(message.text, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.at != null && Object.hasOwnProperty.call(message, "at"))
                    $root.kritor.common.AtElement.encode(message.at, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.face != null && Object.hasOwnProperty.call(message, "face"))
                    $root.kritor.common.FaceElement.encode(message.face, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.bubble_face != null && Object.hasOwnProperty.call(message, "bubble_face"))
                    $root.kritor.common.BubbleFaceElement.encode(message.bubble_face, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.reply != null && Object.hasOwnProperty.call(message, "reply"))
                    $root.kritor.common.ReplyElement.encode(message.reply, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                    $root.kritor.common.ImageElement.encode(message.image, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.voice != null && Object.hasOwnProperty.call(message, "voice"))
                    $root.kritor.common.VoiceElement.encode(message.voice, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.video != null && Object.hasOwnProperty.call(message, "video"))
                    $root.kritor.common.VideoElement.encode(message.video, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.basketball != null && Object.hasOwnProperty.call(message, "basketball"))
                    $root.kritor.common.BasketballElement.encode(message.basketball, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.dice != null && Object.hasOwnProperty.call(message, "dice"))
                    $root.kritor.common.DiceElement.encode(message.dice, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.rps != null && Object.hasOwnProperty.call(message, "rps"))
                    $root.kritor.common.RpsElement.encode(message.rps, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.poke != null && Object.hasOwnProperty.call(message, "poke"))
                    $root.kritor.common.PokeElement.encode(message.poke, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.music != null && Object.hasOwnProperty.call(message, "music"))
                    $root.kritor.common.MusicElement.encode(message.music, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.weather != null && Object.hasOwnProperty.call(message, "weather"))
                    $root.kritor.common.WeatherElement.encode(message.weather, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.kritor.common.LocationElement.encode(message.location, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.share != null && Object.hasOwnProperty.call(message, "share"))
                    $root.kritor.common.ShareElement.encode(message.share, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.gift != null && Object.hasOwnProperty.call(message, "gift"))
                    $root.kritor.common.GiftElement.encode(message.gift, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.market_face != null && Object.hasOwnProperty.call(message, "market_face"))
                    $root.kritor.common.MarketFaceElement.encode(message.market_face, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.forward != null && Object.hasOwnProperty.call(message, "forward"))
                    $root.kritor.common.ForwardElement.encode(message.forward, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.ContactElement.encode(message.contact, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                    $root.kritor.common.JsonElement.encode(message.json, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.xml != null && Object.hasOwnProperty.call(message, "xml"))
                    $root.kritor.common.XmlElement.encode(message.xml, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    $root.kritor.common.FileElement.encode(message.file, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                if (message.markdown != null && Object.hasOwnProperty.call(message, "markdown"))
                    $root.kritor.common.MarkdownElement.encode(message.markdown, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                if (message.keyboard != null && Object.hasOwnProperty.call(message, "keyboard"))
                    $root.kritor.common.KeyboardElement.encode(message.keyboard, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Element message, length delimited. Does not implicitly {@link kritor.common.Element.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.Element
             * @static
             * @param {kritor.common.IElement} message Element message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Element.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Element message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.Element
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.Element} Element
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Element.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.Element();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.text = $root.kritor.common.TextElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.at = $root.kritor.common.AtElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.face = $root.kritor.common.FaceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.bubble_face = $root.kritor.common.BubbleFaceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.reply = $root.kritor.common.ReplyElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            message.image = $root.kritor.common.ImageElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            message.voice = $root.kritor.common.VoiceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.video = $root.kritor.common.VideoElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 10: {
                            message.basketball = $root.kritor.common.BasketballElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.dice = $root.kritor.common.DiceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.rps = $root.kritor.common.RpsElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 13: {
                            message.poke = $root.kritor.common.PokeElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 14: {
                            message.music = $root.kritor.common.MusicElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 15: {
                            message.weather = $root.kritor.common.WeatherElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 16: {
                            message.location = $root.kritor.common.LocationElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 17: {
                            message.share = $root.kritor.common.ShareElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 18: {
                            message.gift = $root.kritor.common.GiftElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 19: {
                            message.market_face = $root.kritor.common.MarketFaceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 20: {
                            message.forward = $root.kritor.common.ForwardElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 21: {
                            message.contact = $root.kritor.common.ContactElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 22: {
                            message.json = $root.kritor.common.JsonElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 23: {
                            message.xml = $root.kritor.common.XmlElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 24: {
                            message.file = $root.kritor.common.FileElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 25: {
                            message.markdown = $root.kritor.common.MarkdownElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 26: {
                            message.keyboard = $root.kritor.common.KeyboardElement.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Element message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.Element
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.Element} Element
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Element.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Element message.
             * @function verify
             * @memberof kritor.common.Element
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Element.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                        break;
                    }
                if (message.text != null && message.hasOwnProperty("text")) {
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.TextElement.verify(message.text);
                        if (error)
                            return "text." + error;
                    }
                }
                if (message.at != null && message.hasOwnProperty("at")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.AtElement.verify(message.at);
                        if (error)
                            return "at." + error;
                    }
                }
                if (message.face != null && message.hasOwnProperty("face")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.FaceElement.verify(message.face);
                        if (error)
                            return "face." + error;
                    }
                }
                if (message.bubble_face != null && message.hasOwnProperty("bubble_face")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.BubbleFaceElement.verify(message.bubble_face);
                        if (error)
                            return "bubble_face." + error;
                    }
                }
                if (message.reply != null && message.hasOwnProperty("reply")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.ReplyElement.verify(message.reply);
                        if (error)
                            return "reply." + error;
                    }
                }
                if (message.image != null && message.hasOwnProperty("image")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.ImageElement.verify(message.image);
                        if (error)
                            return "image." + error;
                    }
                }
                if (message.voice != null && message.hasOwnProperty("voice")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.VoiceElement.verify(message.voice);
                        if (error)
                            return "voice." + error;
                    }
                }
                if (message.video != null && message.hasOwnProperty("video")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.VideoElement.verify(message.video);
                        if (error)
                            return "video." + error;
                    }
                }
                if (message.basketball != null && message.hasOwnProperty("basketball")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.BasketballElement.verify(message.basketball);
                        if (error)
                            return "basketball." + error;
                    }
                }
                if (message.dice != null && message.hasOwnProperty("dice")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.DiceElement.verify(message.dice);
                        if (error)
                            return "dice." + error;
                    }
                }
                if (message.rps != null && message.hasOwnProperty("rps")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.RpsElement.verify(message.rps);
                        if (error)
                            return "rps." + error;
                    }
                }
                if (message.poke != null && message.hasOwnProperty("poke")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.PokeElement.verify(message.poke);
                        if (error)
                            return "poke." + error;
                    }
                }
                if (message.music != null && message.hasOwnProperty("music")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.MusicElement.verify(message.music);
                        if (error)
                            return "music." + error;
                    }
                }
                if (message.weather != null && message.hasOwnProperty("weather")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.WeatherElement.verify(message.weather);
                        if (error)
                            return "weather." + error;
                    }
                }
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.LocationElement.verify(message.location);
                        if (error)
                            return "location." + error;
                    }
                }
                if (message.share != null && message.hasOwnProperty("share")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.ShareElement.verify(message.share);
                        if (error)
                            return "share." + error;
                    }
                }
                if (message.gift != null && message.hasOwnProperty("gift")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.GiftElement.verify(message.gift);
                        if (error)
                            return "gift." + error;
                    }
                }
                if (message.market_face != null && message.hasOwnProperty("market_face")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.MarketFaceElement.verify(message.market_face);
                        if (error)
                            return "market_face." + error;
                    }
                }
                if (message.forward != null && message.hasOwnProperty("forward")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.ForwardElement.verify(message.forward);
                        if (error)
                            return "forward." + error;
                    }
                }
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.ContactElement.verify(message.contact);
                        if (error)
                            return "contact." + error;
                    }
                }
                if (message.json != null && message.hasOwnProperty("json")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.JsonElement.verify(message.json);
                        if (error)
                            return "json." + error;
                    }
                }
                if (message.xml != null && message.hasOwnProperty("xml")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.XmlElement.verify(message.xml);
                        if (error)
                            return "xml." + error;
                    }
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.FileElement.verify(message.file);
                        if (error)
                            return "file." + error;
                    }
                }
                if (message.markdown != null && message.hasOwnProperty("markdown")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.MarkdownElement.verify(message.markdown);
                        if (error)
                            return "markdown." + error;
                    }
                }
                if (message.keyboard != null && message.hasOwnProperty("keyboard")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.KeyboardElement.verify(message.keyboard);
                        if (error)
                            return "keyboard." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Element message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.Element
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.Element} Element
             */
            Element.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.Element)
                    return object;
                let message = new $root.kritor.common.Element();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "TEXT":
                case 0:
                    message.type = 0;
                    break;
                case "AT":
                case 1:
                    message.type = 1;
                    break;
                case "FACE":
                case 2:
                    message.type = 2;
                    break;
                case "BUBBLE_FACE":
                case 3:
                    message.type = 3;
                    break;
                case "REPLY":
                case 4:
                    message.type = 4;
                    break;
                case "IMAGE":
                case 5:
                    message.type = 5;
                    break;
                case "VOICE":
                case 6:
                    message.type = 6;
                    break;
                case "VIDEO":
                case 7:
                    message.type = 7;
                    break;
                case "BASKETBALL":
                case 8:
                    message.type = 8;
                    break;
                case "DICE":
                case 9:
                    message.type = 9;
                    break;
                case "RPS":
                case 10:
                    message.type = 10;
                    break;
                case "POKE":
                case 11:
                    message.type = 11;
                    break;
                case "MUSIC":
                case 12:
                    message.type = 12;
                    break;
                case "WEATHER":
                case 13:
                    message.type = 13;
                    break;
                case "LOCATION":
                case 14:
                    message.type = 14;
                    break;
                case "SHARE":
                case 15:
                    message.type = 15;
                    break;
                case "GIFT":
                case 16:
                    message.type = 16;
                    break;
                case "MARKET_FACE":
                case 17:
                    message.type = 17;
                    break;
                case "FORWARD":
                case 18:
                    message.type = 18;
                    break;
                case "CONTACT":
                case 19:
                    message.type = 19;
                    break;
                case "JSON":
                case 20:
                    message.type = 20;
                    break;
                case "XML":
                case 21:
                    message.type = 21;
                    break;
                case "FILE":
                case 22:
                    message.type = 22;
                    break;
                case "MARKDOWN":
                case 23:
                    message.type = 23;
                    break;
                case "KEYBOARD":
                case 24:
                    message.type = 24;
                    break;
                }
                if (object.text != null) {
                    if (typeof object.text !== "object")
                        throw TypeError(".kritor.common.Element.text: object expected");
                    message.text = $root.kritor.common.TextElement.fromObject(object.text);
                }
                if (object.at != null) {
                    if (typeof object.at !== "object")
                        throw TypeError(".kritor.common.Element.at: object expected");
                    message.at = $root.kritor.common.AtElement.fromObject(object.at);
                }
                if (object.face != null) {
                    if (typeof object.face !== "object")
                        throw TypeError(".kritor.common.Element.face: object expected");
                    message.face = $root.kritor.common.FaceElement.fromObject(object.face);
                }
                if (object.bubble_face != null) {
                    if (typeof object.bubble_face !== "object")
                        throw TypeError(".kritor.common.Element.bubble_face: object expected");
                    message.bubble_face = $root.kritor.common.BubbleFaceElement.fromObject(object.bubble_face);
                }
                if (object.reply != null) {
                    if (typeof object.reply !== "object")
                        throw TypeError(".kritor.common.Element.reply: object expected");
                    message.reply = $root.kritor.common.ReplyElement.fromObject(object.reply);
                }
                if (object.image != null) {
                    if (typeof object.image !== "object")
                        throw TypeError(".kritor.common.Element.image: object expected");
                    message.image = $root.kritor.common.ImageElement.fromObject(object.image);
                }
                if (object.voice != null) {
                    if (typeof object.voice !== "object")
                        throw TypeError(".kritor.common.Element.voice: object expected");
                    message.voice = $root.kritor.common.VoiceElement.fromObject(object.voice);
                }
                if (object.video != null) {
                    if (typeof object.video !== "object")
                        throw TypeError(".kritor.common.Element.video: object expected");
                    message.video = $root.kritor.common.VideoElement.fromObject(object.video);
                }
                if (object.basketball != null) {
                    if (typeof object.basketball !== "object")
                        throw TypeError(".kritor.common.Element.basketball: object expected");
                    message.basketball = $root.kritor.common.BasketballElement.fromObject(object.basketball);
                }
                if (object.dice != null) {
                    if (typeof object.dice !== "object")
                        throw TypeError(".kritor.common.Element.dice: object expected");
                    message.dice = $root.kritor.common.DiceElement.fromObject(object.dice);
                }
                if (object.rps != null) {
                    if (typeof object.rps !== "object")
                        throw TypeError(".kritor.common.Element.rps: object expected");
                    message.rps = $root.kritor.common.RpsElement.fromObject(object.rps);
                }
                if (object.poke != null) {
                    if (typeof object.poke !== "object")
                        throw TypeError(".kritor.common.Element.poke: object expected");
                    message.poke = $root.kritor.common.PokeElement.fromObject(object.poke);
                }
                if (object.music != null) {
                    if (typeof object.music !== "object")
                        throw TypeError(".kritor.common.Element.music: object expected");
                    message.music = $root.kritor.common.MusicElement.fromObject(object.music);
                }
                if (object.weather != null) {
                    if (typeof object.weather !== "object")
                        throw TypeError(".kritor.common.Element.weather: object expected");
                    message.weather = $root.kritor.common.WeatherElement.fromObject(object.weather);
                }
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".kritor.common.Element.location: object expected");
                    message.location = $root.kritor.common.LocationElement.fromObject(object.location);
                }
                if (object.share != null) {
                    if (typeof object.share !== "object")
                        throw TypeError(".kritor.common.Element.share: object expected");
                    message.share = $root.kritor.common.ShareElement.fromObject(object.share);
                }
                if (object.gift != null) {
                    if (typeof object.gift !== "object")
                        throw TypeError(".kritor.common.Element.gift: object expected");
                    message.gift = $root.kritor.common.GiftElement.fromObject(object.gift);
                }
                if (object.market_face != null) {
                    if (typeof object.market_face !== "object")
                        throw TypeError(".kritor.common.Element.market_face: object expected");
                    message.market_face = $root.kritor.common.MarketFaceElement.fromObject(object.market_face);
                }
                if (object.forward != null) {
                    if (typeof object.forward !== "object")
                        throw TypeError(".kritor.common.Element.forward: object expected");
                    message.forward = $root.kritor.common.ForwardElement.fromObject(object.forward);
                }
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.common.Element.contact: object expected");
                    message.contact = $root.kritor.common.ContactElement.fromObject(object.contact);
                }
                if (object.json != null) {
                    if (typeof object.json !== "object")
                        throw TypeError(".kritor.common.Element.json: object expected");
                    message.json = $root.kritor.common.JsonElement.fromObject(object.json);
                }
                if (object.xml != null) {
                    if (typeof object.xml !== "object")
                        throw TypeError(".kritor.common.Element.xml: object expected");
                    message.xml = $root.kritor.common.XmlElement.fromObject(object.xml);
                }
                if (object.file != null) {
                    if (typeof object.file !== "object")
                        throw TypeError(".kritor.common.Element.file: object expected");
                    message.file = $root.kritor.common.FileElement.fromObject(object.file);
                }
                if (object.markdown != null) {
                    if (typeof object.markdown !== "object")
                        throw TypeError(".kritor.common.Element.markdown: object expected");
                    message.markdown = $root.kritor.common.MarkdownElement.fromObject(object.markdown);
                }
                if (object.keyboard != null) {
                    if (typeof object.keyboard !== "object")
                        throw TypeError(".kritor.common.Element.keyboard: object expected");
                    message.keyboard = $root.kritor.common.KeyboardElement.fromObject(object.keyboard);
                }
                return message;
            };

            /**
             * Creates a plain object from an Element message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.Element
             * @static
             * @param {kritor.common.Element} message Element
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Element.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "TEXT" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.common.Element.ElementType[message.type] === undefined ? message.type : $root.kritor.common.Element.ElementType[message.type] : message.type;
                if (message.text != null && message.hasOwnProperty("text")) {
                    object.text = $root.kritor.common.TextElement.toObject(message.text, options);
                    if (options.oneofs)
                        object.data = "text";
                }
                if (message.at != null && message.hasOwnProperty("at")) {
                    object.at = $root.kritor.common.AtElement.toObject(message.at, options);
                    if (options.oneofs)
                        object.data = "at";
                }
                if (message.face != null && message.hasOwnProperty("face")) {
                    object.face = $root.kritor.common.FaceElement.toObject(message.face, options);
                    if (options.oneofs)
                        object.data = "face";
                }
                if (message.bubble_face != null && message.hasOwnProperty("bubble_face")) {
                    object.bubble_face = $root.kritor.common.BubbleFaceElement.toObject(message.bubble_face, options);
                    if (options.oneofs)
                        object.data = "bubble_face";
                }
                if (message.reply != null && message.hasOwnProperty("reply")) {
                    object.reply = $root.kritor.common.ReplyElement.toObject(message.reply, options);
                    if (options.oneofs)
                        object.data = "reply";
                }
                if (message.image != null && message.hasOwnProperty("image")) {
                    object.image = $root.kritor.common.ImageElement.toObject(message.image, options);
                    if (options.oneofs)
                        object.data = "image";
                }
                if (message.voice != null && message.hasOwnProperty("voice")) {
                    object.voice = $root.kritor.common.VoiceElement.toObject(message.voice, options);
                    if (options.oneofs)
                        object.data = "voice";
                }
                if (message.video != null && message.hasOwnProperty("video")) {
                    object.video = $root.kritor.common.VideoElement.toObject(message.video, options);
                    if (options.oneofs)
                        object.data = "video";
                }
                if (message.basketball != null && message.hasOwnProperty("basketball")) {
                    object.basketball = $root.kritor.common.BasketballElement.toObject(message.basketball, options);
                    if (options.oneofs)
                        object.data = "basketball";
                }
                if (message.dice != null && message.hasOwnProperty("dice")) {
                    object.dice = $root.kritor.common.DiceElement.toObject(message.dice, options);
                    if (options.oneofs)
                        object.data = "dice";
                }
                if (message.rps != null && message.hasOwnProperty("rps")) {
                    object.rps = $root.kritor.common.RpsElement.toObject(message.rps, options);
                    if (options.oneofs)
                        object.data = "rps";
                }
                if (message.poke != null && message.hasOwnProperty("poke")) {
                    object.poke = $root.kritor.common.PokeElement.toObject(message.poke, options);
                    if (options.oneofs)
                        object.data = "poke";
                }
                if (message.music != null && message.hasOwnProperty("music")) {
                    object.music = $root.kritor.common.MusicElement.toObject(message.music, options);
                    if (options.oneofs)
                        object.data = "music";
                }
                if (message.weather != null && message.hasOwnProperty("weather")) {
                    object.weather = $root.kritor.common.WeatherElement.toObject(message.weather, options);
                    if (options.oneofs)
                        object.data = "weather";
                }
                if (message.location != null && message.hasOwnProperty("location")) {
                    object.location = $root.kritor.common.LocationElement.toObject(message.location, options);
                    if (options.oneofs)
                        object.data = "location";
                }
                if (message.share != null && message.hasOwnProperty("share")) {
                    object.share = $root.kritor.common.ShareElement.toObject(message.share, options);
                    if (options.oneofs)
                        object.data = "share";
                }
                if (message.gift != null && message.hasOwnProperty("gift")) {
                    object.gift = $root.kritor.common.GiftElement.toObject(message.gift, options);
                    if (options.oneofs)
                        object.data = "gift";
                }
                if (message.market_face != null && message.hasOwnProperty("market_face")) {
                    object.market_face = $root.kritor.common.MarketFaceElement.toObject(message.market_face, options);
                    if (options.oneofs)
                        object.data = "market_face";
                }
                if (message.forward != null && message.hasOwnProperty("forward")) {
                    object.forward = $root.kritor.common.ForwardElement.toObject(message.forward, options);
                    if (options.oneofs)
                        object.data = "forward";
                }
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    object.contact = $root.kritor.common.ContactElement.toObject(message.contact, options);
                    if (options.oneofs)
                        object.data = "contact";
                }
                if (message.json != null && message.hasOwnProperty("json")) {
                    object.json = $root.kritor.common.JsonElement.toObject(message.json, options);
                    if (options.oneofs)
                        object.data = "json";
                }
                if (message.xml != null && message.hasOwnProperty("xml")) {
                    object.xml = $root.kritor.common.XmlElement.toObject(message.xml, options);
                    if (options.oneofs)
                        object.data = "xml";
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = $root.kritor.common.FileElement.toObject(message.file, options);
                    if (options.oneofs)
                        object.data = "file";
                }
                if (message.markdown != null && message.hasOwnProperty("markdown")) {
                    object.markdown = $root.kritor.common.MarkdownElement.toObject(message.markdown, options);
                    if (options.oneofs)
                        object.data = "markdown";
                }
                if (message.keyboard != null && message.hasOwnProperty("keyboard")) {
                    object.keyboard = $root.kritor.common.KeyboardElement.toObject(message.keyboard, options);
                    if (options.oneofs)
                        object.data = "keyboard";
                }
                return object;
            };

            /**
             * Converts this Element to JSON.
             * @function toJSON
             * @memberof kritor.common.Element
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Element.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Element
             * @function getTypeUrl
             * @memberof kritor.common.Element
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Element.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.Element";
            };

            /**
             * ElementType enum.
             * @name kritor.common.Element.ElementType
             * @enum {number}
             * @property {number} TEXT=0 TEXT value
             * @property {number} AT=1 AT value
             * @property {number} FACE=2 FACE value
             * @property {number} BUBBLE_FACE=3 BUBBLE_FACE value
             * @property {number} REPLY=4 REPLY value
             * @property {number} IMAGE=5 IMAGE value
             * @property {number} VOICE=6 VOICE value
             * @property {number} VIDEO=7 VIDEO value
             * @property {number} BASKETBALL=8 BASKETBALL value
             * @property {number} DICE=9 DICE value
             * @property {number} RPS=10 RPS value
             * @property {number} POKE=11 POKE value
             * @property {number} MUSIC=12 MUSIC value
             * @property {number} WEATHER=13 WEATHER value
             * @property {number} LOCATION=14 LOCATION value
             * @property {number} SHARE=15 SHARE value
             * @property {number} GIFT=16 GIFT value
             * @property {number} MARKET_FACE=17 MARKET_FACE value
             * @property {number} FORWARD=18 FORWARD value
             * @property {number} CONTACT=19 CONTACT value
             * @property {number} JSON=20 JSON value
             * @property {number} XML=21 XML value
             * @property {number} FILE=22 FILE value
             * @property {number} MARKDOWN=23 MARKDOWN value
             * @property {number} KEYBOARD=24 KEYBOARD value
             */
            Element.ElementType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TEXT"] = 0;
                values[valuesById[1] = "AT"] = 1;
                values[valuesById[2] = "FACE"] = 2;
                values[valuesById[3] = "BUBBLE_FACE"] = 3;
                values[valuesById[4] = "REPLY"] = 4;
                values[valuesById[5] = "IMAGE"] = 5;
                values[valuesById[6] = "VOICE"] = 6;
                values[valuesById[7] = "VIDEO"] = 7;
                values[valuesById[8] = "BASKETBALL"] = 8;
                values[valuesById[9] = "DICE"] = 9;
                values[valuesById[10] = "RPS"] = 10;
                values[valuesById[11] = "POKE"] = 11;
                values[valuesById[12] = "MUSIC"] = 12;
                values[valuesById[13] = "WEATHER"] = 13;
                values[valuesById[14] = "LOCATION"] = 14;
                values[valuesById[15] = "SHARE"] = 15;
                values[valuesById[16] = "GIFT"] = 16;
                values[valuesById[17] = "MARKET_FACE"] = 17;
                values[valuesById[18] = "FORWARD"] = 18;
                values[valuesById[19] = "CONTACT"] = 19;
                values[valuesById[20] = "JSON"] = 20;
                values[valuesById[21] = "XML"] = 21;
                values[valuesById[22] = "FILE"] = 22;
                values[valuesById[23] = "MARKDOWN"] = 23;
                values[valuesById[24] = "KEYBOARD"] = 24;
                return values;
            })();

            return Element;
        })();

        common.TextElement = (function() {

            /**
             * Properties of a TextElement.
             * @memberof kritor.common
             * @interface ITextElement
             * @property {string|null} [text] TextElement text
             */

            /**
             * Constructs a new TextElement.
             * @memberof kritor.common
             * @classdesc Represents a TextElement.
             * @implements ITextElement
             * @constructor
             * @param {kritor.common.ITextElement=} [properties] Properties to set
             */
            function TextElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TextElement text.
             * @member {string} text
             * @memberof kritor.common.TextElement
             * @instance
             */
            TextElement.prototype.text = "";

            /**
             * Creates a new TextElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.TextElement
             * @static
             * @param {kritor.common.ITextElement=} [properties] Properties to set
             * @returns {kritor.common.TextElement} TextElement instance
             */
            TextElement.create = function create(properties) {
                return new TextElement(properties);
            };

            /**
             * Encodes the specified TextElement message. Does not implicitly {@link kritor.common.TextElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.TextElement
             * @static
             * @param {kritor.common.ITextElement} message TextElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TextElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                return writer;
            };

            /**
             * Encodes the specified TextElement message, length delimited. Does not implicitly {@link kritor.common.TextElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.TextElement
             * @static
             * @param {kritor.common.ITextElement} message TextElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TextElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TextElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.TextElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.TextElement} TextElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TextElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.TextElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.text = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TextElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.TextElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.TextElement} TextElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TextElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TextElement message.
             * @function verify
             * @memberof kritor.common.TextElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TextElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                return null;
            };

            /**
             * Creates a TextElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.TextElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.TextElement} TextElement
             */
            TextElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.TextElement)
                    return object;
                let message = new $root.kritor.common.TextElement();
                if (object.text != null)
                    message.text = String(object.text);
                return message;
            };

            /**
             * Creates a plain object from a TextElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.TextElement
             * @static
             * @param {kritor.common.TextElement} message TextElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TextElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.text = "";
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                return object;
            };

            /**
             * Converts this TextElement to JSON.
             * @function toJSON
             * @memberof kritor.common.TextElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TextElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TextElement
             * @function getTypeUrl
             * @memberof kritor.common.TextElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TextElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.TextElement";
            };

            return TextElement;
        })();

        common.AtElement = (function() {

            /**
             * Properties of an AtElement.
             * @memberof kritor.common
             * @interface IAtElement
             * @property {string|null} [uid] AtElement uid
             * @property {number|Long|null} [uin] AtElement uin
             */

            /**
             * Constructs a new AtElement.
             * @memberof kritor.common
             * @classdesc Represents an AtElement.
             * @implements IAtElement
             * @constructor
             * @param {kritor.common.IAtElement=} [properties] Properties to set
             */
            function AtElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AtElement uid.
             * @member {string} uid
             * @memberof kritor.common.AtElement
             * @instance
             */
            AtElement.prototype.uid = "";

            /**
             * AtElement uin.
             * @member {number|Long|null|undefined} uin
             * @memberof kritor.common.AtElement
             * @instance
             */
            AtElement.prototype.uin = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * AtElement _uin.
             * @member {"uin"|undefined} _uin
             * @memberof kritor.common.AtElement
             * @instance
             */
            Object.defineProperty(AtElement.prototype, "_uin", {
                get: $util.oneOfGetter($oneOfFields = ["uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new AtElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.AtElement
             * @static
             * @param {kritor.common.IAtElement=} [properties] Properties to set
             * @returns {kritor.common.AtElement} AtElement instance
             */
            AtElement.create = function create(properties) {
                return new AtElement(properties);
            };

            /**
             * Encodes the specified AtElement message. Does not implicitly {@link kritor.common.AtElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.AtElement
             * @static
             * @param {kritor.common.IAtElement} message AtElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AtElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                return writer;
            };

            /**
             * Encodes the specified AtElement message, length delimited. Does not implicitly {@link kritor.common.AtElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.AtElement
             * @static
             * @param {kritor.common.IAtElement} message AtElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AtElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AtElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.AtElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.AtElement} AtElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AtElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.AtElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AtElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.AtElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.AtElement} AtElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AtElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AtElement message.
             * @function verify
             * @memberof kritor.common.AtElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AtElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    properties._uin = 1;
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                }
                return null;
            };

            /**
             * Creates an AtElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.AtElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.AtElement} AtElement
             */
            AtElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.AtElement)
                    return object;
                let message = new $root.kritor.common.AtElement();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an AtElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.AtElement
             * @static
             * @param {kritor.common.AtElement} message AtElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AtElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.uid = "";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                    if (options.oneofs)
                        object._uin = "uin";
                }
                return object;
            };

            /**
             * Converts this AtElement to JSON.
             * @function toJSON
             * @memberof kritor.common.AtElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AtElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AtElement
             * @function getTypeUrl
             * @memberof kritor.common.AtElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AtElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.AtElement";
            };

            return AtElement;
        })();

        common.FaceElement = (function() {

            /**
             * Properties of a FaceElement.
             * @memberof kritor.common
             * @interface IFaceElement
             * @property {number|null} [id] FaceElement id
             * @property {boolean|null} [is_big] FaceElement is_big
             * @property {number|null} [result] FaceElement result
             */

            /**
             * Constructs a new FaceElement.
             * @memberof kritor.common
             * @classdesc Represents a FaceElement.
             * @implements IFaceElement
             * @constructor
             * @param {kritor.common.IFaceElement=} [properties] Properties to set
             */
            function FaceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FaceElement id.
             * @member {number} id
             * @memberof kritor.common.FaceElement
             * @instance
             */
            FaceElement.prototype.id = 0;

            /**
             * FaceElement is_big.
             * @member {boolean|null|undefined} is_big
             * @memberof kritor.common.FaceElement
             * @instance
             */
            FaceElement.prototype.is_big = null;

            /**
             * FaceElement result.
             * @member {number|null|undefined} result
             * @memberof kritor.common.FaceElement
             * @instance
             */
            FaceElement.prototype.result = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * FaceElement _is_big.
             * @member {"is_big"|undefined} _is_big
             * @memberof kritor.common.FaceElement
             * @instance
             */
            Object.defineProperty(FaceElement.prototype, "_is_big", {
                get: $util.oneOfGetter($oneOfFields = ["is_big"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FaceElement _result.
             * @member {"result"|undefined} _result
             * @memberof kritor.common.FaceElement
             * @instance
             */
            Object.defineProperty(FaceElement.prototype, "_result", {
                get: $util.oneOfGetter($oneOfFields = ["result"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new FaceElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.FaceElement
             * @static
             * @param {kritor.common.IFaceElement=} [properties] Properties to set
             * @returns {kritor.common.FaceElement} FaceElement instance
             */
            FaceElement.create = function create(properties) {
                return new FaceElement(properties);
            };

            /**
             * Encodes the specified FaceElement message. Does not implicitly {@link kritor.common.FaceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.FaceElement
             * @static
             * @param {kritor.common.IFaceElement} message FaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FaceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.is_big != null && Object.hasOwnProperty.call(message, "is_big"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_big);
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.result);
                return writer;
            };

            /**
             * Encodes the specified FaceElement message, length delimited. Does not implicitly {@link kritor.common.FaceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.FaceElement
             * @static
             * @param {kritor.common.IFaceElement} message FaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FaceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FaceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.FaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.FaceElement} FaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FaceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.FaceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.is_big = reader.bool();
                            break;
                        }
                    case 3: {
                            message.result = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FaceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.FaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.FaceElement} FaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FaceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FaceElement message.
             * @function verify
             * @memberof kritor.common.FaceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FaceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.is_big != null && message.hasOwnProperty("is_big")) {
                    properties._is_big = 1;
                    if (typeof message.is_big !== "boolean")
                        return "is_big: boolean expected";
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    properties._result = 1;
                    if (!$util.isInteger(message.result))
                        return "result: integer expected";
                }
                return null;
            };

            /**
             * Creates a FaceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.FaceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.FaceElement} FaceElement
             */
            FaceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.FaceElement)
                    return object;
                let message = new $root.kritor.common.FaceElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.is_big != null)
                    message.is_big = Boolean(object.is_big);
                if (object.result != null)
                    message.result = object.result >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a FaceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.FaceElement
             * @static
             * @param {kritor.common.FaceElement} message FaceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FaceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.is_big != null && message.hasOwnProperty("is_big")) {
                    object.is_big = message.is_big;
                    if (options.oneofs)
                        object._is_big = "is_big";
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    object.result = message.result;
                    if (options.oneofs)
                        object._result = "result";
                }
                return object;
            };

            /**
             * Converts this FaceElement to JSON.
             * @function toJSON
             * @memberof kritor.common.FaceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FaceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FaceElement
             * @function getTypeUrl
             * @memberof kritor.common.FaceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FaceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.FaceElement";
            };

            return FaceElement;
        })();

        common.BubbleFaceElement = (function() {

            /**
             * Properties of a BubbleFaceElement.
             * @memberof kritor.common
             * @interface IBubbleFaceElement
             * @property {number|null} [id] BubbleFaceElement id
             * @property {number|null} [count] BubbleFaceElement count
             */

            /**
             * Constructs a new BubbleFaceElement.
             * @memberof kritor.common
             * @classdesc Represents a BubbleFaceElement.
             * @implements IBubbleFaceElement
             * @constructor
             * @param {kritor.common.IBubbleFaceElement=} [properties] Properties to set
             */
            function BubbleFaceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BubbleFaceElement id.
             * @member {number} id
             * @memberof kritor.common.BubbleFaceElement
             * @instance
             */
            BubbleFaceElement.prototype.id = 0;

            /**
             * BubbleFaceElement count.
             * @member {number} count
             * @memberof kritor.common.BubbleFaceElement
             * @instance
             */
            BubbleFaceElement.prototype.count = 0;

            /**
             * Creates a new BubbleFaceElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {kritor.common.IBubbleFaceElement=} [properties] Properties to set
             * @returns {kritor.common.BubbleFaceElement} BubbleFaceElement instance
             */
            BubbleFaceElement.create = function create(properties) {
                return new BubbleFaceElement(properties);
            };

            /**
             * Encodes the specified BubbleFaceElement message. Does not implicitly {@link kritor.common.BubbleFaceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {kritor.common.IBubbleFaceElement} message BubbleFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BubbleFaceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified BubbleFaceElement message, length delimited. Does not implicitly {@link kritor.common.BubbleFaceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {kritor.common.IBubbleFaceElement} message BubbleFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BubbleFaceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BubbleFaceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.BubbleFaceElement} BubbleFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BubbleFaceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.BubbleFaceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BubbleFaceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.BubbleFaceElement} BubbleFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BubbleFaceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BubbleFaceElement message.
             * @function verify
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BubbleFaceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                return null;
            };

            /**
             * Creates a BubbleFaceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.BubbleFaceElement} BubbleFaceElement
             */
            BubbleFaceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.BubbleFaceElement)
                    return object;
                let message = new $root.kritor.common.BubbleFaceElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a BubbleFaceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {kritor.common.BubbleFaceElement} message BubbleFaceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BubbleFaceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.count = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                return object;
            };

            /**
             * Converts this BubbleFaceElement to JSON.
             * @function toJSON
             * @memberof kritor.common.BubbleFaceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BubbleFaceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BubbleFaceElement
             * @function getTypeUrl
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BubbleFaceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.BubbleFaceElement";
            };

            return BubbleFaceElement;
        })();

        common.ReplyElement = (function() {

            /**
             * Properties of a ReplyElement.
             * @memberof kritor.common
             * @interface IReplyElement
             * @property {string|null} [message_id] ReplyElement message_id
             */

            /**
             * Constructs a new ReplyElement.
             * @memberof kritor.common
             * @classdesc Represents a ReplyElement.
             * @implements IReplyElement
             * @constructor
             * @param {kritor.common.IReplyElement=} [properties] Properties to set
             */
            function ReplyElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReplyElement message_id.
             * @member {string} message_id
             * @memberof kritor.common.ReplyElement
             * @instance
             */
            ReplyElement.prototype.message_id = "";

            /**
             * Creates a new ReplyElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {kritor.common.IReplyElement=} [properties] Properties to set
             * @returns {kritor.common.ReplyElement} ReplyElement instance
             */
            ReplyElement.create = function create(properties) {
                return new ReplyElement(properties);
            };

            /**
             * Encodes the specified ReplyElement message. Does not implicitly {@link kritor.common.ReplyElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {kritor.common.IReplyElement} message ReplyElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplyElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.message_id);
                return writer;
            };

            /**
             * Encodes the specified ReplyElement message, length delimited. Does not implicitly {@link kritor.common.ReplyElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {kritor.common.IReplyElement} message ReplyElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplyElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReplyElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ReplyElement} ReplyElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplyElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ReplyElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.message_id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReplyElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ReplyElement} ReplyElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplyElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReplyElement message.
             * @function verify
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReplyElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                return null;
            };

            /**
             * Creates a ReplyElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ReplyElement} ReplyElement
             */
            ReplyElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ReplyElement)
                    return object;
                let message = new $root.kritor.common.ReplyElement();
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                return message;
            };

            /**
             * Creates a plain object from a ReplyElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {kritor.common.ReplyElement} message ReplyElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplyElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.message_id = "";
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    object.message_id = message.message_id;
                return object;
            };

            /**
             * Converts this ReplyElement to JSON.
             * @function toJSON
             * @memberof kritor.common.ReplyElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReplyElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReplyElement
             * @function getTypeUrl
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReplyElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ReplyElement";
            };

            return ReplyElement;
        })();

        common.ImageElement = (function() {

            /**
             * Properties of an ImageElement.
             * @memberof kritor.common
             * @interface IImageElement
             * @property {Uint8Array|null} [file] ImageElement file
             * @property {string|null} [file_name] ImageElement file_name
             * @property {string|null} [file_path] ImageElement file_path
             * @property {string|null} [file_url] ImageElement file_url
             * @property {string|null} [file_md5] ImageElement file_md5
             * @property {number|null} [sub_type] ImageElement sub_type
             * @property {kritor.common.ImageElement.ImageType|null} [type] ImageElement type
             */

            /**
             * Constructs a new ImageElement.
             * @memberof kritor.common
             * @classdesc Represents an ImageElement.
             * @implements IImageElement
             * @constructor
             * @param {kritor.common.IImageElement=} [properties] Properties to set
             */
            function ImageElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ImageElement file.
             * @member {Uint8Array|null|undefined} file
             * @memberof kritor.common.ImageElement
             * @instance
             */
            ImageElement.prototype.file = null;

            /**
             * ImageElement file_name.
             * @member {string|null|undefined} file_name
             * @memberof kritor.common.ImageElement
             * @instance
             */
            ImageElement.prototype.file_name = null;

            /**
             * ImageElement file_path.
             * @member {string|null|undefined} file_path
             * @memberof kritor.common.ImageElement
             * @instance
             */
            ImageElement.prototype.file_path = null;

            /**
             * ImageElement file_url.
             * @member {string|null|undefined} file_url
             * @memberof kritor.common.ImageElement
             * @instance
             */
            ImageElement.prototype.file_url = null;

            /**
             * ImageElement file_md5.
             * @member {string|null|undefined} file_md5
             * @memberof kritor.common.ImageElement
             * @instance
             */
            ImageElement.prototype.file_md5 = null;

            /**
             * ImageElement sub_type.
             * @member {number|null|undefined} sub_type
             * @memberof kritor.common.ImageElement
             * @instance
             */
            ImageElement.prototype.sub_type = null;

            /**
             * ImageElement type.
             * @member {kritor.common.ImageElement.ImageType|null|undefined} type
             * @memberof kritor.common.ImageElement
             * @instance
             */
            ImageElement.prototype.type = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ImageElement data.
             * @member {"file"|"file_name"|"file_path"|"file_url"|undefined} data
             * @memberof kritor.common.ImageElement
             * @instance
             */
            Object.defineProperty(ImageElement.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["file", "file_name", "file_path", "file_url"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ImageElement _file_md5.
             * @member {"file_md5"|undefined} _file_md5
             * @memberof kritor.common.ImageElement
             * @instance
             */
            Object.defineProperty(ImageElement.prototype, "_file_md5", {
                get: $util.oneOfGetter($oneOfFields = ["file_md5"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ImageElement _sub_type.
             * @member {"sub_type"|undefined} _sub_type
             * @memberof kritor.common.ImageElement
             * @instance
             */
            Object.defineProperty(ImageElement.prototype, "_sub_type", {
                get: $util.oneOfGetter($oneOfFields = ["sub_type"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ImageElement _type.
             * @member {"type"|undefined} _type
             * @memberof kritor.common.ImageElement
             * @instance
             */
            Object.defineProperty(ImageElement.prototype, "_type", {
                get: $util.oneOfGetter($oneOfFields = ["type"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ImageElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.ImageElement
             * @static
             * @param {kritor.common.IImageElement=} [properties] Properties to set
             * @returns {kritor.common.ImageElement} ImageElement instance
             */
            ImageElement.create = function create(properties) {
                return new ImageElement(properties);
            };

            /**
             * Encodes the specified ImageElement message. Does not implicitly {@link kritor.common.ImageElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ImageElement
             * @static
             * @param {kritor.common.IImageElement} message ImageElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImageElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.file);
                if (message.file_name != null && Object.hasOwnProperty.call(message, "file_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.file_name);
                if (message.file_path != null && Object.hasOwnProperty.call(message, "file_path"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.file_path);
                if (message.file_url != null && Object.hasOwnProperty.call(message, "file_url"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.file_url);
                if (message.file_md5 != null && Object.hasOwnProperty.call(message, "file_md5"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.file_md5);
                if (message.sub_type != null && Object.hasOwnProperty.call(message, "sub_type"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.sub_type);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified ImageElement message, length delimited. Does not implicitly {@link kritor.common.ImageElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ImageElement
             * @static
             * @param {kritor.common.IImageElement} message ImageElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImageElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ImageElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ImageElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ImageElement} ImageElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImageElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ImageElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.file_name = reader.string();
                            break;
                        }
                    case 3: {
                            message.file_path = reader.string();
                            break;
                        }
                    case 4: {
                            message.file_url = reader.string();
                            break;
                        }
                    case 5: {
                            message.file_md5 = reader.string();
                            break;
                        }
                    case 6: {
                            message.sub_type = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ImageElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ImageElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ImageElement} ImageElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImageElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ImageElement message.
             * @function verify
             * @memberof kritor.common.ImageElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ImageElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.file != null && message.hasOwnProperty("file")) {
                    properties.data = 1;
                    if (!(message.file && typeof message.file.length === "number" || $util.isString(message.file)))
                        return "file: buffer expected";
                }
                if (message.file_name != null && message.hasOwnProperty("file_name")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.file_name))
                        return "file_name: string expected";
                }
                if (message.file_path != null && message.hasOwnProperty("file_path")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.file_path))
                        return "file_path: string expected";
                }
                if (message.file_url != null && message.hasOwnProperty("file_url")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.file_url))
                        return "file_url: string expected";
                }
                if (message.file_md5 != null && message.hasOwnProperty("file_md5")) {
                    properties._file_md5 = 1;
                    if (!$util.isString(message.file_md5))
                        return "file_md5: string expected";
                }
                if (message.sub_type != null && message.hasOwnProperty("sub_type")) {
                    properties._sub_type = 1;
                    if (!$util.isInteger(message.sub_type))
                        return "sub_type: integer expected";
                }
                if (message.type != null && message.hasOwnProperty("type")) {
                    properties._type = 1;
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                }
                return null;
            };

            /**
             * Creates an ImageElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ImageElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ImageElement} ImageElement
             */
            ImageElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ImageElement)
                    return object;
                let message = new $root.kritor.common.ImageElement();
                if (object.file != null)
                    if (typeof object.file === "string")
                        $util.base64.decode(object.file, message.file = $util.newBuffer($util.base64.length(object.file)), 0);
                    else if (object.file.length >= 0)
                        message.file = object.file;
                if (object.file_name != null)
                    message.file_name = String(object.file_name);
                if (object.file_path != null)
                    message.file_path = String(object.file_path);
                if (object.file_url != null)
                    message.file_url = String(object.file_url);
                if (object.file_md5 != null)
                    message.file_md5 = String(object.file_md5);
                if (object.sub_type != null)
                    message.sub_type = object.sub_type >>> 0;
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "COMMON":
                case 0:
                    message.type = 0;
                    break;
                case "ORIGIN":
                case 1:
                    message.type = 1;
                    break;
                case "FLASH":
                case 2:
                    message.type = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an ImageElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ImageElement
             * @static
             * @param {kritor.common.ImageElement} message ImageElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImageElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = options.bytes === String ? $util.base64.encode(message.file, 0, message.file.length) : options.bytes === Array ? Array.prototype.slice.call(message.file) : message.file;
                    if (options.oneofs)
                        object.data = "file";
                }
                if (message.file_name != null && message.hasOwnProperty("file_name")) {
                    object.file_name = message.file_name;
                    if (options.oneofs)
                        object.data = "file_name";
                }
                if (message.file_path != null && message.hasOwnProperty("file_path")) {
                    object.file_path = message.file_path;
                    if (options.oneofs)
                        object.data = "file_path";
                }
                if (message.file_url != null && message.hasOwnProperty("file_url")) {
                    object.file_url = message.file_url;
                    if (options.oneofs)
                        object.data = "file_url";
                }
                if (message.file_md5 != null && message.hasOwnProperty("file_md5")) {
                    object.file_md5 = message.file_md5;
                    if (options.oneofs)
                        object._file_md5 = "file_md5";
                }
                if (message.sub_type != null && message.hasOwnProperty("sub_type")) {
                    object.sub_type = message.sub_type;
                    if (options.oneofs)
                        object._sub_type = "sub_type";
                }
                if (message.type != null && message.hasOwnProperty("type")) {
                    object.type = options.enums === String ? $root.kritor.common.ImageElement.ImageType[message.type] === undefined ? message.type : $root.kritor.common.ImageElement.ImageType[message.type] : message.type;
                    if (options.oneofs)
                        object._type = "type";
                }
                return object;
            };

            /**
             * Converts this ImageElement to JSON.
             * @function toJSON
             * @memberof kritor.common.ImageElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ImageElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ImageElement
             * @function getTypeUrl
             * @memberof kritor.common.ImageElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ImageElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ImageElement";
            };

            /**
             * ImageType enum.
             * @name kritor.common.ImageElement.ImageType
             * @enum {number}
             * @property {number} COMMON=0 COMMON value
             * @property {number} ORIGIN=1 ORIGIN value
             * @property {number} FLASH=2 FLASH value
             */
            ImageElement.ImageType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COMMON"] = 0;
                values[valuesById[1] = "ORIGIN"] = 1;
                values[valuesById[2] = "FLASH"] = 2;
                return values;
            })();

            return ImageElement;
        })();

        common.VoiceElement = (function() {

            /**
             * Properties of a VoiceElement.
             * @memberof kritor.common
             * @interface IVoiceElement
             * @property {Uint8Array|null} [file] VoiceElement file
             * @property {string|null} [file_name] VoiceElement file_name
             * @property {string|null} [file_path] VoiceElement file_path
             * @property {string|null} [file_url] VoiceElement file_url
             * @property {string|null} [file_md5] VoiceElement file_md5
             * @property {boolean|null} [magic] VoiceElement magic
             */

            /**
             * Constructs a new VoiceElement.
             * @memberof kritor.common
             * @classdesc Represents a VoiceElement.
             * @implements IVoiceElement
             * @constructor
             * @param {kritor.common.IVoiceElement=} [properties] Properties to set
             */
            function VoiceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VoiceElement file.
             * @member {Uint8Array|null|undefined} file
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            VoiceElement.prototype.file = null;

            /**
             * VoiceElement file_name.
             * @member {string|null|undefined} file_name
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            VoiceElement.prototype.file_name = null;

            /**
             * VoiceElement file_path.
             * @member {string|null|undefined} file_path
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            VoiceElement.prototype.file_path = null;

            /**
             * VoiceElement file_url.
             * @member {string|null|undefined} file_url
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            VoiceElement.prototype.file_url = null;

            /**
             * VoiceElement file_md5.
             * @member {string|null|undefined} file_md5
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            VoiceElement.prototype.file_md5 = null;

            /**
             * VoiceElement magic.
             * @member {boolean|null|undefined} magic
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            VoiceElement.prototype.magic = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * VoiceElement data.
             * @member {"file"|"file_name"|"file_path"|"file_url"|undefined} data
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            Object.defineProperty(VoiceElement.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["file", "file_name", "file_path", "file_url"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * VoiceElement _file_md5.
             * @member {"file_md5"|undefined} _file_md5
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            Object.defineProperty(VoiceElement.prototype, "_file_md5", {
                get: $util.oneOfGetter($oneOfFields = ["file_md5"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * VoiceElement _magic.
             * @member {"magic"|undefined} _magic
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            Object.defineProperty(VoiceElement.prototype, "_magic", {
                get: $util.oneOfGetter($oneOfFields = ["magic"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new VoiceElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {kritor.common.IVoiceElement=} [properties] Properties to set
             * @returns {kritor.common.VoiceElement} VoiceElement instance
             */
            VoiceElement.create = function create(properties) {
                return new VoiceElement(properties);
            };

            /**
             * Encodes the specified VoiceElement message. Does not implicitly {@link kritor.common.VoiceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {kritor.common.IVoiceElement} message VoiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoiceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.file);
                if (message.file_name != null && Object.hasOwnProperty.call(message, "file_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.file_name);
                if (message.file_path != null && Object.hasOwnProperty.call(message, "file_path"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.file_path);
                if (message.file_url != null && Object.hasOwnProperty.call(message, "file_url"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.file_url);
                if (message.file_md5 != null && Object.hasOwnProperty.call(message, "file_md5"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.file_md5);
                if (message.magic != null && Object.hasOwnProperty.call(message, "magic"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.magic);
                return writer;
            };

            /**
             * Encodes the specified VoiceElement message, length delimited. Does not implicitly {@link kritor.common.VoiceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {kritor.common.IVoiceElement} message VoiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoiceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VoiceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.VoiceElement} VoiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoiceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.VoiceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.file_name = reader.string();
                            break;
                        }
                    case 3: {
                            message.file_path = reader.string();
                            break;
                        }
                    case 4: {
                            message.file_url = reader.string();
                            break;
                        }
                    case 5: {
                            message.file_md5 = reader.string();
                            break;
                        }
                    case 6: {
                            message.magic = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VoiceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.VoiceElement} VoiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoiceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VoiceElement message.
             * @function verify
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VoiceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.file != null && message.hasOwnProperty("file")) {
                    properties.data = 1;
                    if (!(message.file && typeof message.file.length === "number" || $util.isString(message.file)))
                        return "file: buffer expected";
                }
                if (message.file_name != null && message.hasOwnProperty("file_name")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.file_name))
                        return "file_name: string expected";
                }
                if (message.file_path != null && message.hasOwnProperty("file_path")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.file_path))
                        return "file_path: string expected";
                }
                if (message.file_url != null && message.hasOwnProperty("file_url")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.file_url))
                        return "file_url: string expected";
                }
                if (message.file_md5 != null && message.hasOwnProperty("file_md5")) {
                    properties._file_md5 = 1;
                    if (!$util.isString(message.file_md5))
                        return "file_md5: string expected";
                }
                if (message.magic != null && message.hasOwnProperty("magic")) {
                    properties._magic = 1;
                    if (typeof message.magic !== "boolean")
                        return "magic: boolean expected";
                }
                return null;
            };

            /**
             * Creates a VoiceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.VoiceElement} VoiceElement
             */
            VoiceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.VoiceElement)
                    return object;
                let message = new $root.kritor.common.VoiceElement();
                if (object.file != null)
                    if (typeof object.file === "string")
                        $util.base64.decode(object.file, message.file = $util.newBuffer($util.base64.length(object.file)), 0);
                    else if (object.file.length >= 0)
                        message.file = object.file;
                if (object.file_name != null)
                    message.file_name = String(object.file_name);
                if (object.file_path != null)
                    message.file_path = String(object.file_path);
                if (object.file_url != null)
                    message.file_url = String(object.file_url);
                if (object.file_md5 != null)
                    message.file_md5 = String(object.file_md5);
                if (object.magic != null)
                    message.magic = Boolean(object.magic);
                return message;
            };

            /**
             * Creates a plain object from a VoiceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {kritor.common.VoiceElement} message VoiceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VoiceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = options.bytes === String ? $util.base64.encode(message.file, 0, message.file.length) : options.bytes === Array ? Array.prototype.slice.call(message.file) : message.file;
                    if (options.oneofs)
                        object.data = "file";
                }
                if (message.file_name != null && message.hasOwnProperty("file_name")) {
                    object.file_name = message.file_name;
                    if (options.oneofs)
                        object.data = "file_name";
                }
                if (message.file_path != null && message.hasOwnProperty("file_path")) {
                    object.file_path = message.file_path;
                    if (options.oneofs)
                        object.data = "file_path";
                }
                if (message.file_url != null && message.hasOwnProperty("file_url")) {
                    object.file_url = message.file_url;
                    if (options.oneofs)
                        object.data = "file_url";
                }
                if (message.file_md5 != null && message.hasOwnProperty("file_md5")) {
                    object.file_md5 = message.file_md5;
                    if (options.oneofs)
                        object._file_md5 = "file_md5";
                }
                if (message.magic != null && message.hasOwnProperty("magic")) {
                    object.magic = message.magic;
                    if (options.oneofs)
                        object._magic = "magic";
                }
                return object;
            };

            /**
             * Converts this VoiceElement to JSON.
             * @function toJSON
             * @memberof kritor.common.VoiceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VoiceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VoiceElement
             * @function getTypeUrl
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VoiceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.VoiceElement";
            };

            return VoiceElement;
        })();

        common.VideoElement = (function() {

            /**
             * Properties of a VideoElement.
             * @memberof kritor.common
             * @interface IVideoElement
             * @property {Uint8Array|null} [file] VideoElement file
             * @property {string|null} [file_name] VideoElement file_name
             * @property {string|null} [file_path] VideoElement file_path
             * @property {string|null} [file_url] VideoElement file_url
             * @property {string|null} [file_md5] VideoElement file_md5
             */

            /**
             * Constructs a new VideoElement.
             * @memberof kritor.common
             * @classdesc Represents a VideoElement.
             * @implements IVideoElement
             * @constructor
             * @param {kritor.common.IVideoElement=} [properties] Properties to set
             */
            function VideoElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VideoElement file.
             * @member {Uint8Array|null|undefined} file
             * @memberof kritor.common.VideoElement
             * @instance
             */
            VideoElement.prototype.file = null;

            /**
             * VideoElement file_name.
             * @member {string|null|undefined} file_name
             * @memberof kritor.common.VideoElement
             * @instance
             */
            VideoElement.prototype.file_name = null;

            /**
             * VideoElement file_path.
             * @member {string|null|undefined} file_path
             * @memberof kritor.common.VideoElement
             * @instance
             */
            VideoElement.prototype.file_path = null;

            /**
             * VideoElement file_url.
             * @member {string|null|undefined} file_url
             * @memberof kritor.common.VideoElement
             * @instance
             */
            VideoElement.prototype.file_url = null;

            /**
             * VideoElement file_md5.
             * @member {string|null|undefined} file_md5
             * @memberof kritor.common.VideoElement
             * @instance
             */
            VideoElement.prototype.file_md5 = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * VideoElement data.
             * @member {"file"|"file_name"|"file_path"|"file_url"|undefined} data
             * @memberof kritor.common.VideoElement
             * @instance
             */
            Object.defineProperty(VideoElement.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["file", "file_name", "file_path", "file_url"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * VideoElement _file_md5.
             * @member {"file_md5"|undefined} _file_md5
             * @memberof kritor.common.VideoElement
             * @instance
             */
            Object.defineProperty(VideoElement.prototype, "_file_md5", {
                get: $util.oneOfGetter($oneOfFields = ["file_md5"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new VideoElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.VideoElement
             * @static
             * @param {kritor.common.IVideoElement=} [properties] Properties to set
             * @returns {kritor.common.VideoElement} VideoElement instance
             */
            VideoElement.create = function create(properties) {
                return new VideoElement(properties);
            };

            /**
             * Encodes the specified VideoElement message. Does not implicitly {@link kritor.common.VideoElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.VideoElement
             * @static
             * @param {kritor.common.IVideoElement} message VideoElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VideoElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.file);
                if (message.file_name != null && Object.hasOwnProperty.call(message, "file_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.file_name);
                if (message.file_path != null && Object.hasOwnProperty.call(message, "file_path"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.file_path);
                if (message.file_url != null && Object.hasOwnProperty.call(message, "file_url"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.file_url);
                if (message.file_md5 != null && Object.hasOwnProperty.call(message, "file_md5"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.file_md5);
                return writer;
            };

            /**
             * Encodes the specified VideoElement message, length delimited. Does not implicitly {@link kritor.common.VideoElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.VideoElement
             * @static
             * @param {kritor.common.IVideoElement} message VideoElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VideoElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VideoElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.VideoElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.VideoElement} VideoElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VideoElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.VideoElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.file_name = reader.string();
                            break;
                        }
                    case 3: {
                            message.file_path = reader.string();
                            break;
                        }
                    case 4: {
                            message.file_url = reader.string();
                            break;
                        }
                    case 5: {
                            message.file_md5 = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VideoElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.VideoElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.VideoElement} VideoElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VideoElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VideoElement message.
             * @function verify
             * @memberof kritor.common.VideoElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VideoElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.file != null && message.hasOwnProperty("file")) {
                    properties.data = 1;
                    if (!(message.file && typeof message.file.length === "number" || $util.isString(message.file)))
                        return "file: buffer expected";
                }
                if (message.file_name != null && message.hasOwnProperty("file_name")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.file_name))
                        return "file_name: string expected";
                }
                if (message.file_path != null && message.hasOwnProperty("file_path")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.file_path))
                        return "file_path: string expected";
                }
                if (message.file_url != null && message.hasOwnProperty("file_url")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.file_url))
                        return "file_url: string expected";
                }
                if (message.file_md5 != null && message.hasOwnProperty("file_md5")) {
                    properties._file_md5 = 1;
                    if (!$util.isString(message.file_md5))
                        return "file_md5: string expected";
                }
                return null;
            };

            /**
             * Creates a VideoElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.VideoElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.VideoElement} VideoElement
             */
            VideoElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.VideoElement)
                    return object;
                let message = new $root.kritor.common.VideoElement();
                if (object.file != null)
                    if (typeof object.file === "string")
                        $util.base64.decode(object.file, message.file = $util.newBuffer($util.base64.length(object.file)), 0);
                    else if (object.file.length >= 0)
                        message.file = object.file;
                if (object.file_name != null)
                    message.file_name = String(object.file_name);
                if (object.file_path != null)
                    message.file_path = String(object.file_path);
                if (object.file_url != null)
                    message.file_url = String(object.file_url);
                if (object.file_md5 != null)
                    message.file_md5 = String(object.file_md5);
                return message;
            };

            /**
             * Creates a plain object from a VideoElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.VideoElement
             * @static
             * @param {kritor.common.VideoElement} message VideoElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VideoElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = options.bytes === String ? $util.base64.encode(message.file, 0, message.file.length) : options.bytes === Array ? Array.prototype.slice.call(message.file) : message.file;
                    if (options.oneofs)
                        object.data = "file";
                }
                if (message.file_name != null && message.hasOwnProperty("file_name")) {
                    object.file_name = message.file_name;
                    if (options.oneofs)
                        object.data = "file_name";
                }
                if (message.file_path != null && message.hasOwnProperty("file_path")) {
                    object.file_path = message.file_path;
                    if (options.oneofs)
                        object.data = "file_path";
                }
                if (message.file_url != null && message.hasOwnProperty("file_url")) {
                    object.file_url = message.file_url;
                    if (options.oneofs)
                        object.data = "file_url";
                }
                if (message.file_md5 != null && message.hasOwnProperty("file_md5")) {
                    object.file_md5 = message.file_md5;
                    if (options.oneofs)
                        object._file_md5 = "file_md5";
                }
                return object;
            };

            /**
             * Converts this VideoElement to JSON.
             * @function toJSON
             * @memberof kritor.common.VideoElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VideoElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VideoElement
             * @function getTypeUrl
             * @memberof kritor.common.VideoElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VideoElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.VideoElement";
            };

            return VideoElement;
        })();

        common.BasketballElement = (function() {

            /**
             * Properties of a BasketballElement.
             * @memberof kritor.common
             * @interface IBasketballElement
             * @property {number|null} [id] BasketballElement id
             */

            /**
             * Constructs a new BasketballElement.
             * @memberof kritor.common
             * @classdesc Represents a BasketballElement.
             * @implements IBasketballElement
             * @constructor
             * @param {kritor.common.IBasketballElement=} [properties] Properties to set
             */
            function BasketballElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BasketballElement id.
             * @member {number} id
             * @memberof kritor.common.BasketballElement
             * @instance
             */
            BasketballElement.prototype.id = 0;

            /**
             * Creates a new BasketballElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {kritor.common.IBasketballElement=} [properties] Properties to set
             * @returns {kritor.common.BasketballElement} BasketballElement instance
             */
            BasketballElement.create = function create(properties) {
                return new BasketballElement(properties);
            };

            /**
             * Encodes the specified BasketballElement message. Does not implicitly {@link kritor.common.BasketballElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {kritor.common.IBasketballElement} message BasketballElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BasketballElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified BasketballElement message, length delimited. Does not implicitly {@link kritor.common.BasketballElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {kritor.common.IBasketballElement} message BasketballElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BasketballElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BasketballElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.BasketballElement} BasketballElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BasketballElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.BasketballElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BasketballElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.BasketballElement} BasketballElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BasketballElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BasketballElement message.
             * @function verify
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BasketballElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a BasketballElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.BasketballElement} BasketballElement
             */
            BasketballElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.BasketballElement)
                    return object;
                let message = new $root.kritor.common.BasketballElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a BasketballElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {kritor.common.BasketballElement} message BasketballElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BasketballElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this BasketballElement to JSON.
             * @function toJSON
             * @memberof kritor.common.BasketballElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BasketballElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BasketballElement
             * @function getTypeUrl
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BasketballElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.BasketballElement";
            };

            return BasketballElement;
        })();

        common.DiceElement = (function() {

            /**
             * Properties of a DiceElement.
             * @memberof kritor.common
             * @interface IDiceElement
             * @property {number|null} [id] DiceElement id
             */

            /**
             * Constructs a new DiceElement.
             * @memberof kritor.common
             * @classdesc Represents a DiceElement.
             * @implements IDiceElement
             * @constructor
             * @param {kritor.common.IDiceElement=} [properties] Properties to set
             */
            function DiceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DiceElement id.
             * @member {number} id
             * @memberof kritor.common.DiceElement
             * @instance
             */
            DiceElement.prototype.id = 0;

            /**
             * Creates a new DiceElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.DiceElement
             * @static
             * @param {kritor.common.IDiceElement=} [properties] Properties to set
             * @returns {kritor.common.DiceElement} DiceElement instance
             */
            DiceElement.create = function create(properties) {
                return new DiceElement(properties);
            };

            /**
             * Encodes the specified DiceElement message. Does not implicitly {@link kritor.common.DiceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.DiceElement
             * @static
             * @param {kritor.common.IDiceElement} message DiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified DiceElement message, length delimited. Does not implicitly {@link kritor.common.DiceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.DiceElement
             * @static
             * @param {kritor.common.IDiceElement} message DiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DiceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.DiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.DiceElement} DiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.DiceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DiceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.DiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.DiceElement} DiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DiceElement message.
             * @function verify
             * @memberof kritor.common.DiceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DiceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a DiceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.DiceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.DiceElement} DiceElement
             */
            DiceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.DiceElement)
                    return object;
                let message = new $root.kritor.common.DiceElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DiceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.DiceElement
             * @static
             * @param {kritor.common.DiceElement} message DiceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DiceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this DiceElement to JSON.
             * @function toJSON
             * @memberof kritor.common.DiceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DiceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DiceElement
             * @function getTypeUrl
             * @memberof kritor.common.DiceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DiceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.DiceElement";
            };

            return DiceElement;
        })();

        common.RpsElement = (function() {

            /**
             * Properties of a RpsElement.
             * @memberof kritor.common
             * @interface IRpsElement
             * @property {number|null} [id] RpsElement id
             */

            /**
             * Constructs a new RpsElement.
             * @memberof kritor.common
             * @classdesc Represents a RpsElement.
             * @implements IRpsElement
             * @constructor
             * @param {kritor.common.IRpsElement=} [properties] Properties to set
             */
            function RpsElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RpsElement id.
             * @member {number} id
             * @memberof kritor.common.RpsElement
             * @instance
             */
            RpsElement.prototype.id = 0;

            /**
             * Creates a new RpsElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.RpsElement
             * @static
             * @param {kritor.common.IRpsElement=} [properties] Properties to set
             * @returns {kritor.common.RpsElement} RpsElement instance
             */
            RpsElement.create = function create(properties) {
                return new RpsElement(properties);
            };

            /**
             * Encodes the specified RpsElement message. Does not implicitly {@link kritor.common.RpsElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.RpsElement
             * @static
             * @param {kritor.common.IRpsElement} message RpsElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RpsElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified RpsElement message, length delimited. Does not implicitly {@link kritor.common.RpsElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.RpsElement
             * @static
             * @param {kritor.common.IRpsElement} message RpsElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RpsElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RpsElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.RpsElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.RpsElement} RpsElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RpsElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.RpsElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RpsElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.RpsElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.RpsElement} RpsElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RpsElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RpsElement message.
             * @function verify
             * @memberof kritor.common.RpsElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RpsElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a RpsElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.RpsElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.RpsElement} RpsElement
             */
            RpsElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.RpsElement)
                    return object;
                let message = new $root.kritor.common.RpsElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a RpsElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.RpsElement
             * @static
             * @param {kritor.common.RpsElement} message RpsElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RpsElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this RpsElement to JSON.
             * @function toJSON
             * @memberof kritor.common.RpsElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RpsElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RpsElement
             * @function getTypeUrl
             * @memberof kritor.common.RpsElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RpsElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.RpsElement";
            };

            return RpsElement;
        })();

        common.PokeElement = (function() {

            /**
             * Properties of a PokeElement.
             * @memberof kritor.common
             * @interface IPokeElement
             * @property {number|null} [id] PokeElement id
             * @property {number|null} [type] PokeElement type
             * @property {number|null} [strength] PokeElement strength
             */

            /**
             * Constructs a new PokeElement.
             * @memberof kritor.common
             * @classdesc Represents a PokeElement.
             * @implements IPokeElement
             * @constructor
             * @param {kritor.common.IPokeElement=} [properties] Properties to set
             */
            function PokeElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PokeElement id.
             * @member {number} id
             * @memberof kritor.common.PokeElement
             * @instance
             */
            PokeElement.prototype.id = 0;

            /**
             * PokeElement type.
             * @member {number} type
             * @memberof kritor.common.PokeElement
             * @instance
             */
            PokeElement.prototype.type = 0;

            /**
             * PokeElement strength.
             * @member {number} strength
             * @memberof kritor.common.PokeElement
             * @instance
             */
            PokeElement.prototype.strength = 0;

            /**
             * Creates a new PokeElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.PokeElement
             * @static
             * @param {kritor.common.IPokeElement=} [properties] Properties to set
             * @returns {kritor.common.PokeElement} PokeElement instance
             */
            PokeElement.create = function create(properties) {
                return new PokeElement(properties);
            };

            /**
             * Encodes the specified PokeElement message. Does not implicitly {@link kritor.common.PokeElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.PokeElement
             * @static
             * @param {kritor.common.IPokeElement} message PokeElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
                if (message.strength != null && Object.hasOwnProperty.call(message, "strength"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.strength);
                return writer;
            };

            /**
             * Encodes the specified PokeElement message, length delimited. Does not implicitly {@link kritor.common.PokeElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.PokeElement
             * @static
             * @param {kritor.common.IPokeElement} message PokeElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PokeElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.PokeElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.PokeElement} PokeElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.PokeElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.type = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.strength = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PokeElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.PokeElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.PokeElement} PokeElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PokeElement message.
             * @function verify
             * @memberof kritor.common.PokeElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PokeElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.strength != null && message.hasOwnProperty("strength"))
                    if (!$util.isInteger(message.strength))
                        return "strength: integer expected";
                return null;
            };

            /**
             * Creates a PokeElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.PokeElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.PokeElement} PokeElement
             */
            PokeElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.PokeElement)
                    return object;
                let message = new $root.kritor.common.PokeElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.type != null)
                    message.type = object.type >>> 0;
                if (object.strength != null)
                    message.strength = object.strength >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a PokeElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.PokeElement
             * @static
             * @param {kritor.common.PokeElement} message PokeElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PokeElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.type = 0;
                    object.strength = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.strength != null && message.hasOwnProperty("strength"))
                    object.strength = message.strength;
                return object;
            };

            /**
             * Converts this PokeElement to JSON.
             * @function toJSON
             * @memberof kritor.common.PokeElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PokeElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PokeElement
             * @function getTypeUrl
             * @memberof kritor.common.PokeElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PokeElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.PokeElement";
            };

            return PokeElement;
        })();

        common.CustomMusicData = (function() {

            /**
             * Properties of a CustomMusicData.
             * @memberof kritor.common
             * @interface ICustomMusicData
             * @property {string|null} [url] CustomMusicData url
             * @property {string|null} [audio] CustomMusicData audio
             * @property {string|null} [title] CustomMusicData title
             * @property {string|null} [author] CustomMusicData author
             * @property {string|null} [pic] CustomMusicData pic
             */

            /**
             * Constructs a new CustomMusicData.
             * @memberof kritor.common
             * @classdesc Represents a CustomMusicData.
             * @implements ICustomMusicData
             * @constructor
             * @param {kritor.common.ICustomMusicData=} [properties] Properties to set
             */
            function CustomMusicData(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CustomMusicData url.
             * @member {string} url
             * @memberof kritor.common.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.url = "";

            /**
             * CustomMusicData audio.
             * @member {string} audio
             * @memberof kritor.common.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.audio = "";

            /**
             * CustomMusicData title.
             * @member {string} title
             * @memberof kritor.common.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.title = "";

            /**
             * CustomMusicData author.
             * @member {string} author
             * @memberof kritor.common.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.author = "";

            /**
             * CustomMusicData pic.
             * @member {string} pic
             * @memberof kritor.common.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.pic = "";

            /**
             * Creates a new CustomMusicData instance using the specified properties.
             * @function create
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {kritor.common.ICustomMusicData=} [properties] Properties to set
             * @returns {kritor.common.CustomMusicData} CustomMusicData instance
             */
            CustomMusicData.create = function create(properties) {
                return new CustomMusicData(properties);
            };

            /**
             * Encodes the specified CustomMusicData message. Does not implicitly {@link kritor.common.CustomMusicData.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {kritor.common.ICustomMusicData} message CustomMusicData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomMusicData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.audio);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
                if (message.author != null && Object.hasOwnProperty.call(message, "author"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.author);
                if (message.pic != null && Object.hasOwnProperty.call(message, "pic"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.pic);
                return writer;
            };

            /**
             * Encodes the specified CustomMusicData message, length delimited. Does not implicitly {@link kritor.common.CustomMusicData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {kritor.common.ICustomMusicData} message CustomMusicData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomMusicData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CustomMusicData message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.CustomMusicData} CustomMusicData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomMusicData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.CustomMusicData();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    case 2: {
                            message.audio = reader.string();
                            break;
                        }
                    case 3: {
                            message.title = reader.string();
                            break;
                        }
                    case 4: {
                            message.author = reader.string();
                            break;
                        }
                    case 5: {
                            message.pic = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CustomMusicData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.CustomMusicData} CustomMusicData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomMusicData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CustomMusicData message.
             * @function verify
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CustomMusicData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.audio != null && message.hasOwnProperty("audio"))
                    if (!$util.isString(message.audio))
                        return "audio: string expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.author != null && message.hasOwnProperty("author"))
                    if (!$util.isString(message.author))
                        return "author: string expected";
                if (message.pic != null && message.hasOwnProperty("pic"))
                    if (!$util.isString(message.pic))
                        return "pic: string expected";
                return null;
            };

            /**
             * Creates a CustomMusicData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.CustomMusicData} CustomMusicData
             */
            CustomMusicData.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.CustomMusicData)
                    return object;
                let message = new $root.kritor.common.CustomMusicData();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.audio != null)
                    message.audio = String(object.audio);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.author != null)
                    message.author = String(object.author);
                if (object.pic != null)
                    message.pic = String(object.pic);
                return message;
            };

            /**
             * Creates a plain object from a CustomMusicData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {kritor.common.CustomMusicData} message CustomMusicData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CustomMusicData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.url = "";
                    object.audio = "";
                    object.title = "";
                    object.author = "";
                    object.pic = "";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.audio != null && message.hasOwnProperty("audio"))
                    object.audio = message.audio;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.author != null && message.hasOwnProperty("author"))
                    object.author = message.author;
                if (message.pic != null && message.hasOwnProperty("pic"))
                    object.pic = message.pic;
                return object;
            };

            /**
             * Converts this CustomMusicData to JSON.
             * @function toJSON
             * @memberof kritor.common.CustomMusicData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CustomMusicData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CustomMusicData
             * @function getTypeUrl
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CustomMusicData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.CustomMusicData";
            };

            return CustomMusicData;
        })();

        common.MusicElement = (function() {

            /**
             * Properties of a MusicElement.
             * @memberof kritor.common
             * @interface IMusicElement
             * @property {kritor.common.MusicElement.MusicPlatform|null} [platform] MusicElement platform
             * @property {string|null} [id] MusicElement id
             * @property {kritor.common.ICustomMusicData|null} [custom] MusicElement custom
             */

            /**
             * Constructs a new MusicElement.
             * @memberof kritor.common
             * @classdesc Represents a MusicElement.
             * @implements IMusicElement
             * @constructor
             * @param {kritor.common.IMusicElement=} [properties] Properties to set
             */
            function MusicElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MusicElement platform.
             * @member {kritor.common.MusicElement.MusicPlatform} platform
             * @memberof kritor.common.MusicElement
             * @instance
             */
            MusicElement.prototype.platform = 0;

            /**
             * MusicElement id.
             * @member {string|null|undefined} id
             * @memberof kritor.common.MusicElement
             * @instance
             */
            MusicElement.prototype.id = null;

            /**
             * MusicElement custom.
             * @member {kritor.common.ICustomMusicData|null|undefined} custom
             * @memberof kritor.common.MusicElement
             * @instance
             */
            MusicElement.prototype.custom = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * MusicElement data.
             * @member {"id"|"custom"|undefined} data
             * @memberof kritor.common.MusicElement
             * @instance
             */
            Object.defineProperty(MusicElement.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["id", "custom"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new MusicElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.MusicElement
             * @static
             * @param {kritor.common.IMusicElement=} [properties] Properties to set
             * @returns {kritor.common.MusicElement} MusicElement instance
             */
            MusicElement.create = function create(properties) {
                return new MusicElement(properties);
            };

            /**
             * Encodes the specified MusicElement message. Does not implicitly {@link kritor.common.MusicElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.MusicElement
             * @static
             * @param {kritor.common.IMusicElement} message MusicElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MusicElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.platform);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                if (message.custom != null && Object.hasOwnProperty.call(message, "custom"))
                    $root.kritor.common.CustomMusicData.encode(message.custom, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MusicElement message, length delimited. Does not implicitly {@link kritor.common.MusicElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.MusicElement
             * @static
             * @param {kritor.common.IMusicElement} message MusicElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MusicElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MusicElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.MusicElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.MusicElement} MusicElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MusicElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.MusicElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.platform = reader.int32();
                            break;
                        }
                    case 2: {
                            message.id = reader.string();
                            break;
                        }
                    case 3: {
                            message.custom = $root.kritor.common.CustomMusicData.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MusicElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.MusicElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.MusicElement} MusicElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MusicElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MusicElement message.
             * @function verify
             * @memberof kritor.common.MusicElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MusicElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.platform != null && message.hasOwnProperty("platform"))
                    switch (message.platform) {
                    default:
                        return "platform: enum value expected";
                    case 0:
                    case 1:
                    case 10:
                        break;
                    }
                if (message.id != null && message.hasOwnProperty("id")) {
                    properties.data = 1;
                    if (!$util.isString(message.id))
                        return "id: string expected";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.CustomMusicData.verify(message.custom);
                        if (error)
                            return "custom." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MusicElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.MusicElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.MusicElement} MusicElement
             */
            MusicElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.MusicElement)
                    return object;
                let message = new $root.kritor.common.MusicElement();
                switch (object.platform) {
                default:
                    if (typeof object.platform === "number") {
                        message.platform = object.platform;
                        break;
                    }
                    break;
                case "QQ":
                case 0:
                    message.platform = 0;
                    break;
                case "NetEase":
                case 1:
                    message.platform = 1;
                    break;
                case "Custom":
                case 10:
                    message.platform = 10;
                    break;
                }
                if (object.id != null)
                    message.id = String(object.id);
                if (object.custom != null) {
                    if (typeof object.custom !== "object")
                        throw TypeError(".kritor.common.MusicElement.custom: object expected");
                    message.custom = $root.kritor.common.CustomMusicData.fromObject(object.custom);
                }
                return message;
            };

            /**
             * Creates a plain object from a MusicElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.MusicElement
             * @static
             * @param {kritor.common.MusicElement} message MusicElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MusicElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.platform = options.enums === String ? "QQ" : 0;
                if (message.platform != null && message.hasOwnProperty("platform"))
                    object.platform = options.enums === String ? $root.kritor.common.MusicElement.MusicPlatform[message.platform] === undefined ? message.platform : $root.kritor.common.MusicElement.MusicPlatform[message.platform] : message.platform;
                if (message.id != null && message.hasOwnProperty("id")) {
                    object.id = message.id;
                    if (options.oneofs)
                        object.data = "id";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    object.custom = $root.kritor.common.CustomMusicData.toObject(message.custom, options);
                    if (options.oneofs)
                        object.data = "custom";
                }
                return object;
            };

            /**
             * Converts this MusicElement to JSON.
             * @function toJSON
             * @memberof kritor.common.MusicElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MusicElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MusicElement
             * @function getTypeUrl
             * @memberof kritor.common.MusicElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MusicElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.MusicElement";
            };

            /**
             * MusicPlatform enum.
             * @name kritor.common.MusicElement.MusicPlatform
             * @enum {number}
             * @property {number} QQ=0 QQ value
             * @property {number} NetEase=1 NetEase value
             * @property {number} Custom=10 Custom value
             */
            MusicElement.MusicPlatform = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "QQ"] = 0;
                values[valuesById[1] = "NetEase"] = 1;
                values[valuesById[10] = "Custom"] = 10;
                return values;
            })();

            return MusicElement;
        })();

        common.WeatherElement = (function() {

            /**
             * Properties of a WeatherElement.
             * @memberof kritor.common
             * @interface IWeatherElement
             * @property {string|null} [city] WeatherElement city
             * @property {string|null} [code] WeatherElement code
             */

            /**
             * Constructs a new WeatherElement.
             * @memberof kritor.common
             * @classdesc Represents a WeatherElement.
             * @implements IWeatherElement
             * @constructor
             * @param {kritor.common.IWeatherElement=} [properties] Properties to set
             */
            function WeatherElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WeatherElement city.
             * @member {string} city
             * @memberof kritor.common.WeatherElement
             * @instance
             */
            WeatherElement.prototype.city = "";

            /**
             * WeatherElement code.
             * @member {string} code
             * @memberof kritor.common.WeatherElement
             * @instance
             */
            WeatherElement.prototype.code = "";

            /**
             * Creates a new WeatherElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {kritor.common.IWeatherElement=} [properties] Properties to set
             * @returns {kritor.common.WeatherElement} WeatherElement instance
             */
            WeatherElement.create = function create(properties) {
                return new WeatherElement(properties);
            };

            /**
             * Encodes the specified WeatherElement message. Does not implicitly {@link kritor.common.WeatherElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {kritor.common.IWeatherElement} message WeatherElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeatherElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.city != null && Object.hasOwnProperty.call(message, "city"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.city);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.code);
                return writer;
            };

            /**
             * Encodes the specified WeatherElement message, length delimited. Does not implicitly {@link kritor.common.WeatherElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {kritor.common.IWeatherElement} message WeatherElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeatherElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WeatherElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.WeatherElement} WeatherElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeatherElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.WeatherElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.city = reader.string();
                            break;
                        }
                    case 2: {
                            message.code = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WeatherElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.WeatherElement} WeatherElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeatherElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WeatherElement message.
             * @function verify
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WeatherElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.city != null && message.hasOwnProperty("city"))
                    if (!$util.isString(message.city))
                        return "city: string expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    if (!$util.isString(message.code))
                        return "code: string expected";
                return null;
            };

            /**
             * Creates a WeatherElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.WeatherElement} WeatherElement
             */
            WeatherElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.WeatherElement)
                    return object;
                let message = new $root.kritor.common.WeatherElement();
                if (object.city != null)
                    message.city = String(object.city);
                if (object.code != null)
                    message.code = String(object.code);
                return message;
            };

            /**
             * Creates a plain object from a WeatherElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {kritor.common.WeatherElement} message WeatherElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WeatherElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.city = "";
                    object.code = "";
                }
                if (message.city != null && message.hasOwnProperty("city"))
                    object.city = message.city;
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = message.code;
                return object;
            };

            /**
             * Converts this WeatherElement to JSON.
             * @function toJSON
             * @memberof kritor.common.WeatherElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WeatherElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for WeatherElement
             * @function getTypeUrl
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            WeatherElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.WeatherElement";
            };

            return WeatherElement;
        })();

        common.LocationElement = (function() {

            /**
             * Properties of a LocationElement.
             * @memberof kritor.common
             * @interface ILocationElement
             * @property {number|null} [lat] LocationElement lat
             * @property {number|null} [lon] LocationElement lon
             * @property {string|null} [title] LocationElement title
             * @property {string|null} [address] LocationElement address
             */

            /**
             * Constructs a new LocationElement.
             * @memberof kritor.common
             * @classdesc Represents a LocationElement.
             * @implements ILocationElement
             * @constructor
             * @param {kritor.common.ILocationElement=} [properties] Properties to set
             */
            function LocationElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocationElement lat.
             * @member {number} lat
             * @memberof kritor.common.LocationElement
             * @instance
             */
            LocationElement.prototype.lat = 0;

            /**
             * LocationElement lon.
             * @member {number} lon
             * @memberof kritor.common.LocationElement
             * @instance
             */
            LocationElement.prototype.lon = 0;

            /**
             * LocationElement title.
             * @member {string} title
             * @memberof kritor.common.LocationElement
             * @instance
             */
            LocationElement.prototype.title = "";

            /**
             * LocationElement address.
             * @member {string} address
             * @memberof kritor.common.LocationElement
             * @instance
             */
            LocationElement.prototype.address = "";

            /**
             * Creates a new LocationElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.LocationElement
             * @static
             * @param {kritor.common.ILocationElement=} [properties] Properties to set
             * @returns {kritor.common.LocationElement} LocationElement instance
             */
            LocationElement.create = function create(properties) {
                return new LocationElement(properties);
            };

            /**
             * Encodes the specified LocationElement message. Does not implicitly {@link kritor.common.LocationElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.LocationElement
             * @static
             * @param {kritor.common.ILocationElement} message LocationElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lat != null && Object.hasOwnProperty.call(message, "lat"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.lat);
                if (message.lon != null && Object.hasOwnProperty.call(message, "lon"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.lon);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.address);
                return writer;
            };

            /**
             * Encodes the specified LocationElement message, length delimited. Does not implicitly {@link kritor.common.LocationElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.LocationElement
             * @static
             * @param {kritor.common.ILocationElement} message LocationElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocationElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.LocationElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.LocationElement} LocationElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.LocationElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.lat = reader.float();
                            break;
                        }
                    case 2: {
                            message.lon = reader.float();
                            break;
                        }
                    case 3: {
                            message.title = reader.string();
                            break;
                        }
                    case 4: {
                            message.address = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocationElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.LocationElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.LocationElement} LocationElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocationElement message.
             * @function verify
             * @memberof kritor.common.LocationElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocationElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lat != null && message.hasOwnProperty("lat"))
                    if (typeof message.lat !== "number")
                        return "lat: number expected";
                if (message.lon != null && message.hasOwnProperty("lon"))
                    if (typeof message.lon !== "number")
                        return "lon: number expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                return null;
            };

            /**
             * Creates a LocationElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.LocationElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.LocationElement} LocationElement
             */
            LocationElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.LocationElement)
                    return object;
                let message = new $root.kritor.common.LocationElement();
                if (object.lat != null)
                    message.lat = Number(object.lat);
                if (object.lon != null)
                    message.lon = Number(object.lon);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.address != null)
                    message.address = String(object.address);
                return message;
            };

            /**
             * Creates a plain object from a LocationElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.LocationElement
             * @static
             * @param {kritor.common.LocationElement} message LocationElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocationElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.lat = 0;
                    object.lon = 0;
                    object.title = "";
                    object.address = "";
                }
                if (message.lat != null && message.hasOwnProperty("lat"))
                    object.lat = options.json && !isFinite(message.lat) ? String(message.lat) : message.lat;
                if (message.lon != null && message.hasOwnProperty("lon"))
                    object.lon = options.json && !isFinite(message.lon) ? String(message.lon) : message.lon;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                return object;
            };

            /**
             * Converts this LocationElement to JSON.
             * @function toJSON
             * @memberof kritor.common.LocationElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocationElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LocationElement
             * @function getTypeUrl
             * @memberof kritor.common.LocationElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LocationElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.LocationElement";
            };

            return LocationElement;
        })();

        common.ShareElement = (function() {

            /**
             * Properties of a ShareElement.
             * @memberof kritor.common
             * @interface IShareElement
             * @property {string|null} [url] ShareElement url
             * @property {string|null} [title] ShareElement title
             * @property {string|null} [content] ShareElement content
             * @property {string|null} [image] ShareElement image
             */

            /**
             * Constructs a new ShareElement.
             * @memberof kritor.common
             * @classdesc Represents a ShareElement.
             * @implements IShareElement
             * @constructor
             * @param {kritor.common.IShareElement=} [properties] Properties to set
             */
            function ShareElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShareElement url.
             * @member {string} url
             * @memberof kritor.common.ShareElement
             * @instance
             */
            ShareElement.prototype.url = "";

            /**
             * ShareElement title.
             * @member {string} title
             * @memberof kritor.common.ShareElement
             * @instance
             */
            ShareElement.prototype.title = "";

            /**
             * ShareElement content.
             * @member {string} content
             * @memberof kritor.common.ShareElement
             * @instance
             */
            ShareElement.prototype.content = "";

            /**
             * ShareElement image.
             * @member {string} image
             * @memberof kritor.common.ShareElement
             * @instance
             */
            ShareElement.prototype.image = "";

            /**
             * Creates a new ShareElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.ShareElement
             * @static
             * @param {kritor.common.IShareElement=} [properties] Properties to set
             * @returns {kritor.common.ShareElement} ShareElement instance
             */
            ShareElement.create = function create(properties) {
                return new ShareElement(properties);
            };

            /**
             * Encodes the specified ShareElement message. Does not implicitly {@link kritor.common.ShareElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ShareElement
             * @static
             * @param {kritor.common.IShareElement} message ShareElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShareElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.content);
                if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.image);
                return writer;
            };

            /**
             * Encodes the specified ShareElement message, length delimited. Does not implicitly {@link kritor.common.ShareElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ShareElement
             * @static
             * @param {kritor.common.IShareElement} message ShareElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShareElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShareElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ShareElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ShareElement} ShareElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShareElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ShareElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    case 2: {
                            message.title = reader.string();
                            break;
                        }
                    case 3: {
                            message.content = reader.string();
                            break;
                        }
                    case 4: {
                            message.image = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ShareElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ShareElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ShareElement} ShareElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShareElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShareElement message.
             * @function verify
             * @memberof kritor.common.ShareElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShareElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!$util.isString(message.content))
                        return "content: string expected";
                if (message.image != null && message.hasOwnProperty("image"))
                    if (!$util.isString(message.image))
                        return "image: string expected";
                return null;
            };

            /**
             * Creates a ShareElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ShareElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ShareElement} ShareElement
             */
            ShareElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ShareElement)
                    return object;
                let message = new $root.kritor.common.ShareElement();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.content != null)
                    message.content = String(object.content);
                if (object.image != null)
                    message.image = String(object.image);
                return message;
            };

            /**
             * Creates a plain object from a ShareElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ShareElement
             * @static
             * @param {kritor.common.ShareElement} message ShareElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ShareElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.url = "";
                    object.title = "";
                    object.content = "";
                    object.image = "";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = message.content;
                if (message.image != null && message.hasOwnProperty("image"))
                    object.image = message.image;
                return object;
            };

            /**
             * Converts this ShareElement to JSON.
             * @function toJSON
             * @memberof kritor.common.ShareElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ShareElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ShareElement
             * @function getTypeUrl
             * @memberof kritor.common.ShareElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ShareElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ShareElement";
            };

            return ShareElement;
        })();

        common.GiftElement = (function() {

            /**
             * Properties of a GiftElement.
             * @memberof kritor.common
             * @interface IGiftElement
             * @property {number|Long|null} [qq] GiftElement qq
             * @property {number|null} [id] GiftElement id
             */

            /**
             * Constructs a new GiftElement.
             * @memberof kritor.common
             * @classdesc Represents a GiftElement.
             * @implements IGiftElement
             * @constructor
             * @param {kritor.common.IGiftElement=} [properties] Properties to set
             */
            function GiftElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GiftElement qq.
             * @member {number|Long} qq
             * @memberof kritor.common.GiftElement
             * @instance
             */
            GiftElement.prototype.qq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GiftElement id.
             * @member {number} id
             * @memberof kritor.common.GiftElement
             * @instance
             */
            GiftElement.prototype.id = 0;

            /**
             * Creates a new GiftElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.GiftElement
             * @static
             * @param {kritor.common.IGiftElement=} [properties] Properties to set
             * @returns {kritor.common.GiftElement} GiftElement instance
             */
            GiftElement.create = function create(properties) {
                return new GiftElement(properties);
            };

            /**
             * Encodes the specified GiftElement message. Does not implicitly {@link kritor.common.GiftElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.GiftElement
             * @static
             * @param {kritor.common.IGiftElement} message GiftElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiftElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.qq != null && Object.hasOwnProperty.call(message, "qq"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.qq);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified GiftElement message, length delimited. Does not implicitly {@link kritor.common.GiftElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.GiftElement
             * @static
             * @param {kritor.common.IGiftElement} message GiftElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiftElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GiftElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.GiftElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.GiftElement} GiftElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiftElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.GiftElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.qq = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GiftElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.GiftElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.GiftElement} GiftElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiftElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GiftElement message.
             * @function verify
             * @memberof kritor.common.GiftElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GiftElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.qq != null && message.hasOwnProperty("qq"))
                    if (!$util.isInteger(message.qq) && !(message.qq && $util.isInteger(message.qq.low) && $util.isInteger(message.qq.high)))
                        return "qq: integer|Long expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a GiftElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.GiftElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.GiftElement} GiftElement
             */
            GiftElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.GiftElement)
                    return object;
                let message = new $root.kritor.common.GiftElement();
                if (object.qq != null)
                    if ($util.Long)
                        (message.qq = $util.Long.fromValue(object.qq)).unsigned = true;
                    else if (typeof object.qq === "string")
                        message.qq = parseInt(object.qq, 10);
                    else if (typeof object.qq === "number")
                        message.qq = object.qq;
                    else if (typeof object.qq === "object")
                        message.qq = new $util.LongBits(object.qq.low >>> 0, object.qq.high >>> 0).toNumber(true);
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GiftElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.GiftElement
             * @static
             * @param {kritor.common.GiftElement} message GiftElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GiftElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.qq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.qq = options.longs === String ? "0" : 0;
                    object.id = 0;
                }
                if (message.qq != null && message.hasOwnProperty("qq"))
                    if (typeof message.qq === "number")
                        object.qq = options.longs === String ? String(message.qq) : message.qq;
                    else
                        object.qq = options.longs === String ? $util.Long.prototype.toString.call(message.qq) : options.longs === Number ? new $util.LongBits(message.qq.low >>> 0, message.qq.high >>> 0).toNumber(true) : message.qq;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this GiftElement to JSON.
             * @function toJSON
             * @memberof kritor.common.GiftElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GiftElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GiftElement
             * @function getTypeUrl
             * @memberof kritor.common.GiftElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GiftElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.GiftElement";
            };

            return GiftElement;
        })();

        common.MarketFaceElement = (function() {

            /**
             * Properties of a MarketFaceElement.
             * @memberof kritor.common
             * @interface IMarketFaceElement
             * @property {string|null} [id] MarketFaceElement id
             */

            /**
             * Constructs a new MarketFaceElement.
             * @memberof kritor.common
             * @classdesc Represents a MarketFaceElement.
             * @implements IMarketFaceElement
             * @constructor
             * @param {kritor.common.IMarketFaceElement=} [properties] Properties to set
             */
            function MarketFaceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MarketFaceElement id.
             * @member {string} id
             * @memberof kritor.common.MarketFaceElement
             * @instance
             */
            MarketFaceElement.prototype.id = "";

            /**
             * Creates a new MarketFaceElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {kritor.common.IMarketFaceElement=} [properties] Properties to set
             * @returns {kritor.common.MarketFaceElement} MarketFaceElement instance
             */
            MarketFaceElement.create = function create(properties) {
                return new MarketFaceElement(properties);
            };

            /**
             * Encodes the specified MarketFaceElement message. Does not implicitly {@link kritor.common.MarketFaceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {kritor.common.IMarketFaceElement} message MarketFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarketFaceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified MarketFaceElement message, length delimited. Does not implicitly {@link kritor.common.MarketFaceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {kritor.common.IMarketFaceElement} message MarketFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarketFaceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MarketFaceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.MarketFaceElement} MarketFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarketFaceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.MarketFaceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MarketFaceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.MarketFaceElement} MarketFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarketFaceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MarketFaceElement message.
             * @function verify
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MarketFaceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a MarketFaceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.MarketFaceElement} MarketFaceElement
             */
            MarketFaceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.MarketFaceElement)
                    return object;
                let message = new $root.kritor.common.MarketFaceElement();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a MarketFaceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {kritor.common.MarketFaceElement} message MarketFaceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MarketFaceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this MarketFaceElement to JSON.
             * @function toJSON
             * @memberof kritor.common.MarketFaceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MarketFaceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MarketFaceElement
             * @function getTypeUrl
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MarketFaceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.MarketFaceElement";
            };

            return MarketFaceElement;
        })();

        common.ForwardElement = (function() {

            /**
             * Properties of a ForwardElement.
             * @memberof kritor.common
             * @interface IForwardElement
             * @property {string|null} [res_id] ForwardElement res_id
             * @property {string|null} [uniseq] ForwardElement uniseq
             * @property {string|null} [summary] ForwardElement summary
             * @property {string|null} [description] ForwardElement description
             */

            /**
             * Constructs a new ForwardElement.
             * @memberof kritor.common
             * @classdesc Represents a ForwardElement.
             * @implements IForwardElement
             * @constructor
             * @param {kritor.common.IForwardElement=} [properties] Properties to set
             */
            function ForwardElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForwardElement res_id.
             * @member {string} res_id
             * @memberof kritor.common.ForwardElement
             * @instance
             */
            ForwardElement.prototype.res_id = "";

            /**
             * ForwardElement uniseq.
             * @member {string} uniseq
             * @memberof kritor.common.ForwardElement
             * @instance
             */
            ForwardElement.prototype.uniseq = "";

            /**
             * ForwardElement summary.
             * @member {string} summary
             * @memberof kritor.common.ForwardElement
             * @instance
             */
            ForwardElement.prototype.summary = "";

            /**
             * ForwardElement description.
             * @member {string} description
             * @memberof kritor.common.ForwardElement
             * @instance
             */
            ForwardElement.prototype.description = "";

            /**
             * Creates a new ForwardElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {kritor.common.IForwardElement=} [properties] Properties to set
             * @returns {kritor.common.ForwardElement} ForwardElement instance
             */
            ForwardElement.create = function create(properties) {
                return new ForwardElement(properties);
            };

            /**
             * Encodes the specified ForwardElement message. Does not implicitly {@link kritor.common.ForwardElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {kritor.common.IForwardElement} message ForwardElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.res_id != null && Object.hasOwnProperty.call(message, "res_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.res_id);
                if (message.uniseq != null && Object.hasOwnProperty.call(message, "uniseq"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uniseq);
                if (message.summary != null && Object.hasOwnProperty.call(message, "summary"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.summary);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                return writer;
            };

            /**
             * Encodes the specified ForwardElement message, length delimited. Does not implicitly {@link kritor.common.ForwardElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {kritor.common.IForwardElement} message ForwardElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForwardElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ForwardElement} ForwardElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ForwardElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.res_id = reader.string();
                            break;
                        }
                    case 2: {
                            message.uniseq = reader.string();
                            break;
                        }
                    case 3: {
                            message.summary = reader.string();
                            break;
                        }
                    case 4: {
                            message.description = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForwardElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ForwardElement} ForwardElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForwardElement message.
             * @function verify
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForwardElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.res_id != null && message.hasOwnProperty("res_id"))
                    if (!$util.isString(message.res_id))
                        return "res_id: string expected";
                if (message.uniseq != null && message.hasOwnProperty("uniseq"))
                    if (!$util.isString(message.uniseq))
                        return "uniseq: string expected";
                if (message.summary != null && message.hasOwnProperty("summary"))
                    if (!$util.isString(message.summary))
                        return "summary: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                return null;
            };

            /**
             * Creates a ForwardElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ForwardElement} ForwardElement
             */
            ForwardElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ForwardElement)
                    return object;
                let message = new $root.kritor.common.ForwardElement();
                if (object.res_id != null)
                    message.res_id = String(object.res_id);
                if (object.uniseq != null)
                    message.uniseq = String(object.uniseq);
                if (object.summary != null)
                    message.summary = String(object.summary);
                if (object.description != null)
                    message.description = String(object.description);
                return message;
            };

            /**
             * Creates a plain object from a ForwardElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {kritor.common.ForwardElement} message ForwardElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForwardElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.res_id = "";
                    object.uniseq = "";
                    object.summary = "";
                    object.description = "";
                }
                if (message.res_id != null && message.hasOwnProperty("res_id"))
                    object.res_id = message.res_id;
                if (message.uniseq != null && message.hasOwnProperty("uniseq"))
                    object.uniseq = message.uniseq;
                if (message.summary != null && message.hasOwnProperty("summary"))
                    object.summary = message.summary;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                return object;
            };

            /**
             * Converts this ForwardElement to JSON.
             * @function toJSON
             * @memberof kritor.common.ForwardElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForwardElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ForwardElement
             * @function getTypeUrl
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ForwardElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ForwardElement";
            };

            return ForwardElement;
        })();

        common.ContactElement = (function() {

            /**
             * Properties of a ContactElement.
             * @memberof kritor.common
             * @interface IContactElement
             * @property {kritor.common.Scene|null} [scene] ContactElement scene
             * @property {string|null} [peer] ContactElement peer
             */

            /**
             * Constructs a new ContactElement.
             * @memberof kritor.common
             * @classdesc Represents a ContactElement.
             * @implements IContactElement
             * @constructor
             * @param {kritor.common.IContactElement=} [properties] Properties to set
             */
            function ContactElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ContactElement scene.
             * @member {kritor.common.Scene} scene
             * @memberof kritor.common.ContactElement
             * @instance
             */
            ContactElement.prototype.scene = 0;

            /**
             * ContactElement peer.
             * @member {string} peer
             * @memberof kritor.common.ContactElement
             * @instance
             */
            ContactElement.prototype.peer = "";

            /**
             * Creates a new ContactElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.ContactElement
             * @static
             * @param {kritor.common.IContactElement=} [properties] Properties to set
             * @returns {kritor.common.ContactElement} ContactElement instance
             */
            ContactElement.create = function create(properties) {
                return new ContactElement(properties);
            };

            /**
             * Encodes the specified ContactElement message. Does not implicitly {@link kritor.common.ContactElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ContactElement
             * @static
             * @param {kritor.common.IContactElement} message ContactElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scene != null && Object.hasOwnProperty.call(message, "scene"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.scene);
                if (message.peer != null && Object.hasOwnProperty.call(message, "peer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.peer);
                return writer;
            };

            /**
             * Encodes the specified ContactElement message, length delimited. Does not implicitly {@link kritor.common.ContactElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ContactElement
             * @static
             * @param {kritor.common.IContactElement} message ContactElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ContactElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ContactElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ContactElement} ContactElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ContactElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.scene = reader.int32();
                            break;
                        }
                    case 2: {
                            message.peer = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ContactElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ContactElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ContactElement} ContactElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ContactElement message.
             * @function verify
             * @memberof kritor.common.ContactElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContactElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.scene != null && message.hasOwnProperty("scene"))
                    switch (message.scene) {
                    default:
                        return "scene: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 5:
                    case 9:
                        break;
                    }
                if (message.peer != null && message.hasOwnProperty("peer"))
                    if (!$util.isString(message.peer))
                        return "peer: string expected";
                return null;
            };

            /**
             * Creates a ContactElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ContactElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ContactElement} ContactElement
             */
            ContactElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ContactElement)
                    return object;
                let message = new $root.kritor.common.ContactElement();
                switch (object.scene) {
                default:
                    if (typeof object.scene === "number") {
                        message.scene = object.scene;
                        break;
                    }
                    break;
                case "GROUP":
                case 0:
                    message.scene = 0;
                    break;
                case "FRIEND":
                case 1:
                    message.scene = 1;
                    break;
                case "GUILD":
                case 2:
                    message.scene = 2;
                    break;
                case "STRANGER_FROM_GROUP":
                case 10:
                    message.scene = 10;
                    break;
                case "NEARBY":
                case 5:
                    message.scene = 5;
                    break;
                case "STRANGER":
                case 9:
                    message.scene = 9;
                    break;
                }
                if (object.peer != null)
                    message.peer = String(object.peer);
                return message;
            };

            /**
             * Creates a plain object from a ContactElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ContactElement
             * @static
             * @param {kritor.common.ContactElement} message ContactElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ContactElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.scene = options.enums === String ? "GROUP" : 0;
                    object.peer = "";
                }
                if (message.scene != null && message.hasOwnProperty("scene"))
                    object.scene = options.enums === String ? $root.kritor.common.Scene[message.scene] === undefined ? message.scene : $root.kritor.common.Scene[message.scene] : message.scene;
                if (message.peer != null && message.hasOwnProperty("peer"))
                    object.peer = message.peer;
                return object;
            };

            /**
             * Converts this ContactElement to JSON.
             * @function toJSON
             * @memberof kritor.common.ContactElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ContactElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ContactElement
             * @function getTypeUrl
             * @memberof kritor.common.ContactElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ContactElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ContactElement";
            };

            return ContactElement;
        })();

        common.JsonElement = (function() {

            /**
             * Properties of a JsonElement.
             * @memberof kritor.common
             * @interface IJsonElement
             * @property {string|null} [json] JsonElement json
             */

            /**
             * Constructs a new JsonElement.
             * @memberof kritor.common
             * @classdesc Represents a JsonElement.
             * @implements IJsonElement
             * @constructor
             * @param {kritor.common.IJsonElement=} [properties] Properties to set
             */
            function JsonElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JsonElement json.
             * @member {string} json
             * @memberof kritor.common.JsonElement
             * @instance
             */
            JsonElement.prototype.json = "";

            /**
             * Creates a new JsonElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.JsonElement
             * @static
             * @param {kritor.common.IJsonElement=} [properties] Properties to set
             * @returns {kritor.common.JsonElement} JsonElement instance
             */
            JsonElement.create = function create(properties) {
                return new JsonElement(properties);
            };

            /**
             * Encodes the specified JsonElement message. Does not implicitly {@link kritor.common.JsonElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.JsonElement
             * @static
             * @param {kritor.common.IJsonElement} message JsonElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JsonElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.json);
                return writer;
            };

            /**
             * Encodes the specified JsonElement message, length delimited. Does not implicitly {@link kritor.common.JsonElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.JsonElement
             * @static
             * @param {kritor.common.IJsonElement} message JsonElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JsonElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JsonElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.JsonElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.JsonElement} JsonElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JsonElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.JsonElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.json = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JsonElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.JsonElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.JsonElement} JsonElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JsonElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JsonElement message.
             * @function verify
             * @memberof kritor.common.JsonElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JsonElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.json != null && message.hasOwnProperty("json"))
                    if (!$util.isString(message.json))
                        return "json: string expected";
                return null;
            };

            /**
             * Creates a JsonElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.JsonElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.JsonElement} JsonElement
             */
            JsonElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.JsonElement)
                    return object;
                let message = new $root.kritor.common.JsonElement();
                if (object.json != null)
                    message.json = String(object.json);
                return message;
            };

            /**
             * Creates a plain object from a JsonElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.JsonElement
             * @static
             * @param {kritor.common.JsonElement} message JsonElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JsonElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.json = "";
                if (message.json != null && message.hasOwnProperty("json"))
                    object.json = message.json;
                return object;
            };

            /**
             * Converts this JsonElement to JSON.
             * @function toJSON
             * @memberof kritor.common.JsonElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JsonElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for JsonElement
             * @function getTypeUrl
             * @memberof kritor.common.JsonElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            JsonElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.JsonElement";
            };

            return JsonElement;
        })();

        common.XmlElement = (function() {

            /**
             * Properties of a XmlElement.
             * @memberof kritor.common
             * @interface IXmlElement
             * @property {string|null} [xml] XmlElement xml
             */

            /**
             * Constructs a new XmlElement.
             * @memberof kritor.common
             * @classdesc Represents a XmlElement.
             * @implements IXmlElement
             * @constructor
             * @param {kritor.common.IXmlElement=} [properties] Properties to set
             */
            function XmlElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * XmlElement xml.
             * @member {string} xml
             * @memberof kritor.common.XmlElement
             * @instance
             */
            XmlElement.prototype.xml = "";

            /**
             * Creates a new XmlElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.XmlElement
             * @static
             * @param {kritor.common.IXmlElement=} [properties] Properties to set
             * @returns {kritor.common.XmlElement} XmlElement instance
             */
            XmlElement.create = function create(properties) {
                return new XmlElement(properties);
            };

            /**
             * Encodes the specified XmlElement message. Does not implicitly {@link kritor.common.XmlElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.XmlElement
             * @static
             * @param {kritor.common.IXmlElement} message XmlElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            XmlElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.xml != null && Object.hasOwnProperty.call(message, "xml"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.xml);
                return writer;
            };

            /**
             * Encodes the specified XmlElement message, length delimited. Does not implicitly {@link kritor.common.XmlElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.XmlElement
             * @static
             * @param {kritor.common.IXmlElement} message XmlElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            XmlElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a XmlElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.XmlElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.XmlElement} XmlElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            XmlElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.XmlElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.xml = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a XmlElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.XmlElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.XmlElement} XmlElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            XmlElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a XmlElement message.
             * @function verify
             * @memberof kritor.common.XmlElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            XmlElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.xml != null && message.hasOwnProperty("xml"))
                    if (!$util.isString(message.xml))
                        return "xml: string expected";
                return null;
            };

            /**
             * Creates a XmlElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.XmlElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.XmlElement} XmlElement
             */
            XmlElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.XmlElement)
                    return object;
                let message = new $root.kritor.common.XmlElement();
                if (object.xml != null)
                    message.xml = String(object.xml);
                return message;
            };

            /**
             * Creates a plain object from a XmlElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.XmlElement
             * @static
             * @param {kritor.common.XmlElement} message XmlElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            XmlElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.xml = "";
                if (message.xml != null && message.hasOwnProperty("xml"))
                    object.xml = message.xml;
                return object;
            };

            /**
             * Converts this XmlElement to JSON.
             * @function toJSON
             * @memberof kritor.common.XmlElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            XmlElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for XmlElement
             * @function getTypeUrl
             * @memberof kritor.common.XmlElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            XmlElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.XmlElement";
            };

            return XmlElement;
        })();

        common.FileElement = (function() {

            /**
             * Properties of a FileElement.
             * @memberof kritor.common
             * @interface IFileElement
             * @property {string|null} [name] FileElement name
             * @property {number|Long|null} [size] FileElement size
             * @property {number|Long|null} [expire_time] FileElement expire_time
             * @property {string|null} [id] FileElement id
             * @property {string|null} [url] FileElement url
             * @property {number|null} [biz] FileElement biz
             * @property {string|null} [sub_id] FileElement sub_id
             */

            /**
             * Constructs a new FileElement.
             * @memberof kritor.common
             * @classdesc Represents a FileElement.
             * @implements IFileElement
             * @constructor
             * @param {kritor.common.IFileElement=} [properties] Properties to set
             */
            function FileElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileElement name.
             * @member {string|null|undefined} name
             * @memberof kritor.common.FileElement
             * @instance
             */
            FileElement.prototype.name = null;

            /**
             * FileElement size.
             * @member {number|Long|null|undefined} size
             * @memberof kritor.common.FileElement
             * @instance
             */
            FileElement.prototype.size = null;

            /**
             * FileElement expire_time.
             * @member {number|Long|null|undefined} expire_time
             * @memberof kritor.common.FileElement
             * @instance
             */
            FileElement.prototype.expire_time = null;

            /**
             * FileElement id.
             * @member {string|null|undefined} id
             * @memberof kritor.common.FileElement
             * @instance
             */
            FileElement.prototype.id = null;

            /**
             * FileElement url.
             * @member {string|null|undefined} url
             * @memberof kritor.common.FileElement
             * @instance
             */
            FileElement.prototype.url = null;

            /**
             * FileElement biz.
             * @member {number|null|undefined} biz
             * @memberof kritor.common.FileElement
             * @instance
             */
            FileElement.prototype.biz = null;

            /**
             * FileElement sub_id.
             * @member {string|null|undefined} sub_id
             * @memberof kritor.common.FileElement
             * @instance
             */
            FileElement.prototype.sub_id = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * FileElement _name.
             * @member {"name"|undefined} _name
             * @memberof kritor.common.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_name", {
                get: $util.oneOfGetter($oneOfFields = ["name"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _size.
             * @member {"size"|undefined} _size
             * @memberof kritor.common.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_size", {
                get: $util.oneOfGetter($oneOfFields = ["size"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _expire_time.
             * @member {"expire_time"|undefined} _expire_time
             * @memberof kritor.common.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_expire_time", {
                get: $util.oneOfGetter($oneOfFields = ["expire_time"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _id.
             * @member {"id"|undefined} _id
             * @memberof kritor.common.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_id", {
                get: $util.oneOfGetter($oneOfFields = ["id"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _url.
             * @member {"url"|undefined} _url
             * @memberof kritor.common.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_url", {
                get: $util.oneOfGetter($oneOfFields = ["url"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _biz.
             * @member {"biz"|undefined} _biz
             * @memberof kritor.common.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_biz", {
                get: $util.oneOfGetter($oneOfFields = ["biz"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _sub_id.
             * @member {"sub_id"|undefined} _sub_id
             * @memberof kritor.common.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_sub_id", {
                get: $util.oneOfGetter($oneOfFields = ["sub_id"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new FileElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.FileElement
             * @static
             * @param {kritor.common.IFileElement=} [properties] Properties to set
             * @returns {kritor.common.FileElement} FileElement instance
             */
            FileElement.create = function create(properties) {
                return new FileElement(properties);
            };

            /**
             * Encodes the specified FileElement message. Does not implicitly {@link kritor.common.FileElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.FileElement
             * @static
             * @param {kritor.common.IFileElement} message FileElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.size);
                if (message.expire_time != null && Object.hasOwnProperty.call(message, "expire_time"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.expire_time);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.id);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.url);
                if (message.biz != null && Object.hasOwnProperty.call(message, "biz"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.biz);
                if (message.sub_id != null && Object.hasOwnProperty.call(message, "sub_id"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.sub_id);
                return writer;
            };

            /**
             * Encodes the specified FileElement message, length delimited. Does not implicitly {@link kritor.common.FileElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.FileElement
             * @static
             * @param {kritor.common.IFileElement} message FileElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.FileElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.FileElement} FileElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.FileElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.size = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.expire_time = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.id = reader.string();
                            break;
                        }
                    case 5: {
                            message.url = reader.string();
                            break;
                        }
                    case 6: {
                            message.biz = reader.int32();
                            break;
                        }
                    case 7: {
                            message.sub_id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.FileElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.FileElement} FileElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileElement message.
             * @function verify
             * @memberof kritor.common.FileElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.name != null && message.hasOwnProperty("name")) {
                    properties._name = 1;
                    if (!$util.isString(message.name))
                        return "name: string expected";
                }
                if (message.size != null && message.hasOwnProperty("size")) {
                    properties._size = 1;
                    if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                        return "size: integer|Long expected";
                }
                if (message.expire_time != null && message.hasOwnProperty("expire_time")) {
                    properties._expire_time = 1;
                    if (!$util.isInteger(message.expire_time) && !(message.expire_time && $util.isInteger(message.expire_time.low) && $util.isInteger(message.expire_time.high)))
                        return "expire_time: integer|Long expected";
                }
                if (message.id != null && message.hasOwnProperty("id")) {
                    properties._id = 1;
                    if (!$util.isString(message.id))
                        return "id: string expected";
                }
                if (message.url != null && message.hasOwnProperty("url")) {
                    properties._url = 1;
                    if (!$util.isString(message.url))
                        return "url: string expected";
                }
                if (message.biz != null && message.hasOwnProperty("biz")) {
                    properties._biz = 1;
                    if (!$util.isInteger(message.biz))
                        return "biz: integer expected";
                }
                if (message.sub_id != null && message.hasOwnProperty("sub_id")) {
                    properties._sub_id = 1;
                    if (!$util.isString(message.sub_id))
                        return "sub_id: string expected";
                }
                return null;
            };

            /**
             * Creates a FileElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.FileElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.FileElement} FileElement
             */
            FileElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.FileElement)
                    return object;
                let message = new $root.kritor.common.FileElement();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.size != null)
                    if ($util.Long)
                        (message.size = $util.Long.fromValue(object.size)).unsigned = true;
                    else if (typeof object.size === "string")
                        message.size = parseInt(object.size, 10);
                    else if (typeof object.size === "number")
                        message.size = object.size;
                    else if (typeof object.size === "object")
                        message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber(true);
                if (object.expire_time != null)
                    if ($util.Long)
                        (message.expire_time = $util.Long.fromValue(object.expire_time)).unsigned = true;
                    else if (typeof object.expire_time === "string")
                        message.expire_time = parseInt(object.expire_time, 10);
                    else if (typeof object.expire_time === "number")
                        message.expire_time = object.expire_time;
                    else if (typeof object.expire_time === "object")
                        message.expire_time = new $util.LongBits(object.expire_time.low >>> 0, object.expire_time.high >>> 0).toNumber(true);
                if (object.id != null)
                    message.id = String(object.id);
                if (object.url != null)
                    message.url = String(object.url);
                if (object.biz != null)
                    message.biz = object.biz | 0;
                if (object.sub_id != null)
                    message.sub_id = String(object.sub_id);
                return message;
            };

            /**
             * Creates a plain object from a FileElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.FileElement
             * @static
             * @param {kritor.common.FileElement} message FileElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.name != null && message.hasOwnProperty("name")) {
                    object.name = message.name;
                    if (options.oneofs)
                        object._name = "name";
                }
                if (message.size != null && message.hasOwnProperty("size")) {
                    if (typeof message.size === "number")
                        object.size = options.longs === String ? String(message.size) : message.size;
                    else
                        object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber(true) : message.size;
                    if (options.oneofs)
                        object._size = "size";
                }
                if (message.expire_time != null && message.hasOwnProperty("expire_time")) {
                    if (typeof message.expire_time === "number")
                        object.expire_time = options.longs === String ? String(message.expire_time) : message.expire_time;
                    else
                        object.expire_time = options.longs === String ? $util.Long.prototype.toString.call(message.expire_time) : options.longs === Number ? new $util.LongBits(message.expire_time.low >>> 0, message.expire_time.high >>> 0).toNumber(true) : message.expire_time;
                    if (options.oneofs)
                        object._expire_time = "expire_time";
                }
                if (message.id != null && message.hasOwnProperty("id")) {
                    object.id = message.id;
                    if (options.oneofs)
                        object._id = "id";
                }
                if (message.url != null && message.hasOwnProperty("url")) {
                    object.url = message.url;
                    if (options.oneofs)
                        object._url = "url";
                }
                if (message.biz != null && message.hasOwnProperty("biz")) {
                    object.biz = message.biz;
                    if (options.oneofs)
                        object._biz = "biz";
                }
                if (message.sub_id != null && message.hasOwnProperty("sub_id")) {
                    object.sub_id = message.sub_id;
                    if (options.oneofs)
                        object._sub_id = "sub_id";
                }
                return object;
            };

            /**
             * Converts this FileElement to JSON.
             * @function toJSON
             * @memberof kritor.common.FileElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FileElement
             * @function getTypeUrl
             * @memberof kritor.common.FileElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.FileElement";
            };

            return FileElement;
        })();

        common.MarkdownElement = (function() {

            /**
             * Properties of a MarkdownElement.
             * @memberof kritor.common
             * @interface IMarkdownElement
             * @property {string|null} [markdown] MarkdownElement markdown
             */

            /**
             * Constructs a new MarkdownElement.
             * @memberof kritor.common
             * @classdesc Represents a MarkdownElement.
             * @implements IMarkdownElement
             * @constructor
             * @param {kritor.common.IMarkdownElement=} [properties] Properties to set
             */
            function MarkdownElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MarkdownElement markdown.
             * @member {string} markdown
             * @memberof kritor.common.MarkdownElement
             * @instance
             */
            MarkdownElement.prototype.markdown = "";

            /**
             * Creates a new MarkdownElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {kritor.common.IMarkdownElement=} [properties] Properties to set
             * @returns {kritor.common.MarkdownElement} MarkdownElement instance
             */
            MarkdownElement.create = function create(properties) {
                return new MarkdownElement(properties);
            };

            /**
             * Encodes the specified MarkdownElement message. Does not implicitly {@link kritor.common.MarkdownElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {kritor.common.IMarkdownElement} message MarkdownElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarkdownElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.markdown != null && Object.hasOwnProperty.call(message, "markdown"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.markdown);
                return writer;
            };

            /**
             * Encodes the specified MarkdownElement message, length delimited. Does not implicitly {@link kritor.common.MarkdownElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {kritor.common.IMarkdownElement} message MarkdownElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarkdownElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MarkdownElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.MarkdownElement} MarkdownElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarkdownElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.MarkdownElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.markdown = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MarkdownElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.MarkdownElement} MarkdownElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarkdownElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MarkdownElement message.
             * @function verify
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MarkdownElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.markdown != null && message.hasOwnProperty("markdown"))
                    if (!$util.isString(message.markdown))
                        return "markdown: string expected";
                return null;
            };

            /**
             * Creates a MarkdownElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.MarkdownElement} MarkdownElement
             */
            MarkdownElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.MarkdownElement)
                    return object;
                let message = new $root.kritor.common.MarkdownElement();
                if (object.markdown != null)
                    message.markdown = String(object.markdown);
                return message;
            };

            /**
             * Creates a plain object from a MarkdownElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {kritor.common.MarkdownElement} message MarkdownElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MarkdownElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.markdown = "";
                if (message.markdown != null && message.hasOwnProperty("markdown"))
                    object.markdown = message.markdown;
                return object;
            };

            /**
             * Converts this MarkdownElement to JSON.
             * @function toJSON
             * @memberof kritor.common.MarkdownElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MarkdownElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MarkdownElement
             * @function getTypeUrl
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MarkdownElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.MarkdownElement";
            };

            return MarkdownElement;
        })();

        common.ButtonActionPermission = (function() {

            /**
             * Properties of a ButtonActionPermission.
             * @memberof kritor.common
             * @interface IButtonActionPermission
             * @property {number|null} [type] ButtonActionPermission type
             * @property {Array.<string>|null} [role_ids] ButtonActionPermission role_ids
             * @property {Array.<string>|null} [user_ids] ButtonActionPermission user_ids
             */

            /**
             * Constructs a new ButtonActionPermission.
             * @memberof kritor.common
             * @classdesc Represents a ButtonActionPermission.
             * @implements IButtonActionPermission
             * @constructor
             * @param {kritor.common.IButtonActionPermission=} [properties] Properties to set
             */
            function ButtonActionPermission(properties) {
                this.role_ids = [];
                this.user_ids = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonActionPermission type.
             * @member {number} type
             * @memberof kritor.common.ButtonActionPermission
             * @instance
             */
            ButtonActionPermission.prototype.type = 0;

            /**
             * ButtonActionPermission role_ids.
             * @member {Array.<string>} role_ids
             * @memberof kritor.common.ButtonActionPermission
             * @instance
             */
            ButtonActionPermission.prototype.role_ids = $util.emptyArray;

            /**
             * ButtonActionPermission user_ids.
             * @member {Array.<string>} user_ids
             * @memberof kritor.common.ButtonActionPermission
             * @instance
             */
            ButtonActionPermission.prototype.user_ids = $util.emptyArray;

            /**
             * Creates a new ButtonActionPermission instance using the specified properties.
             * @function create
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {kritor.common.IButtonActionPermission=} [properties] Properties to set
             * @returns {kritor.common.ButtonActionPermission} ButtonActionPermission instance
             */
            ButtonActionPermission.create = function create(properties) {
                return new ButtonActionPermission(properties);
            };

            /**
             * Encodes the specified ButtonActionPermission message. Does not implicitly {@link kritor.common.ButtonActionPermission.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {kritor.common.IButtonActionPermission} message ButtonActionPermission message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonActionPermission.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.role_ids != null && message.role_ids.length)
                    for (let i = 0; i < message.role_ids.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.role_ids[i]);
                if (message.user_ids != null && message.user_ids.length)
                    for (let i = 0; i < message.user_ids.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.user_ids[i]);
                return writer;
            };

            /**
             * Encodes the specified ButtonActionPermission message, length delimited. Does not implicitly {@link kritor.common.ButtonActionPermission.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {kritor.common.IButtonActionPermission} message ButtonActionPermission message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonActionPermission.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonActionPermission message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ButtonActionPermission} ButtonActionPermission
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonActionPermission.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ButtonActionPermission();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            if (!(message.role_ids && message.role_ids.length))
                                message.role_ids = [];
                            message.role_ids.push(reader.string());
                            break;
                        }
                    case 3: {
                            if (!(message.user_ids && message.user_ids.length))
                                message.user_ids = [];
                            message.user_ids.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonActionPermission message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ButtonActionPermission} ButtonActionPermission
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonActionPermission.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonActionPermission message.
             * @function verify
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonActionPermission.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.role_ids != null && message.hasOwnProperty("role_ids")) {
                    if (!Array.isArray(message.role_ids))
                        return "role_ids: array expected";
                    for (let i = 0; i < message.role_ids.length; ++i)
                        if (!$util.isString(message.role_ids[i]))
                            return "role_ids: string[] expected";
                }
                if (message.user_ids != null && message.hasOwnProperty("user_ids")) {
                    if (!Array.isArray(message.user_ids))
                        return "user_ids: array expected";
                    for (let i = 0; i < message.user_ids.length; ++i)
                        if (!$util.isString(message.user_ids[i]))
                            return "user_ids: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ButtonActionPermission message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ButtonActionPermission} ButtonActionPermission
             */
            ButtonActionPermission.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ButtonActionPermission)
                    return object;
                let message = new $root.kritor.common.ButtonActionPermission();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.role_ids) {
                    if (!Array.isArray(object.role_ids))
                        throw TypeError(".kritor.common.ButtonActionPermission.role_ids: array expected");
                    message.role_ids = [];
                    for (let i = 0; i < object.role_ids.length; ++i)
                        message.role_ids[i] = String(object.role_ids[i]);
                }
                if (object.user_ids) {
                    if (!Array.isArray(object.user_ids))
                        throw TypeError(".kritor.common.ButtonActionPermission.user_ids: array expected");
                    message.user_ids = [];
                    for (let i = 0; i < object.user_ids.length; ++i)
                        message.user_ids[i] = String(object.user_ids[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ButtonActionPermission message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {kritor.common.ButtonActionPermission} message ButtonActionPermission
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonActionPermission.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.role_ids = [];
                    object.user_ids = [];
                }
                if (options.defaults)
                    object.type = 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.role_ids && message.role_ids.length) {
                    object.role_ids = [];
                    for (let j = 0; j < message.role_ids.length; ++j)
                        object.role_ids[j] = message.role_ids[j];
                }
                if (message.user_ids && message.user_ids.length) {
                    object.user_ids = [];
                    for (let j = 0; j < message.user_ids.length; ++j)
                        object.user_ids[j] = message.user_ids[j];
                }
                return object;
            };

            /**
             * Converts this ButtonActionPermission to JSON.
             * @function toJSON
             * @memberof kritor.common.ButtonActionPermission
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonActionPermission.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonActionPermission
             * @function getTypeUrl
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonActionPermission.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ButtonActionPermission";
            };

            return ButtonActionPermission;
        })();

        common.ButtonAction = (function() {

            /**
             * Properties of a ButtonAction.
             * @memberof kritor.common
             * @interface IButtonAction
             * @property {number|null} [type] ButtonAction type
             * @property {kritor.common.IButtonActionPermission|null} [permission] ButtonAction permission
             * @property {string|null} [unsupported_tips] ButtonAction unsupported_tips
             * @property {string|null} [data] ButtonAction data
             * @property {boolean|null} [reply] ButtonAction reply
             * @property {boolean|null} [enter] ButtonAction enter
             */

            /**
             * Constructs a new ButtonAction.
             * @memberof kritor.common
             * @classdesc Represents a ButtonAction.
             * @implements IButtonAction
             * @constructor
             * @param {kritor.common.IButtonAction=} [properties] Properties to set
             */
            function ButtonAction(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonAction type.
             * @member {number} type
             * @memberof kritor.common.ButtonAction
             * @instance
             */
            ButtonAction.prototype.type = 0;

            /**
             * ButtonAction permission.
             * @member {kritor.common.IButtonActionPermission|null|undefined} permission
             * @memberof kritor.common.ButtonAction
             * @instance
             */
            ButtonAction.prototype.permission = null;

            /**
             * ButtonAction unsupported_tips.
             * @member {string} unsupported_tips
             * @memberof kritor.common.ButtonAction
             * @instance
             */
            ButtonAction.prototype.unsupported_tips = "";

            /**
             * ButtonAction data.
             * @member {string} data
             * @memberof kritor.common.ButtonAction
             * @instance
             */
            ButtonAction.prototype.data = "";

            /**
             * ButtonAction reply.
             * @member {boolean} reply
             * @memberof kritor.common.ButtonAction
             * @instance
             */
            ButtonAction.prototype.reply = false;

            /**
             * ButtonAction enter.
             * @member {boolean} enter
             * @memberof kritor.common.ButtonAction
             * @instance
             */
            ButtonAction.prototype.enter = false;

            /**
             * Creates a new ButtonAction instance using the specified properties.
             * @function create
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {kritor.common.IButtonAction=} [properties] Properties to set
             * @returns {kritor.common.ButtonAction} ButtonAction instance
             */
            ButtonAction.create = function create(properties) {
                return new ButtonAction(properties);
            };

            /**
             * Encodes the specified ButtonAction message. Does not implicitly {@link kritor.common.ButtonAction.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {kritor.common.IButtonAction} message ButtonAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.permission != null && Object.hasOwnProperty.call(message, "permission"))
                    $root.kritor.common.ButtonActionPermission.encode(message.permission, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.unsupported_tips != null && Object.hasOwnProperty.call(message, "unsupported_tips"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.unsupported_tips);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.data);
                if (message.reply != null && Object.hasOwnProperty.call(message, "reply"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.reply);
                if (message.enter != null && Object.hasOwnProperty.call(message, "enter"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.enter);
                return writer;
            };

            /**
             * Encodes the specified ButtonAction message, length delimited. Does not implicitly {@link kritor.common.ButtonAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {kritor.common.IButtonAction} message ButtonAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonAction message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ButtonAction} ButtonAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ButtonAction();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.permission = $root.kritor.common.ButtonActionPermission.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.unsupported_tips = reader.string();
                            break;
                        }
                    case 4: {
                            message.data = reader.string();
                            break;
                        }
                    case 5: {
                            message.reply = reader.bool();
                            break;
                        }
                    case 6: {
                            message.enter = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ButtonAction} ButtonAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonAction message.
             * @function verify
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.permission != null && message.hasOwnProperty("permission")) {
                    let error = $root.kritor.common.ButtonActionPermission.verify(message.permission);
                    if (error)
                        return "permission." + error;
                }
                if (message.unsupported_tips != null && message.hasOwnProperty("unsupported_tips"))
                    if (!$util.isString(message.unsupported_tips))
                        return "unsupported_tips: string expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isString(message.data))
                        return "data: string expected";
                if (message.reply != null && message.hasOwnProperty("reply"))
                    if (typeof message.reply !== "boolean")
                        return "reply: boolean expected";
                if (message.enter != null && message.hasOwnProperty("enter"))
                    if (typeof message.enter !== "boolean")
                        return "enter: boolean expected";
                return null;
            };

            /**
             * Creates a ButtonAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ButtonAction} ButtonAction
             */
            ButtonAction.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ButtonAction)
                    return object;
                let message = new $root.kritor.common.ButtonAction();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.permission != null) {
                    if (typeof object.permission !== "object")
                        throw TypeError(".kritor.common.ButtonAction.permission: object expected");
                    message.permission = $root.kritor.common.ButtonActionPermission.fromObject(object.permission);
                }
                if (object.unsupported_tips != null)
                    message.unsupported_tips = String(object.unsupported_tips);
                if (object.data != null)
                    message.data = String(object.data);
                if (object.reply != null)
                    message.reply = Boolean(object.reply);
                if (object.enter != null)
                    message.enter = Boolean(object.enter);
                return message;
            };

            /**
             * Creates a plain object from a ButtonAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {kritor.common.ButtonAction} message ButtonAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.permission = null;
                    object.unsupported_tips = "";
                    object.data = "";
                    object.reply = false;
                    object.enter = false;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.permission != null && message.hasOwnProperty("permission"))
                    object.permission = $root.kritor.common.ButtonActionPermission.toObject(message.permission, options);
                if (message.unsupported_tips != null && message.hasOwnProperty("unsupported_tips"))
                    object.unsupported_tips = message.unsupported_tips;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                if (message.reply != null && message.hasOwnProperty("reply"))
                    object.reply = message.reply;
                if (message.enter != null && message.hasOwnProperty("enter"))
                    object.enter = message.enter;
                return object;
            };

            /**
             * Converts this ButtonAction to JSON.
             * @function toJSON
             * @memberof kritor.common.ButtonAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonAction
             * @function getTypeUrl
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ButtonAction";
            };

            return ButtonAction;
        })();

        common.ButtonRender = (function() {

            /**
             * Properties of a ButtonRender.
             * @memberof kritor.common
             * @interface IButtonRender
             * @property {string|null} [label] ButtonRender label
             * @property {string|null} [visited_label] ButtonRender visited_label
             * @property {number|null} [style] ButtonRender style
             */

            /**
             * Constructs a new ButtonRender.
             * @memberof kritor.common
             * @classdesc Represents a ButtonRender.
             * @implements IButtonRender
             * @constructor
             * @param {kritor.common.IButtonRender=} [properties] Properties to set
             */
            function ButtonRender(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonRender label.
             * @member {string} label
             * @memberof kritor.common.ButtonRender
             * @instance
             */
            ButtonRender.prototype.label = "";

            /**
             * ButtonRender visited_label.
             * @member {string} visited_label
             * @memberof kritor.common.ButtonRender
             * @instance
             */
            ButtonRender.prototype.visited_label = "";

            /**
             * ButtonRender style.
             * @member {number} style
             * @memberof kritor.common.ButtonRender
             * @instance
             */
            ButtonRender.prototype.style = 0;

            /**
             * Creates a new ButtonRender instance using the specified properties.
             * @function create
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {kritor.common.IButtonRender=} [properties] Properties to set
             * @returns {kritor.common.ButtonRender} ButtonRender instance
             */
            ButtonRender.create = function create(properties) {
                return new ButtonRender(properties);
            };

            /**
             * Encodes the specified ButtonRender message. Does not implicitly {@link kritor.common.ButtonRender.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {kritor.common.IButtonRender} message ButtonRender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonRender.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.label);
                if (message.visited_label != null && Object.hasOwnProperty.call(message, "visited_label"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.visited_label);
                if (message.style != null && Object.hasOwnProperty.call(message, "style"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.style);
                return writer;
            };

            /**
             * Encodes the specified ButtonRender message, length delimited. Does not implicitly {@link kritor.common.ButtonRender.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {kritor.common.IButtonRender} message ButtonRender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonRender.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonRender message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ButtonRender} ButtonRender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonRender.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ButtonRender();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.label = reader.string();
                            break;
                        }
                    case 2: {
                            message.visited_label = reader.string();
                            break;
                        }
                    case 3: {
                            message.style = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonRender message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ButtonRender} ButtonRender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonRender.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonRender message.
             * @function verify
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonRender.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                if (message.visited_label != null && message.hasOwnProperty("visited_label"))
                    if (!$util.isString(message.visited_label))
                        return "visited_label: string expected";
                if (message.style != null && message.hasOwnProperty("style"))
                    if (!$util.isInteger(message.style))
                        return "style: integer expected";
                return null;
            };

            /**
             * Creates a ButtonRender message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ButtonRender} ButtonRender
             */
            ButtonRender.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ButtonRender)
                    return object;
                let message = new $root.kritor.common.ButtonRender();
                if (object.label != null)
                    message.label = String(object.label);
                if (object.visited_label != null)
                    message.visited_label = String(object.visited_label);
                if (object.style != null)
                    message.style = object.style | 0;
                return message;
            };

            /**
             * Creates a plain object from a ButtonRender message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {kritor.common.ButtonRender} message ButtonRender
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonRender.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.label = "";
                    object.visited_label = "";
                    object.style = 0;
                }
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = message.label;
                if (message.visited_label != null && message.hasOwnProperty("visited_label"))
                    object.visited_label = message.visited_label;
                if (message.style != null && message.hasOwnProperty("style"))
                    object.style = message.style;
                return object;
            };

            /**
             * Converts this ButtonRender to JSON.
             * @function toJSON
             * @memberof kritor.common.ButtonRender
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonRender.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonRender
             * @function getTypeUrl
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonRender.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ButtonRender";
            };

            return ButtonRender;
        })();

        common.Button = (function() {

            /**
             * Properties of a Button.
             * @memberof kritor.common
             * @interface IButton
             * @property {string|null} [id] Button id
             * @property {kritor.common.IButtonRender|null} [render_data] Button render_data
             * @property {kritor.common.IButtonAction|null} [action] Button action
             */

            /**
             * Constructs a new Button.
             * @memberof kritor.common
             * @classdesc Represents a Button.
             * @implements IButton
             * @constructor
             * @param {kritor.common.IButton=} [properties] Properties to set
             */
            function Button(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Button id.
             * @member {string} id
             * @memberof kritor.common.Button
             * @instance
             */
            Button.prototype.id = "";

            /**
             * Button render_data.
             * @member {kritor.common.IButtonRender|null|undefined} render_data
             * @memberof kritor.common.Button
             * @instance
             */
            Button.prototype.render_data = null;

            /**
             * Button action.
             * @member {kritor.common.IButtonAction|null|undefined} action
             * @memberof kritor.common.Button
             * @instance
             */
            Button.prototype.action = null;

            /**
             * Creates a new Button instance using the specified properties.
             * @function create
             * @memberof kritor.common.Button
             * @static
             * @param {kritor.common.IButton=} [properties] Properties to set
             * @returns {kritor.common.Button} Button instance
             */
            Button.create = function create(properties) {
                return new Button(properties);
            };

            /**
             * Encodes the specified Button message. Does not implicitly {@link kritor.common.Button.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.Button
             * @static
             * @param {kritor.common.IButton} message Button message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Button.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.render_data != null && Object.hasOwnProperty.call(message, "render_data"))
                    $root.kritor.common.ButtonRender.encode(message.render_data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    $root.kritor.common.ButtonAction.encode(message.action, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Button message, length delimited. Does not implicitly {@link kritor.common.Button.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.Button
             * @static
             * @param {kritor.common.IButton} message Button message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Button.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Button message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.Button
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.Button} Button
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Button.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.Button();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    case 2: {
                            message.render_data = $root.kritor.common.ButtonRender.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.action = $root.kritor.common.ButtonAction.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Button message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.Button
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.Button} Button
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Button.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Button message.
             * @function verify
             * @memberof kritor.common.Button
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Button.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.render_data != null && message.hasOwnProperty("render_data")) {
                    let error = $root.kritor.common.ButtonRender.verify(message.render_data);
                    if (error)
                        return "render_data." + error;
                }
                if (message.action != null && message.hasOwnProperty("action")) {
                    let error = $root.kritor.common.ButtonAction.verify(message.action);
                    if (error)
                        return "action." + error;
                }
                return null;
            };

            /**
             * Creates a Button message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.Button
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.Button} Button
             */
            Button.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.Button)
                    return object;
                let message = new $root.kritor.common.Button();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.render_data != null) {
                    if (typeof object.render_data !== "object")
                        throw TypeError(".kritor.common.Button.render_data: object expected");
                    message.render_data = $root.kritor.common.ButtonRender.fromObject(object.render_data);
                }
                if (object.action != null) {
                    if (typeof object.action !== "object")
                        throw TypeError(".kritor.common.Button.action: object expected");
                    message.action = $root.kritor.common.ButtonAction.fromObject(object.action);
                }
                return message;
            };

            /**
             * Creates a plain object from a Button message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.Button
             * @static
             * @param {kritor.common.Button} message Button
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Button.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = "";
                    object.render_data = null;
                    object.action = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.render_data != null && message.hasOwnProperty("render_data"))
                    object.render_data = $root.kritor.common.ButtonRender.toObject(message.render_data, options);
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = $root.kritor.common.ButtonAction.toObject(message.action, options);
                return object;
            };

            /**
             * Converts this Button to JSON.
             * @function toJSON
             * @memberof kritor.common.Button
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Button.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Button
             * @function getTypeUrl
             * @memberof kritor.common.Button
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Button.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.Button";
            };

            return Button;
        })();

        common.KeyboardRow = (function() {

            /**
             * Properties of a KeyboardRow.
             * @memberof kritor.common
             * @interface IKeyboardRow
             * @property {Array.<kritor.common.IButton>|null} [buttons] KeyboardRow buttons
             */

            /**
             * Constructs a new KeyboardRow.
             * @memberof kritor.common
             * @classdesc Represents a KeyboardRow.
             * @implements IKeyboardRow
             * @constructor
             * @param {kritor.common.IKeyboardRow=} [properties] Properties to set
             */
            function KeyboardRow(properties) {
                this.buttons = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeyboardRow buttons.
             * @member {Array.<kritor.common.IButton>} buttons
             * @memberof kritor.common.KeyboardRow
             * @instance
             */
            KeyboardRow.prototype.buttons = $util.emptyArray;

            /**
             * Creates a new KeyboardRow instance using the specified properties.
             * @function create
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {kritor.common.IKeyboardRow=} [properties] Properties to set
             * @returns {kritor.common.KeyboardRow} KeyboardRow instance
             */
            KeyboardRow.create = function create(properties) {
                return new KeyboardRow(properties);
            };

            /**
             * Encodes the specified KeyboardRow message. Does not implicitly {@link kritor.common.KeyboardRow.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {kritor.common.IKeyboardRow} message KeyboardRow message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyboardRow.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.buttons != null && message.buttons.length)
                    for (let i = 0; i < message.buttons.length; ++i)
                        $root.kritor.common.Button.encode(message.buttons[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified KeyboardRow message, length delimited. Does not implicitly {@link kritor.common.KeyboardRow.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {kritor.common.IKeyboardRow} message KeyboardRow message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyboardRow.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeyboardRow message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.KeyboardRow} KeyboardRow
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyboardRow.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.KeyboardRow();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.buttons && message.buttons.length))
                                message.buttons = [];
                            message.buttons.push($root.kritor.common.Button.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeyboardRow message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.KeyboardRow} KeyboardRow
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyboardRow.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeyboardRow message.
             * @function verify
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyboardRow.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.buttons != null && message.hasOwnProperty("buttons")) {
                    if (!Array.isArray(message.buttons))
                        return "buttons: array expected";
                    for (let i = 0; i < message.buttons.length; ++i) {
                        let error = $root.kritor.common.Button.verify(message.buttons[i]);
                        if (error)
                            return "buttons." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a KeyboardRow message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.KeyboardRow} KeyboardRow
             */
            KeyboardRow.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.KeyboardRow)
                    return object;
                let message = new $root.kritor.common.KeyboardRow();
                if (object.buttons) {
                    if (!Array.isArray(object.buttons))
                        throw TypeError(".kritor.common.KeyboardRow.buttons: array expected");
                    message.buttons = [];
                    for (let i = 0; i < object.buttons.length; ++i) {
                        if (typeof object.buttons[i] !== "object")
                            throw TypeError(".kritor.common.KeyboardRow.buttons: object expected");
                        message.buttons[i] = $root.kritor.common.Button.fromObject(object.buttons[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a KeyboardRow message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {kritor.common.KeyboardRow} message KeyboardRow
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyboardRow.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.buttons = [];
                if (message.buttons && message.buttons.length) {
                    object.buttons = [];
                    for (let j = 0; j < message.buttons.length; ++j)
                        object.buttons[j] = $root.kritor.common.Button.toObject(message.buttons[j], options);
                }
                return object;
            };

            /**
             * Converts this KeyboardRow to JSON.
             * @function toJSON
             * @memberof kritor.common.KeyboardRow
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyboardRow.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KeyboardRow
             * @function getTypeUrl
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KeyboardRow.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.KeyboardRow";
            };

            return KeyboardRow;
        })();

        common.KeyboardElement = (function() {

            /**
             * Properties of a KeyboardElement.
             * @memberof kritor.common
             * @interface IKeyboardElement
             * @property {Array.<kritor.common.IKeyboardRow>|null} [rows] KeyboardElement rows
             * @property {number|Long|null} [bot_appid] KeyboardElement bot_appid
             */

            /**
             * Constructs a new KeyboardElement.
             * @memberof kritor.common
             * @classdesc Represents a KeyboardElement.
             * @implements IKeyboardElement
             * @constructor
             * @param {kritor.common.IKeyboardElement=} [properties] Properties to set
             */
            function KeyboardElement(properties) {
                this.rows = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeyboardElement rows.
             * @member {Array.<kritor.common.IKeyboardRow>} rows
             * @memberof kritor.common.KeyboardElement
             * @instance
             */
            KeyboardElement.prototype.rows = $util.emptyArray;

            /**
             * KeyboardElement bot_appid.
             * @member {number|Long} bot_appid
             * @memberof kritor.common.KeyboardElement
             * @instance
             */
            KeyboardElement.prototype.bot_appid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new KeyboardElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {kritor.common.IKeyboardElement=} [properties] Properties to set
             * @returns {kritor.common.KeyboardElement} KeyboardElement instance
             */
            KeyboardElement.create = function create(properties) {
                return new KeyboardElement(properties);
            };

            /**
             * Encodes the specified KeyboardElement message. Does not implicitly {@link kritor.common.KeyboardElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {kritor.common.IKeyboardElement} message KeyboardElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyboardElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rows != null && message.rows.length)
                    for (let i = 0; i < message.rows.length; ++i)
                        $root.kritor.common.KeyboardRow.encode(message.rows[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.bot_appid != null && Object.hasOwnProperty.call(message, "bot_appid"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.bot_appid);
                return writer;
            };

            /**
             * Encodes the specified KeyboardElement message, length delimited. Does not implicitly {@link kritor.common.KeyboardElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {kritor.common.IKeyboardElement} message KeyboardElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyboardElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeyboardElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.KeyboardElement} KeyboardElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyboardElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.KeyboardElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.rows && message.rows.length))
                                message.rows = [];
                            message.rows.push($root.kritor.common.KeyboardRow.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            message.bot_appid = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeyboardElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.KeyboardElement} KeyboardElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyboardElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeyboardElement message.
             * @function verify
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyboardElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rows != null && message.hasOwnProperty("rows")) {
                    if (!Array.isArray(message.rows))
                        return "rows: array expected";
                    for (let i = 0; i < message.rows.length; ++i) {
                        let error = $root.kritor.common.KeyboardRow.verify(message.rows[i]);
                        if (error)
                            return "rows." + error;
                    }
                }
                if (message.bot_appid != null && message.hasOwnProperty("bot_appid"))
                    if (!$util.isInteger(message.bot_appid) && !(message.bot_appid && $util.isInteger(message.bot_appid.low) && $util.isInteger(message.bot_appid.high)))
                        return "bot_appid: integer|Long expected";
                return null;
            };

            /**
             * Creates a KeyboardElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.KeyboardElement} KeyboardElement
             */
            KeyboardElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.KeyboardElement)
                    return object;
                let message = new $root.kritor.common.KeyboardElement();
                if (object.rows) {
                    if (!Array.isArray(object.rows))
                        throw TypeError(".kritor.common.KeyboardElement.rows: array expected");
                    message.rows = [];
                    for (let i = 0; i < object.rows.length; ++i) {
                        if (typeof object.rows[i] !== "object")
                            throw TypeError(".kritor.common.KeyboardElement.rows: object expected");
                        message.rows[i] = $root.kritor.common.KeyboardRow.fromObject(object.rows[i]);
                    }
                }
                if (object.bot_appid != null)
                    if ($util.Long)
                        (message.bot_appid = $util.Long.fromValue(object.bot_appid)).unsigned = true;
                    else if (typeof object.bot_appid === "string")
                        message.bot_appid = parseInt(object.bot_appid, 10);
                    else if (typeof object.bot_appid === "number")
                        message.bot_appid = object.bot_appid;
                    else if (typeof object.bot_appid === "object")
                        message.bot_appid = new $util.LongBits(object.bot_appid.low >>> 0, object.bot_appid.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a KeyboardElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {kritor.common.KeyboardElement} message KeyboardElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyboardElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.rows = [];
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.bot_appid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.bot_appid = options.longs === String ? "0" : 0;
                if (message.rows && message.rows.length) {
                    object.rows = [];
                    for (let j = 0; j < message.rows.length; ++j)
                        object.rows[j] = $root.kritor.common.KeyboardRow.toObject(message.rows[j], options);
                }
                if (message.bot_appid != null && message.hasOwnProperty("bot_appid"))
                    if (typeof message.bot_appid === "number")
                        object.bot_appid = options.longs === String ? String(message.bot_appid) : message.bot_appid;
                    else
                        object.bot_appid = options.longs === String ? $util.Long.prototype.toString.call(message.bot_appid) : options.longs === Number ? new $util.LongBits(message.bot_appid.low >>> 0, message.bot_appid.high >>> 0).toNumber(true) : message.bot_appid;
                return object;
            };

            /**
             * Converts this KeyboardElement to JSON.
             * @function toJSON
             * @memberof kritor.common.KeyboardElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyboardElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KeyboardElement
             * @function getTypeUrl
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KeyboardElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.KeyboardElement";
            };

            return KeyboardElement;
        })();

        common.Request = (function() {

            /**
             * Properties of a Request.
             * @memberof kritor.common
             * @interface IRequest
             * @property {string|null} [cmd] Request cmd
             * @property {number|null} [seq] Request seq
             * @property {Uint8Array|null} [buf] Request buf
             * @property {boolean|null} [no_response] Request no_response
             */

            /**
             * Constructs a new Request.
             * @memberof kritor.common
             * @classdesc Represents a Request.
             * @implements IRequest
             * @constructor
             * @param {kritor.common.IRequest=} [properties] Properties to set
             */
            function Request(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Request cmd.
             * @member {string} cmd
             * @memberof kritor.common.Request
             * @instance
             */
            Request.prototype.cmd = "";

            /**
             * Request seq.
             * @member {number} seq
             * @memberof kritor.common.Request
             * @instance
             */
            Request.prototype.seq = 0;

            /**
             * Request buf.
             * @member {Uint8Array} buf
             * @memberof kritor.common.Request
             * @instance
             */
            Request.prototype.buf = $util.newBuffer([]);

            /**
             * Request no_response.
             * @member {boolean} no_response
             * @memberof kritor.common.Request
             * @instance
             */
            Request.prototype.no_response = false;

            /**
             * Creates a new Request instance using the specified properties.
             * @function create
             * @memberof kritor.common.Request
             * @static
             * @param {kritor.common.IRequest=} [properties] Properties to set
             * @returns {kritor.common.Request} Request instance
             */
            Request.create = function create(properties) {
                return new Request(properties);
            };

            /**
             * Encodes the specified Request message. Does not implicitly {@link kritor.common.Request.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.Request
             * @static
             * @param {kritor.common.IRequest} message Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Request.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cmd != null && Object.hasOwnProperty.call(message, "cmd"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmd);
                if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.seq);
                if (message.buf != null && Object.hasOwnProperty.call(message, "buf"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.buf);
                if (message.no_response != null && Object.hasOwnProperty.call(message, "no_response"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.no_response);
                return writer;
            };

            /**
             * Encodes the specified Request message, length delimited. Does not implicitly {@link kritor.common.Request.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.Request
             * @static
             * @param {kritor.common.IRequest} message Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Request.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Request message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.Request} Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Request.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.Request();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cmd = reader.string();
                            break;
                        }
                    case 2: {
                            message.seq = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.buf = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.no_response = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Request message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.Request} Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Request.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Request message.
             * @function verify
             * @memberof kritor.common.Request
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Request.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cmd != null && message.hasOwnProperty("cmd"))
                    if (!$util.isString(message.cmd))
                        return "cmd: string expected";
                if (message.seq != null && message.hasOwnProperty("seq"))
                    if (!$util.isInteger(message.seq))
                        return "seq: integer expected";
                if (message.buf != null && message.hasOwnProperty("buf"))
                    if (!(message.buf && typeof message.buf.length === "number" || $util.isString(message.buf)))
                        return "buf: buffer expected";
                if (message.no_response != null && message.hasOwnProperty("no_response"))
                    if (typeof message.no_response !== "boolean")
                        return "no_response: boolean expected";
                return null;
            };

            /**
             * Creates a Request message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.Request
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.Request} Request
             */
            Request.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.Request)
                    return object;
                let message = new $root.kritor.common.Request();
                if (object.cmd != null)
                    message.cmd = String(object.cmd);
                if (object.seq != null)
                    message.seq = object.seq >>> 0;
                if (object.buf != null)
                    if (typeof object.buf === "string")
                        $util.base64.decode(object.buf, message.buf = $util.newBuffer($util.base64.length(object.buf)), 0);
                    else if (object.buf.length >= 0)
                        message.buf = object.buf;
                if (object.no_response != null)
                    message.no_response = Boolean(object.no_response);
                return message;
            };

            /**
             * Creates a plain object from a Request message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.Request
             * @static
             * @param {kritor.common.Request} message Request
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Request.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.cmd = "";
                    object.seq = 0;
                    if (options.bytes === String)
                        object.buf = "";
                    else {
                        object.buf = [];
                        if (options.bytes !== Array)
                            object.buf = $util.newBuffer(object.buf);
                    }
                    object.no_response = false;
                }
                if (message.cmd != null && message.hasOwnProperty("cmd"))
                    object.cmd = message.cmd;
                if (message.seq != null && message.hasOwnProperty("seq"))
                    object.seq = message.seq;
                if (message.buf != null && message.hasOwnProperty("buf"))
                    object.buf = options.bytes === String ? $util.base64.encode(message.buf, 0, message.buf.length) : options.bytes === Array ? Array.prototype.slice.call(message.buf) : message.buf;
                if (message.no_response != null && message.hasOwnProperty("no_response"))
                    object.no_response = message.no_response;
                return object;
            };

            /**
             * Converts this Request to JSON.
             * @function toJSON
             * @memberof kritor.common.Request
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Request.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Request
             * @function getTypeUrl
             * @memberof kritor.common.Request
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Request.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.Request";
            };

            return Request;
        })();

        common.Response = (function() {

            /**
             * Properties of a Response.
             * @memberof kritor.common
             * @interface IResponse
             * @property {string|null} [cmd] Response cmd
             * @property {number|null} [seq] Response seq
             * @property {kritor.common.Response.ResponseCode|null} [code] Response code
             * @property {string|null} [msg] Response msg
             * @property {Uint8Array|null} [buf] Response buf
             */

            /**
             * Constructs a new Response.
             * @memberof kritor.common
             * @classdesc Represents a Response.
             * @implements IResponse
             * @constructor
             * @param {kritor.common.IResponse=} [properties] Properties to set
             */
            function Response(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Response cmd.
             * @member {string} cmd
             * @memberof kritor.common.Response
             * @instance
             */
            Response.prototype.cmd = "";

            /**
             * Response seq.
             * @member {number} seq
             * @memberof kritor.common.Response
             * @instance
             */
            Response.prototype.seq = 0;

            /**
             * Response code.
             * @member {kritor.common.Response.ResponseCode} code
             * @memberof kritor.common.Response
             * @instance
             */
            Response.prototype.code = 0;

            /**
             * Response msg.
             * @member {string|null|undefined} msg
             * @memberof kritor.common.Response
             * @instance
             */
            Response.prototype.msg = null;

            /**
             * Response buf.
             * @member {Uint8Array} buf
             * @memberof kritor.common.Response
             * @instance
             */
            Response.prototype.buf = $util.newBuffer([]);

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Response _msg.
             * @member {"msg"|undefined} _msg
             * @memberof kritor.common.Response
             * @instance
             */
            Object.defineProperty(Response.prototype, "_msg", {
                get: $util.oneOfGetter($oneOfFields = ["msg"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Response instance using the specified properties.
             * @function create
             * @memberof kritor.common.Response
             * @static
             * @param {kritor.common.IResponse=} [properties] Properties to set
             * @returns {kritor.common.Response} Response instance
             */
            Response.create = function create(properties) {
                return new Response(properties);
            };

            /**
             * Encodes the specified Response message. Does not implicitly {@link kritor.common.Response.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.Response
             * @static
             * @param {kritor.common.IResponse} message Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Response.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cmd != null && Object.hasOwnProperty.call(message, "cmd"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmd);
                if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.seq);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.msg);
                if (message.buf != null && Object.hasOwnProperty.call(message, "buf"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.buf);
                return writer;
            };

            /**
             * Encodes the specified Response message, length delimited. Does not implicitly {@link kritor.common.Response.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.Response
             * @static
             * @param {kritor.common.IResponse} message Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Response.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Response message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.Response} Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Response.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.Response();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cmd = reader.string();
                            break;
                        }
                    case 2: {
                            message.seq = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.code = reader.int32();
                            break;
                        }
                    case 4: {
                            message.msg = reader.string();
                            break;
                        }
                    case 5: {
                            message.buf = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Response message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.Response} Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Response.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Response message.
             * @function verify
             * @memberof kritor.common.Response
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Response.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.cmd != null && message.hasOwnProperty("cmd"))
                    if (!$util.isString(message.cmd))
                        return "cmd: string expected";
                if (message.seq != null && message.hasOwnProperty("seq"))
                    if (!$util.isInteger(message.seq))
                        return "seq: integer expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.msg != null && message.hasOwnProperty("msg")) {
                    properties._msg = 1;
                    if (!$util.isString(message.msg))
                        return "msg: string expected";
                }
                if (message.buf != null && message.hasOwnProperty("buf"))
                    if (!(message.buf && typeof message.buf.length === "number" || $util.isString(message.buf)))
                        return "buf: buffer expected";
                return null;
            };

            /**
             * Creates a Response message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.Response
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.Response} Response
             */
            Response.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.Response)
                    return object;
                let message = new $root.kritor.common.Response();
                if (object.cmd != null)
                    message.cmd = String(object.cmd);
                if (object.seq != null)
                    message.seq = object.seq >>> 0;
                switch (object.code) {
                default:
                    if (typeof object.code === "number") {
                        message.code = object.code;
                        break;
                    }
                    break;
                case "SUCCESS":
                case 0:
                    message.code = 0;
                    break;
                case "INVALID_ARGUMENT":
                case 1:
                    message.code = 1;
                    break;
                case "INTERNAL":
                case 2:
                    message.code = 2;
                    break;
                case "UNAUTHENTICATED":
                case 3:
                    message.code = 3;
                    break;
                case "PERMISSION_DENIED":
                case 4:
                    message.code = 4;
                    break;
                }
                if (object.msg != null)
                    message.msg = String(object.msg);
                if (object.buf != null)
                    if (typeof object.buf === "string")
                        $util.base64.decode(object.buf, message.buf = $util.newBuffer($util.base64.length(object.buf)), 0);
                    else if (object.buf.length >= 0)
                        message.buf = object.buf;
                return message;
            };

            /**
             * Creates a plain object from a Response message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.Response
             * @static
             * @param {kritor.common.Response} message Response
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Response.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.cmd = "";
                    object.seq = 0;
                    object.code = options.enums === String ? "SUCCESS" : 0;
                    if (options.bytes === String)
                        object.buf = "";
                    else {
                        object.buf = [];
                        if (options.bytes !== Array)
                            object.buf = $util.newBuffer(object.buf);
                    }
                }
                if (message.cmd != null && message.hasOwnProperty("cmd"))
                    object.cmd = message.cmd;
                if (message.seq != null && message.hasOwnProperty("seq"))
                    object.seq = message.seq;
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.kritor.common.Response.ResponseCode[message.code] === undefined ? message.code : $root.kritor.common.Response.ResponseCode[message.code] : message.code;
                if (message.msg != null && message.hasOwnProperty("msg")) {
                    object.msg = message.msg;
                    if (options.oneofs)
                        object._msg = "msg";
                }
                if (message.buf != null && message.hasOwnProperty("buf"))
                    object.buf = options.bytes === String ? $util.base64.encode(message.buf, 0, message.buf.length) : options.bytes === Array ? Array.prototype.slice.call(message.buf) : message.buf;
                return object;
            };

            /**
             * Converts this Response to JSON.
             * @function toJSON
             * @memberof kritor.common.Response
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Response.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Response
             * @function getTypeUrl
             * @memberof kritor.common.Response
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Response.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.Response";
            };

            /**
             * ResponseCode enum.
             * @name kritor.common.Response.ResponseCode
             * @enum {number}
             * @property {number} SUCCESS=0 SUCCESS value
             * @property {number} INVALID_ARGUMENT=1 INVALID_ARGUMENT value
             * @property {number} INTERNAL=2 INTERNAL value
             * @property {number} UNAUTHENTICATED=3 UNAUTHENTICATED value
             * @property {number} PERMISSION_DENIED=4 PERMISSION_DENIED value
             */
            Response.ResponseCode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SUCCESS"] = 0;
                values[valuesById[1] = "INVALID_ARGUMENT"] = 1;
                values[valuesById[2] = "INTERNAL"] = 2;
                values[valuesById[3] = "UNAUTHENTICATED"] = 3;
                values[valuesById[4] = "PERMISSION_DENIED"] = 4;
                return values;
            })();

            return Response;
        })();

        return common;
    })();

    kritor.core = (function() {

        /**
         * Namespace core.
         * @memberof kritor
         * @namespace
         */
        const core = {};

        core.CoreService = (function() {

            /**
             * Constructs a new CoreService service.
             * @memberof kritor.core
             * @classdesc Represents a CoreService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function CoreService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (CoreService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = CoreService;

            /**
             * Creates new CoreService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.core.CoreService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {CoreService} RPC service. Useful where requests and/or responses are streamed.
             */
            CoreService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.core.CoreService#getVersion}.
             * @memberof kritor.core.CoreService
             * @typedef GetVersionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.core.GetVersionResponse} [response] GetVersionResponse
             */

            /**
             * Calls GetVersion.
             * @function getVersion
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.IGetVersionRequest} request GetVersionRequest message or plain object
             * @param {kritor.core.CoreService.GetVersionCallback} callback Node-style callback called with the error, if any, and GetVersionResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(CoreService.prototype.getVersion = function getVersion(request, callback) {
                return this.rpcCall(getVersion, $root.kritor.core.GetVersionRequest, $root.kritor.core.GetVersionResponse, request, callback);
            }, "name", { value: "GetVersion" });

            /**
             * Calls GetVersion.
             * @function getVersion
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.IGetVersionRequest} request GetVersionRequest message or plain object
             * @returns {Promise<kritor.core.GetVersionResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.core.CoreService#downloadFile}.
             * @memberof kritor.core.CoreService
             * @typedef DownloadFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.core.DownloadFileResponse} [response] DownloadFileResponse
             */

            /**
             * Calls DownloadFile.
             * @function downloadFile
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.IDownloadFileRequest} request DownloadFileRequest message or plain object
             * @param {kritor.core.CoreService.DownloadFileCallback} callback Node-style callback called with the error, if any, and DownloadFileResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(CoreService.prototype.downloadFile = function downloadFile(request, callback) {
                return this.rpcCall(downloadFile, $root.kritor.core.DownloadFileRequest, $root.kritor.core.DownloadFileResponse, request, callback);
            }, "name", { value: "DownloadFile" });

            /**
             * Calls DownloadFile.
             * @function downloadFile
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.IDownloadFileRequest} request DownloadFileRequest message or plain object
             * @returns {Promise<kritor.core.DownloadFileResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.core.CoreService#getCurrentAccount}.
             * @memberof kritor.core.CoreService
             * @typedef GetCurrentAccountCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.core.GetCurrentAccountResponse} [response] GetCurrentAccountResponse
             */

            /**
             * Calls GetCurrentAccount.
             * @function getCurrentAccount
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.IGetCurrentAccountRequest} request GetCurrentAccountRequest message or plain object
             * @param {kritor.core.CoreService.GetCurrentAccountCallback} callback Node-style callback called with the error, if any, and GetCurrentAccountResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(CoreService.prototype.getCurrentAccount = function getCurrentAccount(request, callback) {
                return this.rpcCall(getCurrentAccount, $root.kritor.core.GetCurrentAccountRequest, $root.kritor.core.GetCurrentAccountResponse, request, callback);
            }, "name", { value: "GetCurrentAccount" });

            /**
             * Calls GetCurrentAccount.
             * @function getCurrentAccount
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.IGetCurrentAccountRequest} request GetCurrentAccountRequest message or plain object
             * @returns {Promise<kritor.core.GetCurrentAccountResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.core.CoreService#switchAccount}.
             * @memberof kritor.core.CoreService
             * @typedef SwitchAccountCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.core.SwitchAccountResponse} [response] SwitchAccountResponse
             */

            /**
             * Calls SwitchAccount.
             * @function switchAccount
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.ISwitchAccountRequest} request SwitchAccountRequest message or plain object
             * @param {kritor.core.CoreService.SwitchAccountCallback} callback Node-style callback called with the error, if any, and SwitchAccountResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(CoreService.prototype.switchAccount = function switchAccount(request, callback) {
                return this.rpcCall(switchAccount, $root.kritor.core.SwitchAccountRequest, $root.kritor.core.SwitchAccountResponse, request, callback);
            }, "name", { value: "SwitchAccount" });

            /**
             * Calls SwitchAccount.
             * @function switchAccount
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.ISwitchAccountRequest} request SwitchAccountRequest message or plain object
             * @returns {Promise<kritor.core.SwitchAccountResponse>} Promise
             * @variation 2
             */

            return CoreService;
        })();

        core.GetVersionRequest = (function() {

            /**
             * Properties of a GetVersionRequest.
             * @memberof kritor.core
             * @interface IGetVersionRequest
             */

            /**
             * Constructs a new GetVersionRequest.
             * @memberof kritor.core
             * @classdesc Represents a GetVersionRequest.
             * @implements IGetVersionRequest
             * @constructor
             * @param {kritor.core.IGetVersionRequest=} [properties] Properties to set
             */
            function GetVersionRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetVersionRequest instance using the specified properties.
             * @function create
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {kritor.core.IGetVersionRequest=} [properties] Properties to set
             * @returns {kritor.core.GetVersionRequest} GetVersionRequest instance
             */
            GetVersionRequest.create = function create(properties) {
                return new GetVersionRequest(properties);
            };

            /**
             * Encodes the specified GetVersionRequest message. Does not implicitly {@link kritor.core.GetVersionRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {kritor.core.IGetVersionRequest} message GetVersionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetVersionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetVersionRequest message, length delimited. Does not implicitly {@link kritor.core.GetVersionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {kritor.core.IGetVersionRequest} message GetVersionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetVersionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetVersionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.GetVersionRequest} GetVersionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetVersionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.GetVersionRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetVersionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.GetVersionRequest} GetVersionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetVersionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetVersionRequest message.
             * @function verify
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetVersionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetVersionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.GetVersionRequest} GetVersionRequest
             */
            GetVersionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.GetVersionRequest)
                    return object;
                return new $root.kritor.core.GetVersionRequest();
            };

            /**
             * Creates a plain object from a GetVersionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {kritor.core.GetVersionRequest} message GetVersionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetVersionRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetVersionRequest to JSON.
             * @function toJSON
             * @memberof kritor.core.GetVersionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetVersionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetVersionRequest
             * @function getTypeUrl
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetVersionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.GetVersionRequest";
            };

            return GetVersionRequest;
        })();

        core.GetVersionResponse = (function() {

            /**
             * Properties of a GetVersionResponse.
             * @memberof kritor.core
             * @interface IGetVersionResponse
             * @property {string|null} [version] GetVersionResponse version
             * @property {string|null} [app_name] GetVersionResponse app_name
             */

            /**
             * Constructs a new GetVersionResponse.
             * @memberof kritor.core
             * @classdesc Represents a GetVersionResponse.
             * @implements IGetVersionResponse
             * @constructor
             * @param {kritor.core.IGetVersionResponse=} [properties] Properties to set
             */
            function GetVersionResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetVersionResponse version.
             * @member {string} version
             * @memberof kritor.core.GetVersionResponse
             * @instance
             */
            GetVersionResponse.prototype.version = "";

            /**
             * GetVersionResponse app_name.
             * @member {string} app_name
             * @memberof kritor.core.GetVersionResponse
             * @instance
             */
            GetVersionResponse.prototype.app_name = "";

            /**
             * Creates a new GetVersionResponse instance using the specified properties.
             * @function create
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {kritor.core.IGetVersionResponse=} [properties] Properties to set
             * @returns {kritor.core.GetVersionResponse} GetVersionResponse instance
             */
            GetVersionResponse.create = function create(properties) {
                return new GetVersionResponse(properties);
            };

            /**
             * Encodes the specified GetVersionResponse message. Does not implicitly {@link kritor.core.GetVersionResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {kritor.core.IGetVersionResponse} message GetVersionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetVersionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
                if (message.app_name != null && Object.hasOwnProperty.call(message, "app_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.app_name);
                return writer;
            };

            /**
             * Encodes the specified GetVersionResponse message, length delimited. Does not implicitly {@link kritor.core.GetVersionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {kritor.core.IGetVersionResponse} message GetVersionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetVersionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetVersionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.GetVersionResponse} GetVersionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetVersionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.GetVersionResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.version = reader.string();
                            break;
                        }
                    case 2: {
                            message.app_name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetVersionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.GetVersionResponse} GetVersionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetVersionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetVersionResponse message.
             * @function verify
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetVersionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.app_name != null && message.hasOwnProperty("app_name"))
                    if (!$util.isString(message.app_name))
                        return "app_name: string expected";
                return null;
            };

            /**
             * Creates a GetVersionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.GetVersionResponse} GetVersionResponse
             */
            GetVersionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.GetVersionResponse)
                    return object;
                let message = new $root.kritor.core.GetVersionResponse();
                if (object.version != null)
                    message.version = String(object.version);
                if (object.app_name != null)
                    message.app_name = String(object.app_name);
                return message;
            };

            /**
             * Creates a plain object from a GetVersionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {kritor.core.GetVersionResponse} message GetVersionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetVersionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.version = "";
                    object.app_name = "";
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.app_name != null && message.hasOwnProperty("app_name"))
                    object.app_name = message.app_name;
                return object;
            };

            /**
             * Converts this GetVersionResponse to JSON.
             * @function toJSON
             * @memberof kritor.core.GetVersionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetVersionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetVersionResponse
             * @function getTypeUrl
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetVersionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.GetVersionResponse";
            };

            return GetVersionResponse;
        })();

        core.DownloadFileRequest = (function() {

            /**
             * Properties of a DownloadFileRequest.
             * @memberof kritor.core
             * @interface IDownloadFileRequest
             * @property {string|null} [url] DownloadFileRequest url
             * @property {string|null} [base64] DownloadFileRequest base64
             * @property {string|null} [root_path] DownloadFileRequest root_path
             * @property {string|null} [file_name] DownloadFileRequest file_name
             * @property {number|null} [thread_cnt] DownloadFileRequest thread_cnt
             * @property {string|null} [headers] DownloadFileRequest headers
             */

            /**
             * Constructs a new DownloadFileRequest.
             * @memberof kritor.core
             * @classdesc Represents a DownloadFileRequest.
             * @implements IDownloadFileRequest
             * @constructor
             * @param {kritor.core.IDownloadFileRequest=} [properties] Properties to set
             */
            function DownloadFileRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DownloadFileRequest url.
             * @member {string|null|undefined} url
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.url = null;

            /**
             * DownloadFileRequest base64.
             * @member {string|null|undefined} base64
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.base64 = null;

            /**
             * DownloadFileRequest root_path.
             * @member {string|null|undefined} root_path
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.root_path = null;

            /**
             * DownloadFileRequest file_name.
             * @member {string|null|undefined} file_name
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.file_name = null;

            /**
             * DownloadFileRequest thread_cnt.
             * @member {number|null|undefined} thread_cnt
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.thread_cnt = null;

            /**
             * DownloadFileRequest headers.
             * @member {string|null|undefined} headers
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.headers = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * DownloadFileRequest _url.
             * @member {"url"|undefined} _url
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_url", {
                get: $util.oneOfGetter($oneOfFields = ["url"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * DownloadFileRequest _base64.
             * @member {"base64"|undefined} _base64
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_base64", {
                get: $util.oneOfGetter($oneOfFields = ["base64"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * DownloadFileRequest _root_path.
             * @member {"root_path"|undefined} _root_path
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_root_path", {
                get: $util.oneOfGetter($oneOfFields = ["root_path"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * DownloadFileRequest _file_name.
             * @member {"file_name"|undefined} _file_name
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_file_name", {
                get: $util.oneOfGetter($oneOfFields = ["file_name"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * DownloadFileRequest _thread_cnt.
             * @member {"thread_cnt"|undefined} _thread_cnt
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_thread_cnt", {
                get: $util.oneOfGetter($oneOfFields = ["thread_cnt"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * DownloadFileRequest _headers.
             * @member {"headers"|undefined} _headers
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_headers", {
                get: $util.oneOfGetter($oneOfFields = ["headers"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new DownloadFileRequest instance using the specified properties.
             * @function create
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {kritor.core.IDownloadFileRequest=} [properties] Properties to set
             * @returns {kritor.core.DownloadFileRequest} DownloadFileRequest instance
             */
            DownloadFileRequest.create = function create(properties) {
                return new DownloadFileRequest(properties);
            };

            /**
             * Encodes the specified DownloadFileRequest message. Does not implicitly {@link kritor.core.DownloadFileRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {kritor.core.IDownloadFileRequest} message DownloadFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadFileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.base64 != null && Object.hasOwnProperty.call(message, "base64"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.base64);
                if (message.root_path != null && Object.hasOwnProperty.call(message, "root_path"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.root_path);
                if (message.file_name != null && Object.hasOwnProperty.call(message, "file_name"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.file_name);
                if (message.thread_cnt != null && Object.hasOwnProperty.call(message, "thread_cnt"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.thread_cnt);
                if (message.headers != null && Object.hasOwnProperty.call(message, "headers"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.headers);
                return writer;
            };

            /**
             * Encodes the specified DownloadFileRequest message, length delimited. Does not implicitly {@link kritor.core.DownloadFileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {kritor.core.IDownloadFileRequest} message DownloadFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DownloadFileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.DownloadFileRequest} DownloadFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadFileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.DownloadFileRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    case 2: {
                            message.base64 = reader.string();
                            break;
                        }
                    case 3: {
                            message.root_path = reader.string();
                            break;
                        }
                    case 4: {
                            message.file_name = reader.string();
                            break;
                        }
                    case 5: {
                            message.thread_cnt = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.headers = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DownloadFileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.DownloadFileRequest} DownloadFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadFileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DownloadFileRequest message.
             * @function verify
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DownloadFileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.url != null && message.hasOwnProperty("url")) {
                    properties._url = 1;
                    if (!$util.isString(message.url))
                        return "url: string expected";
                }
                if (message.base64 != null && message.hasOwnProperty("base64")) {
                    properties._base64 = 1;
                    if (!$util.isString(message.base64))
                        return "base64: string expected";
                }
                if (message.root_path != null && message.hasOwnProperty("root_path")) {
                    properties._root_path = 1;
                    if (!$util.isString(message.root_path))
                        return "root_path: string expected";
                }
                if (message.file_name != null && message.hasOwnProperty("file_name")) {
                    properties._file_name = 1;
                    if (!$util.isString(message.file_name))
                        return "file_name: string expected";
                }
                if (message.thread_cnt != null && message.hasOwnProperty("thread_cnt")) {
                    properties._thread_cnt = 1;
                    if (!$util.isInteger(message.thread_cnt))
                        return "thread_cnt: integer expected";
                }
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    properties._headers = 1;
                    if (!$util.isString(message.headers))
                        return "headers: string expected";
                }
                return null;
            };

            /**
             * Creates a DownloadFileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.DownloadFileRequest} DownloadFileRequest
             */
            DownloadFileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.DownloadFileRequest)
                    return object;
                let message = new $root.kritor.core.DownloadFileRequest();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.base64 != null)
                    message.base64 = String(object.base64);
                if (object.root_path != null)
                    message.root_path = String(object.root_path);
                if (object.file_name != null)
                    message.file_name = String(object.file_name);
                if (object.thread_cnt != null)
                    message.thread_cnt = object.thread_cnt >>> 0;
                if (object.headers != null)
                    message.headers = String(object.headers);
                return message;
            };

            /**
             * Creates a plain object from a DownloadFileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {kritor.core.DownloadFileRequest} message DownloadFileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DownloadFileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.url != null && message.hasOwnProperty("url")) {
                    object.url = message.url;
                    if (options.oneofs)
                        object._url = "url";
                }
                if (message.base64 != null && message.hasOwnProperty("base64")) {
                    object.base64 = message.base64;
                    if (options.oneofs)
                        object._base64 = "base64";
                }
                if (message.root_path != null && message.hasOwnProperty("root_path")) {
                    object.root_path = message.root_path;
                    if (options.oneofs)
                        object._root_path = "root_path";
                }
                if (message.file_name != null && message.hasOwnProperty("file_name")) {
                    object.file_name = message.file_name;
                    if (options.oneofs)
                        object._file_name = "file_name";
                }
                if (message.thread_cnt != null && message.hasOwnProperty("thread_cnt")) {
                    object.thread_cnt = message.thread_cnt;
                    if (options.oneofs)
                        object._thread_cnt = "thread_cnt";
                }
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    object.headers = message.headers;
                    if (options.oneofs)
                        object._headers = "headers";
                }
                return object;
            };

            /**
             * Converts this DownloadFileRequest to JSON.
             * @function toJSON
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DownloadFileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DownloadFileRequest
             * @function getTypeUrl
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DownloadFileRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.DownloadFileRequest";
            };

            return DownloadFileRequest;
        })();

        core.DownloadFileResponse = (function() {

            /**
             * Properties of a DownloadFileResponse.
             * @memberof kritor.core
             * @interface IDownloadFileResponse
             * @property {string|null} [file_absolute_path] DownloadFileResponse file_absolute_path
             * @property {string|null} [file_md5] DownloadFileResponse file_md5
             */

            /**
             * Constructs a new DownloadFileResponse.
             * @memberof kritor.core
             * @classdesc Represents a DownloadFileResponse.
             * @implements IDownloadFileResponse
             * @constructor
             * @param {kritor.core.IDownloadFileResponse=} [properties] Properties to set
             */
            function DownloadFileResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DownloadFileResponse file_absolute_path.
             * @member {string} file_absolute_path
             * @memberof kritor.core.DownloadFileResponse
             * @instance
             */
            DownloadFileResponse.prototype.file_absolute_path = "";

            /**
             * DownloadFileResponse file_md5.
             * @member {string} file_md5
             * @memberof kritor.core.DownloadFileResponse
             * @instance
             */
            DownloadFileResponse.prototype.file_md5 = "";

            /**
             * Creates a new DownloadFileResponse instance using the specified properties.
             * @function create
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {kritor.core.IDownloadFileResponse=} [properties] Properties to set
             * @returns {kritor.core.DownloadFileResponse} DownloadFileResponse instance
             */
            DownloadFileResponse.create = function create(properties) {
                return new DownloadFileResponse(properties);
            };

            /**
             * Encodes the specified DownloadFileResponse message. Does not implicitly {@link kritor.core.DownloadFileResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {kritor.core.IDownloadFileResponse} message DownloadFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadFileResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file_absolute_path != null && Object.hasOwnProperty.call(message, "file_absolute_path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.file_absolute_path);
                if (message.file_md5 != null && Object.hasOwnProperty.call(message, "file_md5"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.file_md5);
                return writer;
            };

            /**
             * Encodes the specified DownloadFileResponse message, length delimited. Does not implicitly {@link kritor.core.DownloadFileResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {kritor.core.IDownloadFileResponse} message DownloadFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadFileResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DownloadFileResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.DownloadFileResponse} DownloadFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadFileResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.DownloadFileResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file_absolute_path = reader.string();
                            break;
                        }
                    case 2: {
                            message.file_md5 = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DownloadFileResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.DownloadFileResponse} DownloadFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadFileResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DownloadFileResponse message.
             * @function verify
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DownloadFileResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file_absolute_path != null && message.hasOwnProperty("file_absolute_path"))
                    if (!$util.isString(message.file_absolute_path))
                        return "file_absolute_path: string expected";
                if (message.file_md5 != null && message.hasOwnProperty("file_md5"))
                    if (!$util.isString(message.file_md5))
                        return "file_md5: string expected";
                return null;
            };

            /**
             * Creates a DownloadFileResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.DownloadFileResponse} DownloadFileResponse
             */
            DownloadFileResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.DownloadFileResponse)
                    return object;
                let message = new $root.kritor.core.DownloadFileResponse();
                if (object.file_absolute_path != null)
                    message.file_absolute_path = String(object.file_absolute_path);
                if (object.file_md5 != null)
                    message.file_md5 = String(object.file_md5);
                return message;
            };

            /**
             * Creates a plain object from a DownloadFileResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {kritor.core.DownloadFileResponse} message DownloadFileResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DownloadFileResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.file_absolute_path = "";
                    object.file_md5 = "";
                }
                if (message.file_absolute_path != null && message.hasOwnProperty("file_absolute_path"))
                    object.file_absolute_path = message.file_absolute_path;
                if (message.file_md5 != null && message.hasOwnProperty("file_md5"))
                    object.file_md5 = message.file_md5;
                return object;
            };

            /**
             * Converts this DownloadFileResponse to JSON.
             * @function toJSON
             * @memberof kritor.core.DownloadFileResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DownloadFileResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DownloadFileResponse
             * @function getTypeUrl
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DownloadFileResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.DownloadFileResponse";
            };

            return DownloadFileResponse;
        })();

        core.GetCurrentAccountRequest = (function() {

            /**
             * Properties of a GetCurrentAccountRequest.
             * @memberof kritor.core
             * @interface IGetCurrentAccountRequest
             */

            /**
             * Constructs a new GetCurrentAccountRequest.
             * @memberof kritor.core
             * @classdesc Represents a GetCurrentAccountRequest.
             * @implements IGetCurrentAccountRequest
             * @constructor
             * @param {kritor.core.IGetCurrentAccountRequest=} [properties] Properties to set
             */
            function GetCurrentAccountRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetCurrentAccountRequest instance using the specified properties.
             * @function create
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {kritor.core.IGetCurrentAccountRequest=} [properties] Properties to set
             * @returns {kritor.core.GetCurrentAccountRequest} GetCurrentAccountRequest instance
             */
            GetCurrentAccountRequest.create = function create(properties) {
                return new GetCurrentAccountRequest(properties);
            };

            /**
             * Encodes the specified GetCurrentAccountRequest message. Does not implicitly {@link kritor.core.GetCurrentAccountRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {kritor.core.IGetCurrentAccountRequest} message GetCurrentAccountRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCurrentAccountRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetCurrentAccountRequest message, length delimited. Does not implicitly {@link kritor.core.GetCurrentAccountRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {kritor.core.IGetCurrentAccountRequest} message GetCurrentAccountRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCurrentAccountRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCurrentAccountRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.GetCurrentAccountRequest} GetCurrentAccountRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCurrentAccountRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.GetCurrentAccountRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCurrentAccountRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.GetCurrentAccountRequest} GetCurrentAccountRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCurrentAccountRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCurrentAccountRequest message.
             * @function verify
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCurrentAccountRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetCurrentAccountRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.GetCurrentAccountRequest} GetCurrentAccountRequest
             */
            GetCurrentAccountRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.GetCurrentAccountRequest)
                    return object;
                return new $root.kritor.core.GetCurrentAccountRequest();
            };

            /**
             * Creates a plain object from a GetCurrentAccountRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {kritor.core.GetCurrentAccountRequest} message GetCurrentAccountRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCurrentAccountRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetCurrentAccountRequest to JSON.
             * @function toJSON
             * @memberof kritor.core.GetCurrentAccountRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCurrentAccountRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCurrentAccountRequest
             * @function getTypeUrl
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCurrentAccountRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.GetCurrentAccountRequest";
            };

            return GetCurrentAccountRequest;
        })();

        core.GetCurrentAccountResponse = (function() {

            /**
             * Properties of a GetCurrentAccountResponse.
             * @memberof kritor.core
             * @interface IGetCurrentAccountResponse
             * @property {string|null} [account_uid] GetCurrentAccountResponse account_uid
             * @property {number|Long|null} [account_uin] GetCurrentAccountResponse account_uin
             * @property {string|null} [account_name] GetCurrentAccountResponse account_name
             */

            /**
             * Constructs a new GetCurrentAccountResponse.
             * @memberof kritor.core
             * @classdesc Represents a GetCurrentAccountResponse.
             * @implements IGetCurrentAccountResponse
             * @constructor
             * @param {kritor.core.IGetCurrentAccountResponse=} [properties] Properties to set
             */
            function GetCurrentAccountResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCurrentAccountResponse account_uid.
             * @member {string} account_uid
             * @memberof kritor.core.GetCurrentAccountResponse
             * @instance
             */
            GetCurrentAccountResponse.prototype.account_uid = "";

            /**
             * GetCurrentAccountResponse account_uin.
             * @member {number|Long} account_uin
             * @memberof kritor.core.GetCurrentAccountResponse
             * @instance
             */
            GetCurrentAccountResponse.prototype.account_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetCurrentAccountResponse account_name.
             * @member {string} account_name
             * @memberof kritor.core.GetCurrentAccountResponse
             * @instance
             */
            GetCurrentAccountResponse.prototype.account_name = "";

            /**
             * Creates a new GetCurrentAccountResponse instance using the specified properties.
             * @function create
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {kritor.core.IGetCurrentAccountResponse=} [properties] Properties to set
             * @returns {kritor.core.GetCurrentAccountResponse} GetCurrentAccountResponse instance
             */
            GetCurrentAccountResponse.create = function create(properties) {
                return new GetCurrentAccountResponse(properties);
            };

            /**
             * Encodes the specified GetCurrentAccountResponse message. Does not implicitly {@link kritor.core.GetCurrentAccountResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {kritor.core.IGetCurrentAccountResponse} message GetCurrentAccountResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCurrentAccountResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.account_uid != null && Object.hasOwnProperty.call(message, "account_uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.account_uid);
                if (message.account_uin != null && Object.hasOwnProperty.call(message, "account_uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.account_uin);
                if (message.account_name != null && Object.hasOwnProperty.call(message, "account_name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.account_name);
                return writer;
            };

            /**
             * Encodes the specified GetCurrentAccountResponse message, length delimited. Does not implicitly {@link kritor.core.GetCurrentAccountResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {kritor.core.IGetCurrentAccountResponse} message GetCurrentAccountResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCurrentAccountResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCurrentAccountResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.GetCurrentAccountResponse} GetCurrentAccountResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCurrentAccountResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.GetCurrentAccountResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.account_uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.account_uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.account_name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCurrentAccountResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.GetCurrentAccountResponse} GetCurrentAccountResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCurrentAccountResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCurrentAccountResponse message.
             * @function verify
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCurrentAccountResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.account_uid != null && message.hasOwnProperty("account_uid"))
                    if (!$util.isString(message.account_uid))
                        return "account_uid: string expected";
                if (message.account_uin != null && message.hasOwnProperty("account_uin"))
                    if (!$util.isInteger(message.account_uin) && !(message.account_uin && $util.isInteger(message.account_uin.low) && $util.isInteger(message.account_uin.high)))
                        return "account_uin: integer|Long expected";
                if (message.account_name != null && message.hasOwnProperty("account_name"))
                    if (!$util.isString(message.account_name))
                        return "account_name: string expected";
                return null;
            };

            /**
             * Creates a GetCurrentAccountResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.GetCurrentAccountResponse} GetCurrentAccountResponse
             */
            GetCurrentAccountResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.GetCurrentAccountResponse)
                    return object;
                let message = new $root.kritor.core.GetCurrentAccountResponse();
                if (object.account_uid != null)
                    message.account_uid = String(object.account_uid);
                if (object.account_uin != null)
                    if ($util.Long)
                        (message.account_uin = $util.Long.fromValue(object.account_uin)).unsigned = true;
                    else if (typeof object.account_uin === "string")
                        message.account_uin = parseInt(object.account_uin, 10);
                    else if (typeof object.account_uin === "number")
                        message.account_uin = object.account_uin;
                    else if (typeof object.account_uin === "object")
                        message.account_uin = new $util.LongBits(object.account_uin.low >>> 0, object.account_uin.high >>> 0).toNumber(true);
                if (object.account_name != null)
                    message.account_name = String(object.account_name);
                return message;
            };

            /**
             * Creates a plain object from a GetCurrentAccountResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {kritor.core.GetCurrentAccountResponse} message GetCurrentAccountResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCurrentAccountResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.account_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.account_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.account_uin = options.longs === String ? "0" : 0;
                    object.account_name = "";
                }
                if (message.account_uid != null && message.hasOwnProperty("account_uid"))
                    object.account_uid = message.account_uid;
                if (message.account_uin != null && message.hasOwnProperty("account_uin"))
                    if (typeof message.account_uin === "number")
                        object.account_uin = options.longs === String ? String(message.account_uin) : message.account_uin;
                    else
                        object.account_uin = options.longs === String ? $util.Long.prototype.toString.call(message.account_uin) : options.longs === Number ? new $util.LongBits(message.account_uin.low >>> 0, message.account_uin.high >>> 0).toNumber(true) : message.account_uin;
                if (message.account_name != null && message.hasOwnProperty("account_name"))
                    object.account_name = message.account_name;
                return object;
            };

            /**
             * Converts this GetCurrentAccountResponse to JSON.
             * @function toJSON
             * @memberof kritor.core.GetCurrentAccountResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCurrentAccountResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCurrentAccountResponse
             * @function getTypeUrl
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCurrentAccountResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.GetCurrentAccountResponse";
            };

            return GetCurrentAccountResponse;
        })();

        core.SwitchAccountRequest = (function() {

            /**
             * Properties of a SwitchAccountRequest.
             * @memberof kritor.core
             * @interface ISwitchAccountRequest
             * @property {string|null} [account_uid] SwitchAccountRequest account_uid
             * @property {number|Long|null} [account_uin] SwitchAccountRequest account_uin
             * @property {string|null} [super_ticket] SwitchAccountRequest super_ticket
             */

            /**
             * Constructs a new SwitchAccountRequest.
             * @memberof kritor.core
             * @classdesc Represents a SwitchAccountRequest.
             * @implements ISwitchAccountRequest
             * @constructor
             * @param {kritor.core.ISwitchAccountRequest=} [properties] Properties to set
             */
            function SwitchAccountRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SwitchAccountRequest account_uid.
             * @member {string|null|undefined} account_uid
             * @memberof kritor.core.SwitchAccountRequest
             * @instance
             */
            SwitchAccountRequest.prototype.account_uid = null;

            /**
             * SwitchAccountRequest account_uin.
             * @member {number|Long|null|undefined} account_uin
             * @memberof kritor.core.SwitchAccountRequest
             * @instance
             */
            SwitchAccountRequest.prototype.account_uin = null;

            /**
             * SwitchAccountRequest super_ticket.
             * @member {string} super_ticket
             * @memberof kritor.core.SwitchAccountRequest
             * @instance
             */
            SwitchAccountRequest.prototype.super_ticket = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SwitchAccountRequest account.
             * @member {"account_uid"|"account_uin"|undefined} account
             * @memberof kritor.core.SwitchAccountRequest
             * @instance
             */
            Object.defineProperty(SwitchAccountRequest.prototype, "account", {
                get: $util.oneOfGetter($oneOfFields = ["account_uid", "account_uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SwitchAccountRequest instance using the specified properties.
             * @function create
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {kritor.core.ISwitchAccountRequest=} [properties] Properties to set
             * @returns {kritor.core.SwitchAccountRequest} SwitchAccountRequest instance
             */
            SwitchAccountRequest.create = function create(properties) {
                return new SwitchAccountRequest(properties);
            };

            /**
             * Encodes the specified SwitchAccountRequest message. Does not implicitly {@link kritor.core.SwitchAccountRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {kritor.core.ISwitchAccountRequest} message SwitchAccountRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchAccountRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.account_uid != null && Object.hasOwnProperty.call(message, "account_uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.account_uid);
                if (message.account_uin != null && Object.hasOwnProperty.call(message, "account_uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.account_uin);
                if (message.super_ticket != null && Object.hasOwnProperty.call(message, "super_ticket"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.super_ticket);
                return writer;
            };

            /**
             * Encodes the specified SwitchAccountRequest message, length delimited. Does not implicitly {@link kritor.core.SwitchAccountRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {kritor.core.ISwitchAccountRequest} message SwitchAccountRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchAccountRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SwitchAccountRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.SwitchAccountRequest} SwitchAccountRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchAccountRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.SwitchAccountRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.account_uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.account_uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.super_ticket = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SwitchAccountRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.SwitchAccountRequest} SwitchAccountRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchAccountRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SwitchAccountRequest message.
             * @function verify
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SwitchAccountRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.account_uid != null && message.hasOwnProperty("account_uid")) {
                    properties.account = 1;
                    if (!$util.isString(message.account_uid))
                        return "account_uid: string expected";
                }
                if (message.account_uin != null && message.hasOwnProperty("account_uin")) {
                    if (properties.account === 1)
                        return "account: multiple values";
                    properties.account = 1;
                    if (!$util.isInteger(message.account_uin) && !(message.account_uin && $util.isInteger(message.account_uin.low) && $util.isInteger(message.account_uin.high)))
                        return "account_uin: integer|Long expected";
                }
                if (message.super_ticket != null && message.hasOwnProperty("super_ticket"))
                    if (!$util.isString(message.super_ticket))
                        return "super_ticket: string expected";
                return null;
            };

            /**
             * Creates a SwitchAccountRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.SwitchAccountRequest} SwitchAccountRequest
             */
            SwitchAccountRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.SwitchAccountRequest)
                    return object;
                let message = new $root.kritor.core.SwitchAccountRequest();
                if (object.account_uid != null)
                    message.account_uid = String(object.account_uid);
                if (object.account_uin != null)
                    if ($util.Long)
                        (message.account_uin = $util.Long.fromValue(object.account_uin)).unsigned = true;
                    else if (typeof object.account_uin === "string")
                        message.account_uin = parseInt(object.account_uin, 10);
                    else if (typeof object.account_uin === "number")
                        message.account_uin = object.account_uin;
                    else if (typeof object.account_uin === "object")
                        message.account_uin = new $util.LongBits(object.account_uin.low >>> 0, object.account_uin.high >>> 0).toNumber(true);
                if (object.super_ticket != null)
                    message.super_ticket = String(object.super_ticket);
                return message;
            };

            /**
             * Creates a plain object from a SwitchAccountRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {kritor.core.SwitchAccountRequest} message SwitchAccountRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SwitchAccountRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.super_ticket = "";
                if (message.account_uid != null && message.hasOwnProperty("account_uid")) {
                    object.account_uid = message.account_uid;
                    if (options.oneofs)
                        object.account = "account_uid";
                }
                if (message.account_uin != null && message.hasOwnProperty("account_uin")) {
                    if (typeof message.account_uin === "number")
                        object.account_uin = options.longs === String ? String(message.account_uin) : message.account_uin;
                    else
                        object.account_uin = options.longs === String ? $util.Long.prototype.toString.call(message.account_uin) : options.longs === Number ? new $util.LongBits(message.account_uin.low >>> 0, message.account_uin.high >>> 0).toNumber(true) : message.account_uin;
                    if (options.oneofs)
                        object.account = "account_uin";
                }
                if (message.super_ticket != null && message.hasOwnProperty("super_ticket"))
                    object.super_ticket = message.super_ticket;
                return object;
            };

            /**
             * Converts this SwitchAccountRequest to JSON.
             * @function toJSON
             * @memberof kritor.core.SwitchAccountRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SwitchAccountRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SwitchAccountRequest
             * @function getTypeUrl
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SwitchAccountRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.SwitchAccountRequest";
            };

            return SwitchAccountRequest;
        })();

        core.SwitchAccountResponse = (function() {

            /**
             * Properties of a SwitchAccountResponse.
             * @memberof kritor.core
             * @interface ISwitchAccountResponse
             */

            /**
             * Constructs a new SwitchAccountResponse.
             * @memberof kritor.core
             * @classdesc Represents a SwitchAccountResponse.
             * @implements ISwitchAccountResponse
             * @constructor
             * @param {kritor.core.ISwitchAccountResponse=} [properties] Properties to set
             */
            function SwitchAccountResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SwitchAccountResponse instance using the specified properties.
             * @function create
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {kritor.core.ISwitchAccountResponse=} [properties] Properties to set
             * @returns {kritor.core.SwitchAccountResponse} SwitchAccountResponse instance
             */
            SwitchAccountResponse.create = function create(properties) {
                return new SwitchAccountResponse(properties);
            };

            /**
             * Encodes the specified SwitchAccountResponse message. Does not implicitly {@link kritor.core.SwitchAccountResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {kritor.core.ISwitchAccountResponse} message SwitchAccountResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchAccountResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SwitchAccountResponse message, length delimited. Does not implicitly {@link kritor.core.SwitchAccountResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {kritor.core.ISwitchAccountResponse} message SwitchAccountResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchAccountResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SwitchAccountResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.SwitchAccountResponse} SwitchAccountResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchAccountResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.SwitchAccountResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SwitchAccountResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.SwitchAccountResponse} SwitchAccountResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchAccountResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SwitchAccountResponse message.
             * @function verify
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SwitchAccountResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SwitchAccountResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.SwitchAccountResponse} SwitchAccountResponse
             */
            SwitchAccountResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.SwitchAccountResponse)
                    return object;
                return new $root.kritor.core.SwitchAccountResponse();
            };

            /**
             * Creates a plain object from a SwitchAccountResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {kritor.core.SwitchAccountResponse} message SwitchAccountResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SwitchAccountResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SwitchAccountResponse to JSON.
             * @function toJSON
             * @memberof kritor.core.SwitchAccountResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SwitchAccountResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SwitchAccountResponse
             * @function getTypeUrl
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SwitchAccountResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.SwitchAccountResponse";
            };

            return SwitchAccountResponse;
        })();

        return core;
    })();

    kritor.customization = (function() {

        /**
         * Namespace customization.
         * @memberof kritor
         * @namespace
         */
        const customization = {};

        customization.CustomizationService = (function() {

            /**
             * Constructs a new CustomizationService service.
             * @memberof kritor.customization
             * @classdesc Represents a CustomizationService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function CustomizationService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (CustomizationService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = CustomizationService;

            /**
             * Creates new CustomizationService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.customization.CustomizationService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {CustomizationService} RPC service. Useful where requests and/or responses are streamed.
             */
            CustomizationService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.customization.CustomizationService#callFunction}.
             * @memberof kritor.customization.CustomizationService
             * @typedef CallFunctionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.common.Response} [response] Response
             */

            /**
             * Calls CallFunction.
             * @function callFunction
             * @memberof kritor.customization.CustomizationService
             * @instance
             * @param {kritor.common.IRequest} request Request message or plain object
             * @param {kritor.customization.CustomizationService.CallFunctionCallback} callback Node-style callback called with the error, if any, and Response
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(CustomizationService.prototype.callFunction = function callFunction(request, callback) {
                return this.rpcCall(callFunction, $root.kritor.common.Request, $root.kritor.common.Response, request, callback);
            }, "name", { value: "CallFunction" });

            /**
             * Calls CallFunction.
             * @function callFunction
             * @memberof kritor.customization.CustomizationService
             * @instance
             * @param {kritor.common.IRequest} request Request message or plain object
             * @returns {Promise<kritor.common.Response>} Promise
             * @variation 2
             */

            return CustomizationService;
        })();

        return customization;
    })();

    kritor.developer = (function() {

        /**
         * Namespace developer.
         * @memberof kritor
         * @namespace
         */
        const developer = {};

        developer.DeveloperService = (function() {

            /**
             * Constructs a new DeveloperService service.
             * @memberof kritor.developer
             * @classdesc Represents a DeveloperService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function DeveloperService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (DeveloperService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DeveloperService;

            /**
             * Creates new DeveloperService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.developer.DeveloperService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {DeveloperService} RPC service. Useful where requests and/or responses are streamed.
             */
            DeveloperService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.developer.DeveloperService#shell}.
             * @memberof kritor.developer.DeveloperService
             * @typedef ShellCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.ShellResponse} [response] ShellResponse
             */

            /**
             * Calls Shell.
             * @function shell
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IShellRequest} request ShellRequest message or plain object
             * @param {kritor.developer.DeveloperService.ShellCallback} callback Node-style callback called with the error, if any, and ShellResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeveloperService.prototype.shell = function shell(request, callback) {
                return this.rpcCall(shell, $root.kritor.developer.ShellRequest, $root.kritor.developer.ShellResponse, request, callback);
            }, "name", { value: "Shell" });

            /**
             * Calls Shell.
             * @function shell
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IShellRequest} request ShellRequest message or plain object
             * @returns {Promise<kritor.developer.ShellResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.developer.DeveloperService#getLog}.
             * @memberof kritor.developer.DeveloperService
             * @typedef GetLogCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.GetLogResponse} [response] GetLogResponse
             */

            /**
             * Calls GetLog.
             * @function getLog
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IGetLogRequest} request GetLogRequest message or plain object
             * @param {kritor.developer.DeveloperService.GetLogCallback} callback Node-style callback called with the error, if any, and GetLogResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeveloperService.prototype.getLog = function getLog(request, callback) {
                return this.rpcCall(getLog, $root.kritor.developer.GetLogRequest, $root.kritor.developer.GetLogResponse, request, callback);
            }, "name", { value: "GetLog" });

            /**
             * Calls GetLog.
             * @function getLog
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IGetLogRequest} request GetLogRequest message or plain object
             * @returns {Promise<kritor.developer.GetLogResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.developer.DeveloperService#clearCache}.
             * @memberof kritor.developer.DeveloperService
             * @typedef ClearCacheCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.ClearCacheResponse} [response] ClearCacheResponse
             */

            /**
             * Calls ClearCache.
             * @function clearCache
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IClearCacheRequest} request ClearCacheRequest message or plain object
             * @param {kritor.developer.DeveloperService.ClearCacheCallback} callback Node-style callback called with the error, if any, and ClearCacheResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeveloperService.prototype.clearCache = function clearCache(request, callback) {
                return this.rpcCall(clearCache, $root.kritor.developer.ClearCacheRequest, $root.kritor.developer.ClearCacheResponse, request, callback);
            }, "name", { value: "ClearCache" });

            /**
             * Calls ClearCache.
             * @function clearCache
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IClearCacheRequest} request ClearCacheRequest message or plain object
             * @returns {Promise<kritor.developer.ClearCacheResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.developer.DeveloperService#getDeviceBattery}.
             * @memberof kritor.developer.DeveloperService
             * @typedef GetDeviceBatteryCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.GetDeviceBatteryResponse} [response] GetDeviceBatteryResponse
             */

            /**
             * Calls GetDeviceBattery.
             * @function getDeviceBattery
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IGetDeviceBatteryRequest} request GetDeviceBatteryRequest message or plain object
             * @param {kritor.developer.DeveloperService.GetDeviceBatteryCallback} callback Node-style callback called with the error, if any, and GetDeviceBatteryResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeveloperService.prototype.getDeviceBattery = function getDeviceBattery(request, callback) {
                return this.rpcCall(getDeviceBattery, $root.kritor.developer.GetDeviceBatteryRequest, $root.kritor.developer.GetDeviceBatteryResponse, request, callback);
            }, "name", { value: "GetDeviceBattery" });

            /**
             * Calls GetDeviceBattery.
             * @function getDeviceBattery
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IGetDeviceBatteryRequest} request GetDeviceBatteryRequest message or plain object
             * @returns {Promise<kritor.developer.GetDeviceBatteryResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.developer.DeveloperService#uploadImage}.
             * @memberof kritor.developer.DeveloperService
             * @typedef UploadImageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.UploadImageResponse} [response] UploadImageResponse
             */

            /**
             * Calls UploadImage.
             * @function uploadImage
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IUploadImageRequest} request UploadImageRequest message or plain object
             * @param {kritor.developer.DeveloperService.UploadImageCallback} callback Node-style callback called with the error, if any, and UploadImageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeveloperService.prototype.uploadImage = function uploadImage(request, callback) {
                return this.rpcCall(uploadImage, $root.kritor.developer.UploadImageRequest, $root.kritor.developer.UploadImageResponse, request, callback);
            }, "name", { value: "UploadImage" });

            /**
             * Calls UploadImage.
             * @function uploadImage
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IUploadImageRequest} request UploadImageRequest message or plain object
             * @returns {Promise<kritor.developer.UploadImageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.developer.DeveloperService#sendPacket}.
             * @memberof kritor.developer.DeveloperService
             * @typedef SendPacketCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.SendPacketResponse} [response] SendPacketResponse
             */

            /**
             * Calls SendPacket.
             * @function sendPacket
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.ISendPacketRequest} request SendPacketRequest message or plain object
             * @param {kritor.developer.DeveloperService.SendPacketCallback} callback Node-style callback called with the error, if any, and SendPacketResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeveloperService.prototype.sendPacket = function sendPacket(request, callback) {
                return this.rpcCall(sendPacket, $root.kritor.developer.SendPacketRequest, $root.kritor.developer.SendPacketResponse, request, callback);
            }, "name", { value: "SendPacket" });

            /**
             * Calls SendPacket.
             * @function sendPacket
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.ISendPacketRequest} request SendPacketRequest message or plain object
             * @returns {Promise<kritor.developer.SendPacketResponse>} Promise
             * @variation 2
             */

            return DeveloperService;
        })();

        developer.ShellRequest = (function() {

            /**
             * Properties of a ShellRequest.
             * @memberof kritor.developer
             * @interface IShellRequest
             * @property {string|null} [command] ShellRequest command
             * @property {string|null} [directory] ShellRequest directory
             */

            /**
             * Constructs a new ShellRequest.
             * @memberof kritor.developer
             * @classdesc Represents a ShellRequest.
             * @implements IShellRequest
             * @constructor
             * @param {kritor.developer.IShellRequest=} [properties] Properties to set
             */
            function ShellRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShellRequest command.
             * @member {string} command
             * @memberof kritor.developer.ShellRequest
             * @instance
             */
            ShellRequest.prototype.command = "";

            /**
             * ShellRequest directory.
             * @member {string} directory
             * @memberof kritor.developer.ShellRequest
             * @instance
             */
            ShellRequest.prototype.directory = "";

            /**
             * Creates a new ShellRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {kritor.developer.IShellRequest=} [properties] Properties to set
             * @returns {kritor.developer.ShellRequest} ShellRequest instance
             */
            ShellRequest.create = function create(properties) {
                return new ShellRequest(properties);
            };

            /**
             * Encodes the specified ShellRequest message. Does not implicitly {@link kritor.developer.ShellRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {kritor.developer.IShellRequest} message ShellRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShellRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
                if (message.directory != null && Object.hasOwnProperty.call(message, "directory"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.directory);
                return writer;
            };

            /**
             * Encodes the specified ShellRequest message, length delimited. Does not implicitly {@link kritor.developer.ShellRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {kritor.developer.IShellRequest} message ShellRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShellRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShellRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.ShellRequest} ShellRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShellRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.ShellRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.command = reader.string();
                            break;
                        }
                    case 2: {
                            message.directory = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ShellRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.ShellRequest} ShellRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShellRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShellRequest message.
             * @function verify
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShellRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.command != null && message.hasOwnProperty("command"))
                    if (!$util.isString(message.command))
                        return "command: string expected";
                if (message.directory != null && message.hasOwnProperty("directory"))
                    if (!$util.isString(message.directory))
                        return "directory: string expected";
                return null;
            };

            /**
             * Creates a ShellRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.ShellRequest} ShellRequest
             */
            ShellRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.ShellRequest)
                    return object;
                let message = new $root.kritor.developer.ShellRequest();
                if (object.command != null)
                    message.command = String(object.command);
                if (object.directory != null)
                    message.directory = String(object.directory);
                return message;
            };

            /**
             * Creates a plain object from a ShellRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {kritor.developer.ShellRequest} message ShellRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ShellRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.command = "";
                    object.directory = "";
                }
                if (message.command != null && message.hasOwnProperty("command"))
                    object.command = message.command;
                if (message.directory != null && message.hasOwnProperty("directory"))
                    object.directory = message.directory;
                return object;
            };

            /**
             * Converts this ShellRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.ShellRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ShellRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ShellRequest
             * @function getTypeUrl
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ShellRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.ShellRequest";
            };

            return ShellRequest;
        })();

        developer.ShellResponse = (function() {

            /**
             * Properties of a ShellResponse.
             * @memberof kritor.developer
             * @interface IShellResponse
             * @property {boolean|null} [is_success] ShellResponse is_success
             * @property {string|null} [data] ShellResponse data
             */

            /**
             * Constructs a new ShellResponse.
             * @memberof kritor.developer
             * @classdesc Represents a ShellResponse.
             * @implements IShellResponse
             * @constructor
             * @param {kritor.developer.IShellResponse=} [properties] Properties to set
             */
            function ShellResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShellResponse is_success.
             * @member {boolean} is_success
             * @memberof kritor.developer.ShellResponse
             * @instance
             */
            ShellResponse.prototype.is_success = false;

            /**
             * ShellResponse data.
             * @member {string} data
             * @memberof kritor.developer.ShellResponse
             * @instance
             */
            ShellResponse.prototype.data = "";

            /**
             * Creates a new ShellResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {kritor.developer.IShellResponse=} [properties] Properties to set
             * @returns {kritor.developer.ShellResponse} ShellResponse instance
             */
            ShellResponse.create = function create(properties) {
                return new ShellResponse(properties);
            };

            /**
             * Encodes the specified ShellResponse message. Does not implicitly {@link kritor.developer.ShellResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {kritor.developer.IShellResponse} message ShellResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShellResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.is_success != null && Object.hasOwnProperty.call(message, "is_success"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.is_success);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
                return writer;
            };

            /**
             * Encodes the specified ShellResponse message, length delimited. Does not implicitly {@link kritor.developer.ShellResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {kritor.developer.IShellResponse} message ShellResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShellResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShellResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.ShellResponse} ShellResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShellResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.ShellResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.is_success = reader.bool();
                            break;
                        }
                    case 2: {
                            message.data = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ShellResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.ShellResponse} ShellResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShellResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShellResponse message.
             * @function verify
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShellResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.is_success != null && message.hasOwnProperty("is_success"))
                    if (typeof message.is_success !== "boolean")
                        return "is_success: boolean expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isString(message.data))
                        return "data: string expected";
                return null;
            };

            /**
             * Creates a ShellResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.ShellResponse} ShellResponse
             */
            ShellResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.ShellResponse)
                    return object;
                let message = new $root.kritor.developer.ShellResponse();
                if (object.is_success != null)
                    message.is_success = Boolean(object.is_success);
                if (object.data != null)
                    message.data = String(object.data);
                return message;
            };

            /**
             * Creates a plain object from a ShellResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {kritor.developer.ShellResponse} message ShellResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ShellResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.is_success = false;
                    object.data = "";
                }
                if (message.is_success != null && message.hasOwnProperty("is_success"))
                    object.is_success = message.is_success;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                return object;
            };

            /**
             * Converts this ShellResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.ShellResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ShellResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ShellResponse
             * @function getTypeUrl
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ShellResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.ShellResponse";
            };

            return ShellResponse;
        })();

        developer.GetLogRequest = (function() {

            /**
             * Properties of a GetLogRequest.
             * @memberof kritor.developer
             * @interface IGetLogRequest
             * @property {number|Long|null} [start] GetLogRequest start
             * @property {boolean|null} [recent] GetLogRequest recent
             */

            /**
             * Constructs a new GetLogRequest.
             * @memberof kritor.developer
             * @classdesc Represents a GetLogRequest.
             * @implements IGetLogRequest
             * @constructor
             * @param {kritor.developer.IGetLogRequest=} [properties] Properties to set
             */
            function GetLogRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetLogRequest start.
             * @member {number|Long} start
             * @memberof kritor.developer.GetLogRequest
             * @instance
             */
            GetLogRequest.prototype.start = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetLogRequest recent.
             * @member {boolean} recent
             * @memberof kritor.developer.GetLogRequest
             * @instance
             */
            GetLogRequest.prototype.recent = false;

            /**
             * Creates a new GetLogRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {kritor.developer.IGetLogRequest=} [properties] Properties to set
             * @returns {kritor.developer.GetLogRequest} GetLogRequest instance
             */
            GetLogRequest.create = function create(properties) {
                return new GetLogRequest(properties);
            };

            /**
             * Encodes the specified GetLogRequest message. Does not implicitly {@link kritor.developer.GetLogRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {kritor.developer.IGetLogRequest} message GetLogRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetLogRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.start);
                if (message.recent != null && Object.hasOwnProperty.call(message, "recent"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.recent);
                return writer;
            };

            /**
             * Encodes the specified GetLogRequest message, length delimited. Does not implicitly {@link kritor.developer.GetLogRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {kritor.developer.IGetLogRequest} message GetLogRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetLogRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetLogRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.GetLogRequest} GetLogRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetLogRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.GetLogRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.start = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.recent = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetLogRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.GetLogRequest} GetLogRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetLogRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetLogRequest message.
             * @function verify
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetLogRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.start != null && message.hasOwnProperty("start"))
                    if (!$util.isInteger(message.start) && !(message.start && $util.isInteger(message.start.low) && $util.isInteger(message.start.high)))
                        return "start: integer|Long expected";
                if (message.recent != null && message.hasOwnProperty("recent"))
                    if (typeof message.recent !== "boolean")
                        return "recent: boolean expected";
                return null;
            };

            /**
             * Creates a GetLogRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.GetLogRequest} GetLogRequest
             */
            GetLogRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.GetLogRequest)
                    return object;
                let message = new $root.kritor.developer.GetLogRequest();
                if (object.start != null)
                    if ($util.Long)
                        (message.start = $util.Long.fromValue(object.start)).unsigned = true;
                    else if (typeof object.start === "string")
                        message.start = parseInt(object.start, 10);
                    else if (typeof object.start === "number")
                        message.start = object.start;
                    else if (typeof object.start === "object")
                        message.start = new $util.LongBits(object.start.low >>> 0, object.start.high >>> 0).toNumber(true);
                if (object.recent != null)
                    message.recent = Boolean(object.recent);
                return message;
            };

            /**
             * Creates a plain object from a GetLogRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {kritor.developer.GetLogRequest} message GetLogRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetLogRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.start = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.start = options.longs === String ? "0" : 0;
                    object.recent = false;
                }
                if (message.start != null && message.hasOwnProperty("start"))
                    if (typeof message.start === "number")
                        object.start = options.longs === String ? String(message.start) : message.start;
                    else
                        object.start = options.longs === String ? $util.Long.prototype.toString.call(message.start) : options.longs === Number ? new $util.LongBits(message.start.low >>> 0, message.start.high >>> 0).toNumber(true) : message.start;
                if (message.recent != null && message.hasOwnProperty("recent"))
                    object.recent = message.recent;
                return object;
            };

            /**
             * Converts this GetLogRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.GetLogRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetLogRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetLogRequest
             * @function getTypeUrl
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetLogRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.GetLogRequest";
            };

            return GetLogRequest;
        })();

        developer.GetLogResponse = (function() {

            /**
             * Properties of a GetLogResponse.
             * @memberof kritor.developer
             * @interface IGetLogResponse
             * @property {boolean|null} [is_success] GetLogResponse is_success
             * @property {string|null} [log] GetLogResponse log
             */

            /**
             * Constructs a new GetLogResponse.
             * @memberof kritor.developer
             * @classdesc Represents a GetLogResponse.
             * @implements IGetLogResponse
             * @constructor
             * @param {kritor.developer.IGetLogResponse=} [properties] Properties to set
             */
            function GetLogResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetLogResponse is_success.
             * @member {boolean} is_success
             * @memberof kritor.developer.GetLogResponse
             * @instance
             */
            GetLogResponse.prototype.is_success = false;

            /**
             * GetLogResponse log.
             * @member {string} log
             * @memberof kritor.developer.GetLogResponse
             * @instance
             */
            GetLogResponse.prototype.log = "";

            /**
             * Creates a new GetLogResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {kritor.developer.IGetLogResponse=} [properties] Properties to set
             * @returns {kritor.developer.GetLogResponse} GetLogResponse instance
             */
            GetLogResponse.create = function create(properties) {
                return new GetLogResponse(properties);
            };

            /**
             * Encodes the specified GetLogResponse message. Does not implicitly {@link kritor.developer.GetLogResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {kritor.developer.IGetLogResponse} message GetLogResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetLogResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.is_success != null && Object.hasOwnProperty.call(message, "is_success"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.is_success);
                if (message.log != null && Object.hasOwnProperty.call(message, "log"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.log);
                return writer;
            };

            /**
             * Encodes the specified GetLogResponse message, length delimited. Does not implicitly {@link kritor.developer.GetLogResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {kritor.developer.IGetLogResponse} message GetLogResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetLogResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetLogResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.GetLogResponse} GetLogResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetLogResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.GetLogResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.is_success = reader.bool();
                            break;
                        }
                    case 2: {
                            message.log = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetLogResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.GetLogResponse} GetLogResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetLogResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetLogResponse message.
             * @function verify
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetLogResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.is_success != null && message.hasOwnProperty("is_success"))
                    if (typeof message.is_success !== "boolean")
                        return "is_success: boolean expected";
                if (message.log != null && message.hasOwnProperty("log"))
                    if (!$util.isString(message.log))
                        return "log: string expected";
                return null;
            };

            /**
             * Creates a GetLogResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.GetLogResponse} GetLogResponse
             */
            GetLogResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.GetLogResponse)
                    return object;
                let message = new $root.kritor.developer.GetLogResponse();
                if (object.is_success != null)
                    message.is_success = Boolean(object.is_success);
                if (object.log != null)
                    message.log = String(object.log);
                return message;
            };

            /**
             * Creates a plain object from a GetLogResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {kritor.developer.GetLogResponse} message GetLogResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetLogResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.is_success = false;
                    object.log = "";
                }
                if (message.is_success != null && message.hasOwnProperty("is_success"))
                    object.is_success = message.is_success;
                if (message.log != null && message.hasOwnProperty("log"))
                    object.log = message.log;
                return object;
            };

            /**
             * Converts this GetLogResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.GetLogResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetLogResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetLogResponse
             * @function getTypeUrl
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetLogResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.GetLogResponse";
            };

            return GetLogResponse;
        })();

        developer.ClearCacheRequest = (function() {

            /**
             * Properties of a ClearCacheRequest.
             * @memberof kritor.developer
             * @interface IClearCacheRequest
             */

            /**
             * Constructs a new ClearCacheRequest.
             * @memberof kritor.developer
             * @classdesc Represents a ClearCacheRequest.
             * @implements IClearCacheRequest
             * @constructor
             * @param {kritor.developer.IClearCacheRequest=} [properties] Properties to set
             */
            function ClearCacheRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ClearCacheRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {kritor.developer.IClearCacheRequest=} [properties] Properties to set
             * @returns {kritor.developer.ClearCacheRequest} ClearCacheRequest instance
             */
            ClearCacheRequest.create = function create(properties) {
                return new ClearCacheRequest(properties);
            };

            /**
             * Encodes the specified ClearCacheRequest message. Does not implicitly {@link kritor.developer.ClearCacheRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {kritor.developer.IClearCacheRequest} message ClearCacheRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearCacheRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ClearCacheRequest message, length delimited. Does not implicitly {@link kritor.developer.ClearCacheRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {kritor.developer.IClearCacheRequest} message ClearCacheRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearCacheRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClearCacheRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.ClearCacheRequest} ClearCacheRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearCacheRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.ClearCacheRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClearCacheRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.ClearCacheRequest} ClearCacheRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearCacheRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClearCacheRequest message.
             * @function verify
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClearCacheRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ClearCacheRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.ClearCacheRequest} ClearCacheRequest
             */
            ClearCacheRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.ClearCacheRequest)
                    return object;
                return new $root.kritor.developer.ClearCacheRequest();
            };

            /**
             * Creates a plain object from a ClearCacheRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {kritor.developer.ClearCacheRequest} message ClearCacheRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClearCacheRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ClearCacheRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.ClearCacheRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClearCacheRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ClearCacheRequest
             * @function getTypeUrl
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ClearCacheRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.ClearCacheRequest";
            };

            return ClearCacheRequest;
        })();

        developer.ClearCacheResponse = (function() {

            /**
             * Properties of a ClearCacheResponse.
             * @memberof kritor.developer
             * @interface IClearCacheResponse
             */

            /**
             * Constructs a new ClearCacheResponse.
             * @memberof kritor.developer
             * @classdesc Represents a ClearCacheResponse.
             * @implements IClearCacheResponse
             * @constructor
             * @param {kritor.developer.IClearCacheResponse=} [properties] Properties to set
             */
            function ClearCacheResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ClearCacheResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {kritor.developer.IClearCacheResponse=} [properties] Properties to set
             * @returns {kritor.developer.ClearCacheResponse} ClearCacheResponse instance
             */
            ClearCacheResponse.create = function create(properties) {
                return new ClearCacheResponse(properties);
            };

            /**
             * Encodes the specified ClearCacheResponse message. Does not implicitly {@link kritor.developer.ClearCacheResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {kritor.developer.IClearCacheResponse} message ClearCacheResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearCacheResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ClearCacheResponse message, length delimited. Does not implicitly {@link kritor.developer.ClearCacheResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {kritor.developer.IClearCacheResponse} message ClearCacheResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearCacheResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClearCacheResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.ClearCacheResponse} ClearCacheResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearCacheResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.ClearCacheResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClearCacheResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.ClearCacheResponse} ClearCacheResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearCacheResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClearCacheResponse message.
             * @function verify
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClearCacheResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ClearCacheResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.ClearCacheResponse} ClearCacheResponse
             */
            ClearCacheResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.ClearCacheResponse)
                    return object;
                return new $root.kritor.developer.ClearCacheResponse();
            };

            /**
             * Creates a plain object from a ClearCacheResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {kritor.developer.ClearCacheResponse} message ClearCacheResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClearCacheResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ClearCacheResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.ClearCacheResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClearCacheResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ClearCacheResponse
             * @function getTypeUrl
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ClearCacheResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.ClearCacheResponse";
            };

            return ClearCacheResponse;
        })();

        developer.GetDeviceBatteryRequest = (function() {

            /**
             * Properties of a GetDeviceBatteryRequest.
             * @memberof kritor.developer
             * @interface IGetDeviceBatteryRequest
             */

            /**
             * Constructs a new GetDeviceBatteryRequest.
             * @memberof kritor.developer
             * @classdesc Represents a GetDeviceBatteryRequest.
             * @implements IGetDeviceBatteryRequest
             * @constructor
             * @param {kritor.developer.IGetDeviceBatteryRequest=} [properties] Properties to set
             */
            function GetDeviceBatteryRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetDeviceBatteryRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {kritor.developer.IGetDeviceBatteryRequest=} [properties] Properties to set
             * @returns {kritor.developer.GetDeviceBatteryRequest} GetDeviceBatteryRequest instance
             */
            GetDeviceBatteryRequest.create = function create(properties) {
                return new GetDeviceBatteryRequest(properties);
            };

            /**
             * Encodes the specified GetDeviceBatteryRequest message. Does not implicitly {@link kritor.developer.GetDeviceBatteryRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {kritor.developer.IGetDeviceBatteryRequest} message GetDeviceBatteryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceBatteryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetDeviceBatteryRequest message, length delimited. Does not implicitly {@link kritor.developer.GetDeviceBatteryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {kritor.developer.IGetDeviceBatteryRequest} message GetDeviceBatteryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceBatteryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDeviceBatteryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.GetDeviceBatteryRequest} GetDeviceBatteryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceBatteryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.GetDeviceBatteryRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDeviceBatteryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.GetDeviceBatteryRequest} GetDeviceBatteryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceBatteryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDeviceBatteryRequest message.
             * @function verify
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDeviceBatteryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetDeviceBatteryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.GetDeviceBatteryRequest} GetDeviceBatteryRequest
             */
            GetDeviceBatteryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.GetDeviceBatteryRequest)
                    return object;
                return new $root.kritor.developer.GetDeviceBatteryRequest();
            };

            /**
             * Creates a plain object from a GetDeviceBatteryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {kritor.developer.GetDeviceBatteryRequest} message GetDeviceBatteryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDeviceBatteryRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetDeviceBatteryRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDeviceBatteryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDeviceBatteryRequest
             * @function getTypeUrl
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDeviceBatteryRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.GetDeviceBatteryRequest";
            };

            return GetDeviceBatteryRequest;
        })();

        developer.GetDeviceBatteryResponse = (function() {

            /**
             * Properties of a GetDeviceBatteryResponse.
             * @memberof kritor.developer
             * @interface IGetDeviceBatteryResponse
             * @property {number|null} [battery] GetDeviceBatteryResponse battery
             * @property {number|null} [scale] GetDeviceBatteryResponse scale
             * @property {number|null} [status] GetDeviceBatteryResponse status
             */

            /**
             * Constructs a new GetDeviceBatteryResponse.
             * @memberof kritor.developer
             * @classdesc Represents a GetDeviceBatteryResponse.
             * @implements IGetDeviceBatteryResponse
             * @constructor
             * @param {kritor.developer.IGetDeviceBatteryResponse=} [properties] Properties to set
             */
            function GetDeviceBatteryResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDeviceBatteryResponse battery.
             * @member {number} battery
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @instance
             */
            GetDeviceBatteryResponse.prototype.battery = 0;

            /**
             * GetDeviceBatteryResponse scale.
             * @member {number} scale
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @instance
             */
            GetDeviceBatteryResponse.prototype.scale = 0;

            /**
             * GetDeviceBatteryResponse status.
             * @member {number} status
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @instance
             */
            GetDeviceBatteryResponse.prototype.status = 0;

            /**
             * Creates a new GetDeviceBatteryResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {kritor.developer.IGetDeviceBatteryResponse=} [properties] Properties to set
             * @returns {kritor.developer.GetDeviceBatteryResponse} GetDeviceBatteryResponse instance
             */
            GetDeviceBatteryResponse.create = function create(properties) {
                return new GetDeviceBatteryResponse(properties);
            };

            /**
             * Encodes the specified GetDeviceBatteryResponse message. Does not implicitly {@link kritor.developer.GetDeviceBatteryResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {kritor.developer.IGetDeviceBatteryResponse} message GetDeviceBatteryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceBatteryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.battery != null && Object.hasOwnProperty.call(message, "battery"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battery);
                if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.scale);
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.status);
                return writer;
            };

            /**
             * Encodes the specified GetDeviceBatteryResponse message, length delimited. Does not implicitly {@link kritor.developer.GetDeviceBatteryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {kritor.developer.IGetDeviceBatteryResponse} message GetDeviceBatteryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceBatteryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDeviceBatteryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.GetDeviceBatteryResponse} GetDeviceBatteryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceBatteryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.GetDeviceBatteryResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.battery = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.scale = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.status = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDeviceBatteryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.GetDeviceBatteryResponse} GetDeviceBatteryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceBatteryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDeviceBatteryResponse message.
             * @function verify
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDeviceBatteryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.battery != null && message.hasOwnProperty("battery"))
                    if (!$util.isInteger(message.battery))
                        return "battery: integer expected";
                if (message.scale != null && message.hasOwnProperty("scale"))
                    if (!$util.isInteger(message.scale))
                        return "scale: integer expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (!$util.isInteger(message.status))
                        return "status: integer expected";
                return null;
            };

            /**
             * Creates a GetDeviceBatteryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.GetDeviceBatteryResponse} GetDeviceBatteryResponse
             */
            GetDeviceBatteryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.GetDeviceBatteryResponse)
                    return object;
                let message = new $root.kritor.developer.GetDeviceBatteryResponse();
                if (object.battery != null)
                    message.battery = object.battery >>> 0;
                if (object.scale != null)
                    message.scale = object.scale >>> 0;
                if (object.status != null)
                    message.status = object.status >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetDeviceBatteryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {kritor.developer.GetDeviceBatteryResponse} message GetDeviceBatteryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDeviceBatteryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.battery = 0;
                    object.scale = 0;
                    object.status = 0;
                }
                if (message.battery != null && message.hasOwnProperty("battery"))
                    object.battery = message.battery;
                if (message.scale != null && message.hasOwnProperty("scale"))
                    object.scale = message.scale;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                return object;
            };

            /**
             * Converts this GetDeviceBatteryResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDeviceBatteryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDeviceBatteryResponse
             * @function getTypeUrl
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDeviceBatteryResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.GetDeviceBatteryResponse";
            };

            return GetDeviceBatteryResponse;
        })();

        developer.UploadImageRequest = (function() {

            /**
             * Properties of an UploadImageRequest.
             * @memberof kritor.developer
             * @interface IUploadImageRequest
             * @property {Uint8Array|null} [file] UploadImageRequest file
             * @property {string|null} [file_name] UploadImageRequest file_name
             * @property {string|null} [file_path] UploadImageRequest file_path
             * @property {string|null} [file_url] UploadImageRequest file_url
             * @property {number|Long|null} [group_id] UploadImageRequest group_id
             */

            /**
             * Constructs a new UploadImageRequest.
             * @memberof kritor.developer
             * @classdesc Represents an UploadImageRequest.
             * @implements IUploadImageRequest
             * @constructor
             * @param {kritor.developer.IUploadImageRequest=} [properties] Properties to set
             */
            function UploadImageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UploadImageRequest file.
             * @member {Uint8Array|null|undefined} file
             * @memberof kritor.developer.UploadImageRequest
             * @instance
             */
            UploadImageRequest.prototype.file = null;

            /**
             * UploadImageRequest file_name.
             * @member {string|null|undefined} file_name
             * @memberof kritor.developer.UploadImageRequest
             * @instance
             */
            UploadImageRequest.prototype.file_name = null;

            /**
             * UploadImageRequest file_path.
             * @member {string|null|undefined} file_path
             * @memberof kritor.developer.UploadImageRequest
             * @instance
             */
            UploadImageRequest.prototype.file_path = null;

            /**
             * UploadImageRequest file_url.
             * @member {string|null|undefined} file_url
             * @memberof kritor.developer.UploadImageRequest
             * @instance
             */
            UploadImageRequest.prototype.file_url = null;

            /**
             * UploadImageRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.developer.UploadImageRequest
             * @instance
             */
            UploadImageRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * UploadImageRequest data.
             * @member {"file"|"file_name"|"file_path"|"file_url"|undefined} data
             * @memberof kritor.developer.UploadImageRequest
             * @instance
             */
            Object.defineProperty(UploadImageRequest.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["file", "file_name", "file_path", "file_url"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new UploadImageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {kritor.developer.IUploadImageRequest=} [properties] Properties to set
             * @returns {kritor.developer.UploadImageRequest} UploadImageRequest instance
             */
            UploadImageRequest.create = function create(properties) {
                return new UploadImageRequest(properties);
            };

            /**
             * Encodes the specified UploadImageRequest message. Does not implicitly {@link kritor.developer.UploadImageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {kritor.developer.IUploadImageRequest} message UploadImageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadImageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.file);
                if (message.file_name != null && Object.hasOwnProperty.call(message, "file_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.file_name);
                if (message.file_path != null && Object.hasOwnProperty.call(message, "file_path"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.file_path);
                if (message.file_url != null && Object.hasOwnProperty.call(message, "file_url"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.file_url);
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.group_id);
                return writer;
            };

            /**
             * Encodes the specified UploadImageRequest message, length delimited. Does not implicitly {@link kritor.developer.UploadImageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {kritor.developer.IUploadImageRequest} message UploadImageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadImageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UploadImageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.UploadImageRequest} UploadImageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadImageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.UploadImageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.file_name = reader.string();
                            break;
                        }
                    case 3: {
                            message.file_path = reader.string();
                            break;
                        }
                    case 4: {
                            message.file_url = reader.string();
                            break;
                        }
                    case 5: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UploadImageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.UploadImageRequest} UploadImageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadImageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UploadImageRequest message.
             * @function verify
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UploadImageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.file != null && message.hasOwnProperty("file")) {
                    properties.data = 1;
                    if (!(message.file && typeof message.file.length === "number" || $util.isString(message.file)))
                        return "file: buffer expected";
                }
                if (message.file_name != null && message.hasOwnProperty("file_name")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.file_name))
                        return "file_name: string expected";
                }
                if (message.file_path != null && message.hasOwnProperty("file_path")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.file_path))
                        return "file_path: string expected";
                }
                if (message.file_url != null && message.hasOwnProperty("file_url")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.file_url))
                        return "file_url: string expected";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                return null;
            };

            /**
             * Creates an UploadImageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.UploadImageRequest} UploadImageRequest
             */
            UploadImageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.UploadImageRequest)
                    return object;
                let message = new $root.kritor.developer.UploadImageRequest();
                if (object.file != null)
                    if (typeof object.file === "string")
                        $util.base64.decode(object.file, message.file = $util.newBuffer($util.base64.length(object.file)), 0);
                    else if (object.file.length >= 0)
                        message.file = object.file;
                if (object.file_name != null)
                    message.file_name = String(object.file_name);
                if (object.file_path != null)
                    message.file_path = String(object.file_path);
                if (object.file_url != null)
                    message.file_url = String(object.file_url);
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an UploadImageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {kritor.developer.UploadImageRequest} message UploadImageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UploadImageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = options.bytes === String ? $util.base64.encode(message.file, 0, message.file.length) : options.bytes === Array ? Array.prototype.slice.call(message.file) : message.file;
                    if (options.oneofs)
                        object.data = "file";
                }
                if (message.file_name != null && message.hasOwnProperty("file_name")) {
                    object.file_name = message.file_name;
                    if (options.oneofs)
                        object.data = "file_name";
                }
                if (message.file_path != null && message.hasOwnProperty("file_path")) {
                    object.file_path = message.file_path;
                    if (options.oneofs)
                        object.data = "file_path";
                }
                if (message.file_url != null && message.hasOwnProperty("file_url")) {
                    object.file_url = message.file_url;
                    if (options.oneofs)
                        object.data = "file_url";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                return object;
            };

            /**
             * Converts this UploadImageRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.UploadImageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UploadImageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UploadImageRequest
             * @function getTypeUrl
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UploadImageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.UploadImageRequest";
            };

            return UploadImageRequest;
        })();

        developer.UploadImageResponse = (function() {

            /**
             * Properties of an UploadImageResponse.
             * @memberof kritor.developer
             * @interface IUploadImageResponse
             * @property {boolean|null} [is_success] UploadImageResponse is_success
             * @property {string|null} [image_url] UploadImageResponse image_url
             */

            /**
             * Constructs a new UploadImageResponse.
             * @memberof kritor.developer
             * @classdesc Represents an UploadImageResponse.
             * @implements IUploadImageResponse
             * @constructor
             * @param {kritor.developer.IUploadImageResponse=} [properties] Properties to set
             */
            function UploadImageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UploadImageResponse is_success.
             * @member {boolean} is_success
             * @memberof kritor.developer.UploadImageResponse
             * @instance
             */
            UploadImageResponse.prototype.is_success = false;

            /**
             * UploadImageResponse image_url.
             * @member {string} image_url
             * @memberof kritor.developer.UploadImageResponse
             * @instance
             */
            UploadImageResponse.prototype.image_url = "";

            /**
             * Creates a new UploadImageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {kritor.developer.IUploadImageResponse=} [properties] Properties to set
             * @returns {kritor.developer.UploadImageResponse} UploadImageResponse instance
             */
            UploadImageResponse.create = function create(properties) {
                return new UploadImageResponse(properties);
            };

            /**
             * Encodes the specified UploadImageResponse message. Does not implicitly {@link kritor.developer.UploadImageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {kritor.developer.IUploadImageResponse} message UploadImageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadImageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.is_success != null && Object.hasOwnProperty.call(message, "is_success"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.is_success);
                if (message.image_url != null && Object.hasOwnProperty.call(message, "image_url"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.image_url);
                return writer;
            };

            /**
             * Encodes the specified UploadImageResponse message, length delimited. Does not implicitly {@link kritor.developer.UploadImageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {kritor.developer.IUploadImageResponse} message UploadImageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadImageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UploadImageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.UploadImageResponse} UploadImageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadImageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.UploadImageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.is_success = reader.bool();
                            break;
                        }
                    case 2: {
                            message.image_url = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UploadImageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.UploadImageResponse} UploadImageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadImageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UploadImageResponse message.
             * @function verify
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UploadImageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.is_success != null && message.hasOwnProperty("is_success"))
                    if (typeof message.is_success !== "boolean")
                        return "is_success: boolean expected";
                if (message.image_url != null && message.hasOwnProperty("image_url"))
                    if (!$util.isString(message.image_url))
                        return "image_url: string expected";
                return null;
            };

            /**
             * Creates an UploadImageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.UploadImageResponse} UploadImageResponse
             */
            UploadImageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.UploadImageResponse)
                    return object;
                let message = new $root.kritor.developer.UploadImageResponse();
                if (object.is_success != null)
                    message.is_success = Boolean(object.is_success);
                if (object.image_url != null)
                    message.image_url = String(object.image_url);
                return message;
            };

            /**
             * Creates a plain object from an UploadImageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {kritor.developer.UploadImageResponse} message UploadImageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UploadImageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.is_success = false;
                    object.image_url = "";
                }
                if (message.is_success != null && message.hasOwnProperty("is_success"))
                    object.is_success = message.is_success;
                if (message.image_url != null && message.hasOwnProperty("image_url"))
                    object.image_url = message.image_url;
                return object;
            };

            /**
             * Converts this UploadImageResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.UploadImageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UploadImageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UploadImageResponse
             * @function getTypeUrl
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UploadImageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.UploadImageResponse";
            };

            return UploadImageResponse;
        })();

        developer.SendPacketRequest = (function() {

            /**
             * Properties of a SendPacketRequest.
             * @memberof kritor.developer
             * @interface ISendPacketRequest
             * @property {string|null} [command] SendPacketRequest command
             * @property {Uint8Array|null} [request_buffer] SendPacketRequest request_buffer
             * @property {boolean|null} [is_protobuf] SendPacketRequest is_protobuf
             * @property {Object.<string,string>|null} [attrs] SendPacketRequest attrs
             */

            /**
             * Constructs a new SendPacketRequest.
             * @memberof kritor.developer
             * @classdesc Represents a SendPacketRequest.
             * @implements ISendPacketRequest
             * @constructor
             * @param {kritor.developer.ISendPacketRequest=} [properties] Properties to set
             */
            function SendPacketRequest(properties) {
                this.attrs = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendPacketRequest command.
             * @member {string} command
             * @memberof kritor.developer.SendPacketRequest
             * @instance
             */
            SendPacketRequest.prototype.command = "";

            /**
             * SendPacketRequest request_buffer.
             * @member {Uint8Array} request_buffer
             * @memberof kritor.developer.SendPacketRequest
             * @instance
             */
            SendPacketRequest.prototype.request_buffer = $util.newBuffer([]);

            /**
             * SendPacketRequest is_protobuf.
             * @member {boolean} is_protobuf
             * @memberof kritor.developer.SendPacketRequest
             * @instance
             */
            SendPacketRequest.prototype.is_protobuf = false;

            /**
             * SendPacketRequest attrs.
             * @member {Object.<string,string>} attrs
             * @memberof kritor.developer.SendPacketRequest
             * @instance
             */
            SendPacketRequest.prototype.attrs = $util.emptyObject;

            /**
             * Creates a new SendPacketRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {kritor.developer.ISendPacketRequest=} [properties] Properties to set
             * @returns {kritor.developer.SendPacketRequest} SendPacketRequest instance
             */
            SendPacketRequest.create = function create(properties) {
                return new SendPacketRequest(properties);
            };

            /**
             * Encodes the specified SendPacketRequest message. Does not implicitly {@link kritor.developer.SendPacketRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {kritor.developer.ISendPacketRequest} message SendPacketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendPacketRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
                if (message.request_buffer != null && Object.hasOwnProperty.call(message, "request_buffer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.request_buffer);
                if (message.is_protobuf != null && Object.hasOwnProperty.call(message, "is_protobuf"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_protobuf);
                if (message.attrs != null && Object.hasOwnProperty.call(message, "attrs"))
                    for (let keys = Object.keys(message.attrs), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attrs[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SendPacketRequest message, length delimited. Does not implicitly {@link kritor.developer.SendPacketRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {kritor.developer.ISendPacketRequest} message SendPacketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendPacketRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendPacketRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.SendPacketRequest} SendPacketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendPacketRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.SendPacketRequest(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.command = reader.string();
                            break;
                        }
                    case 2: {
                            message.request_buffer = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.is_protobuf = reader.bool();
                            break;
                        }
                    case 4: {
                            if (message.attrs === $util.emptyObject)
                                message.attrs = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.attrs[key] = value;
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendPacketRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.SendPacketRequest} SendPacketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendPacketRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendPacketRequest message.
             * @function verify
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendPacketRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.command != null && message.hasOwnProperty("command"))
                    if (!$util.isString(message.command))
                        return "command: string expected";
                if (message.request_buffer != null && message.hasOwnProperty("request_buffer"))
                    if (!(message.request_buffer && typeof message.request_buffer.length === "number" || $util.isString(message.request_buffer)))
                        return "request_buffer: buffer expected";
                if (message.is_protobuf != null && message.hasOwnProperty("is_protobuf"))
                    if (typeof message.is_protobuf !== "boolean")
                        return "is_protobuf: boolean expected";
                if (message.attrs != null && message.hasOwnProperty("attrs")) {
                    if (!$util.isObject(message.attrs))
                        return "attrs: object expected";
                    let key = Object.keys(message.attrs);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attrs[key[i]]))
                            return "attrs: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a SendPacketRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.SendPacketRequest} SendPacketRequest
             */
            SendPacketRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.SendPacketRequest)
                    return object;
                let message = new $root.kritor.developer.SendPacketRequest();
                if (object.command != null)
                    message.command = String(object.command);
                if (object.request_buffer != null)
                    if (typeof object.request_buffer === "string")
                        $util.base64.decode(object.request_buffer, message.request_buffer = $util.newBuffer($util.base64.length(object.request_buffer)), 0);
                    else if (object.request_buffer.length >= 0)
                        message.request_buffer = object.request_buffer;
                if (object.is_protobuf != null)
                    message.is_protobuf = Boolean(object.is_protobuf);
                if (object.attrs) {
                    if (typeof object.attrs !== "object")
                        throw TypeError(".kritor.developer.SendPacketRequest.attrs: object expected");
                    message.attrs = {};
                    for (let keys = Object.keys(object.attrs), i = 0; i < keys.length; ++i)
                        message.attrs[keys[i]] = String(object.attrs[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a SendPacketRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {kritor.developer.SendPacketRequest} message SendPacketRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendPacketRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.attrs = {};
                if (options.defaults) {
                    object.command = "";
                    if (options.bytes === String)
                        object.request_buffer = "";
                    else {
                        object.request_buffer = [];
                        if (options.bytes !== Array)
                            object.request_buffer = $util.newBuffer(object.request_buffer);
                    }
                    object.is_protobuf = false;
                }
                if (message.command != null && message.hasOwnProperty("command"))
                    object.command = message.command;
                if (message.request_buffer != null && message.hasOwnProperty("request_buffer"))
                    object.request_buffer = options.bytes === String ? $util.base64.encode(message.request_buffer, 0, message.request_buffer.length) : options.bytes === Array ? Array.prototype.slice.call(message.request_buffer) : message.request_buffer;
                if (message.is_protobuf != null && message.hasOwnProperty("is_protobuf"))
                    object.is_protobuf = message.is_protobuf;
                let keys2;
                if (message.attrs && (keys2 = Object.keys(message.attrs)).length) {
                    object.attrs = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.attrs[keys2[j]] = message.attrs[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this SendPacketRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.SendPacketRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendPacketRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendPacketRequest
             * @function getTypeUrl
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendPacketRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.SendPacketRequest";
            };

            return SendPacketRequest;
        })();

        developer.SendPacketResponse = (function() {

            /**
             * Properties of a SendPacketResponse.
             * @memberof kritor.developer
             * @interface ISendPacketResponse
             * @property {boolean|null} [is_success] SendPacketResponse is_success
             * @property {Uint8Array|null} [response_buffer] SendPacketResponse response_buffer
             */

            /**
             * Constructs a new SendPacketResponse.
             * @memberof kritor.developer
             * @classdesc Represents a SendPacketResponse.
             * @implements ISendPacketResponse
             * @constructor
             * @param {kritor.developer.ISendPacketResponse=} [properties] Properties to set
             */
            function SendPacketResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendPacketResponse is_success.
             * @member {boolean} is_success
             * @memberof kritor.developer.SendPacketResponse
             * @instance
             */
            SendPacketResponse.prototype.is_success = false;

            /**
             * SendPacketResponse response_buffer.
             * @member {Uint8Array} response_buffer
             * @memberof kritor.developer.SendPacketResponse
             * @instance
             */
            SendPacketResponse.prototype.response_buffer = $util.newBuffer([]);

            /**
             * Creates a new SendPacketResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {kritor.developer.ISendPacketResponse=} [properties] Properties to set
             * @returns {kritor.developer.SendPacketResponse} SendPacketResponse instance
             */
            SendPacketResponse.create = function create(properties) {
                return new SendPacketResponse(properties);
            };

            /**
             * Encodes the specified SendPacketResponse message. Does not implicitly {@link kritor.developer.SendPacketResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {kritor.developer.ISendPacketResponse} message SendPacketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendPacketResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.is_success != null && Object.hasOwnProperty.call(message, "is_success"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.is_success);
                if (message.response_buffer != null && Object.hasOwnProperty.call(message, "response_buffer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.response_buffer);
                return writer;
            };

            /**
             * Encodes the specified SendPacketResponse message, length delimited. Does not implicitly {@link kritor.developer.SendPacketResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {kritor.developer.ISendPacketResponse} message SendPacketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendPacketResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendPacketResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.SendPacketResponse} SendPacketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendPacketResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.SendPacketResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.is_success = reader.bool();
                            break;
                        }
                    case 2: {
                            message.response_buffer = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendPacketResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.SendPacketResponse} SendPacketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendPacketResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendPacketResponse message.
             * @function verify
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendPacketResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.is_success != null && message.hasOwnProperty("is_success"))
                    if (typeof message.is_success !== "boolean")
                        return "is_success: boolean expected";
                if (message.response_buffer != null && message.hasOwnProperty("response_buffer"))
                    if (!(message.response_buffer && typeof message.response_buffer.length === "number" || $util.isString(message.response_buffer)))
                        return "response_buffer: buffer expected";
                return null;
            };

            /**
             * Creates a SendPacketResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.SendPacketResponse} SendPacketResponse
             */
            SendPacketResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.SendPacketResponse)
                    return object;
                let message = new $root.kritor.developer.SendPacketResponse();
                if (object.is_success != null)
                    message.is_success = Boolean(object.is_success);
                if (object.response_buffer != null)
                    if (typeof object.response_buffer === "string")
                        $util.base64.decode(object.response_buffer, message.response_buffer = $util.newBuffer($util.base64.length(object.response_buffer)), 0);
                    else if (object.response_buffer.length >= 0)
                        message.response_buffer = object.response_buffer;
                return message;
            };

            /**
             * Creates a plain object from a SendPacketResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {kritor.developer.SendPacketResponse} message SendPacketResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendPacketResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.is_success = false;
                    if (options.bytes === String)
                        object.response_buffer = "";
                    else {
                        object.response_buffer = [];
                        if (options.bytes !== Array)
                            object.response_buffer = $util.newBuffer(object.response_buffer);
                    }
                }
                if (message.is_success != null && message.hasOwnProperty("is_success"))
                    object.is_success = message.is_success;
                if (message.response_buffer != null && message.hasOwnProperty("response_buffer"))
                    object.response_buffer = options.bytes === String ? $util.base64.encode(message.response_buffer, 0, message.response_buffer.length) : options.bytes === Array ? Array.prototype.slice.call(message.response_buffer) : message.response_buffer;
                return object;
            };

            /**
             * Converts this SendPacketResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.SendPacketResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendPacketResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendPacketResponse
             * @function getTypeUrl
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendPacketResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.SendPacketResponse";
            };

            return SendPacketResponse;
        })();

        developer.QsignService = (function() {

            /**
             * Constructs a new QsignService service.
             * @memberof kritor.developer
             * @classdesc Represents a QsignService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function QsignService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (QsignService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = QsignService;

            /**
             * Creates new QsignService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.developer.QsignService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {QsignService} RPC service. Useful where requests and/or responses are streamed.
             */
            QsignService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.developer.QsignService#sign}.
             * @memberof kritor.developer.QsignService
             * @typedef SignCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.SignResponse} [response] SignResponse
             */

            /**
             * Calls Sign.
             * @function sign
             * @memberof kritor.developer.QsignService
             * @instance
             * @param {kritor.developer.ISignRequest} request SignRequest message or plain object
             * @param {kritor.developer.QsignService.SignCallback} callback Node-style callback called with the error, if any, and SignResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(QsignService.prototype.sign = function sign(request, callback) {
                return this.rpcCall(sign, $root.kritor.developer.SignRequest, $root.kritor.developer.SignResponse, request, callback);
            }, "name", { value: "Sign" });

            /**
             * Calls Sign.
             * @function sign
             * @memberof kritor.developer.QsignService
             * @instance
             * @param {kritor.developer.ISignRequest} request SignRequest message or plain object
             * @returns {Promise<kritor.developer.SignResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.developer.QsignService#energy}.
             * @memberof kritor.developer.QsignService
             * @typedef EnergyCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.EnergyResponse} [response] EnergyResponse
             */

            /**
             * Calls Energy.
             * @function energy
             * @memberof kritor.developer.QsignService
             * @instance
             * @param {kritor.developer.IEnergyRequest} request EnergyRequest message or plain object
             * @param {kritor.developer.QsignService.EnergyCallback} callback Node-style callback called with the error, if any, and EnergyResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(QsignService.prototype.energy = function energy(request, callback) {
                return this.rpcCall(energy, $root.kritor.developer.EnergyRequest, $root.kritor.developer.EnergyResponse, request, callback);
            }, "name", { value: "Energy" });

            /**
             * Calls Energy.
             * @function energy
             * @memberof kritor.developer.QsignService
             * @instance
             * @param {kritor.developer.IEnergyRequest} request EnergyRequest message or plain object
             * @returns {Promise<kritor.developer.EnergyResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.developer.QsignService#getCmdWhitelist}.
             * @memberof kritor.developer.QsignService
             * @typedef GetCmdWhitelistCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.GetCmdWhitelistResponse} [response] GetCmdWhitelistResponse
             */

            /**
             * Calls GetCmdWhitelist.
             * @function getCmdWhitelist
             * @memberof kritor.developer.QsignService
             * @instance
             * @param {kritor.developer.IGetCmdWhitelistRequest} request GetCmdWhitelistRequest message or plain object
             * @param {kritor.developer.QsignService.GetCmdWhitelistCallback} callback Node-style callback called with the error, if any, and GetCmdWhitelistResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(QsignService.prototype.getCmdWhitelist = function getCmdWhitelist(request, callback) {
                return this.rpcCall(getCmdWhitelist, $root.kritor.developer.GetCmdWhitelistRequest, $root.kritor.developer.GetCmdWhitelistResponse, request, callback);
            }, "name", { value: "GetCmdWhitelist" });

            /**
             * Calls GetCmdWhitelist.
             * @function getCmdWhitelist
             * @memberof kritor.developer.QsignService
             * @instance
             * @param {kritor.developer.IGetCmdWhitelistRequest} request GetCmdWhitelistRequest message or plain object
             * @returns {Promise<kritor.developer.GetCmdWhitelistResponse>} Promise
             * @variation 2
             */

            return QsignService;
        })();

        developer.SignRequest = (function() {

            /**
             * Properties of a SignRequest.
             * @memberof kritor.developer
             * @interface ISignRequest
             * @property {string|null} [uin] SignRequest uin
             * @property {string|null} [command] SignRequest command
             * @property {number|null} [seq] SignRequest seq
             * @property {Uint8Array|null} [buffer] SignRequest buffer
             * @property {string|null} [qua] SignRequest qua
             */

            /**
             * Constructs a new SignRequest.
             * @memberof kritor.developer
             * @classdesc Represents a SignRequest.
             * @implements ISignRequest
             * @constructor
             * @param {kritor.developer.ISignRequest=} [properties] Properties to set
             */
            function SignRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SignRequest uin.
             * @member {string} uin
             * @memberof kritor.developer.SignRequest
             * @instance
             */
            SignRequest.prototype.uin = "";

            /**
             * SignRequest command.
             * @member {string} command
             * @memberof kritor.developer.SignRequest
             * @instance
             */
            SignRequest.prototype.command = "";

            /**
             * SignRequest seq.
             * @member {number} seq
             * @memberof kritor.developer.SignRequest
             * @instance
             */
            SignRequest.prototype.seq = 0;

            /**
             * SignRequest buffer.
             * @member {Uint8Array} buffer
             * @memberof kritor.developer.SignRequest
             * @instance
             */
            SignRequest.prototype.buffer = $util.newBuffer([]);

            /**
             * SignRequest qua.
             * @member {string|null|undefined} qua
             * @memberof kritor.developer.SignRequest
             * @instance
             */
            SignRequest.prototype.qua = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SignRequest _qua.
             * @member {"qua"|undefined} _qua
             * @memberof kritor.developer.SignRequest
             * @instance
             */
            Object.defineProperty(SignRequest.prototype, "_qua", {
                get: $util.oneOfGetter($oneOfFields = ["qua"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SignRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {kritor.developer.ISignRequest=} [properties] Properties to set
             * @returns {kritor.developer.SignRequest} SignRequest instance
             */
            SignRequest.create = function create(properties) {
                return new SignRequest(properties);
            };

            /**
             * Encodes the specified SignRequest message. Does not implicitly {@link kritor.developer.SignRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {kritor.developer.ISignRequest} message SignRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uin);
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.command);
                if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.seq);
                if (message.buffer != null && Object.hasOwnProperty.call(message, "buffer"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.buffer);
                if (message.qua != null && Object.hasOwnProperty.call(message, "qua"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.qua);
                return writer;
            };

            /**
             * Encodes the specified SignRequest message, length delimited. Does not implicitly {@link kritor.developer.SignRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {kritor.developer.ISignRequest} message SignRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SignRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.SignRequest} SignRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.SignRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uin = reader.string();
                            break;
                        }
                    case 2: {
                            message.command = reader.string();
                            break;
                        }
                    case 3: {
                            message.seq = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.buffer = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.qua = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SignRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.SignRequest} SignRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SignRequest message.
             * @function verify
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isString(message.uin))
                        return "uin: string expected";
                if (message.command != null && message.hasOwnProperty("command"))
                    if (!$util.isString(message.command))
                        return "command: string expected";
                if (message.seq != null && message.hasOwnProperty("seq"))
                    if (!$util.isInteger(message.seq))
                        return "seq: integer expected";
                if (message.buffer != null && message.hasOwnProperty("buffer"))
                    if (!(message.buffer && typeof message.buffer.length === "number" || $util.isString(message.buffer)))
                        return "buffer: buffer expected";
                if (message.qua != null && message.hasOwnProperty("qua")) {
                    properties._qua = 1;
                    if (!$util.isString(message.qua))
                        return "qua: string expected";
                }
                return null;
            };

            /**
             * Creates a SignRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.SignRequest} SignRequest
             */
            SignRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.SignRequest)
                    return object;
                let message = new $root.kritor.developer.SignRequest();
                if (object.uin != null)
                    message.uin = String(object.uin);
                if (object.command != null)
                    message.command = String(object.command);
                if (object.seq != null)
                    message.seq = object.seq >>> 0;
                if (object.buffer != null)
                    if (typeof object.buffer === "string")
                        $util.base64.decode(object.buffer, message.buffer = $util.newBuffer($util.base64.length(object.buffer)), 0);
                    else if (object.buffer.length >= 0)
                        message.buffer = object.buffer;
                if (object.qua != null)
                    message.qua = String(object.qua);
                return message;
            };

            /**
             * Creates a plain object from a SignRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {kritor.developer.SignRequest} message SignRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uin = "";
                    object.command = "";
                    object.seq = 0;
                    if (options.bytes === String)
                        object.buffer = "";
                    else {
                        object.buffer = [];
                        if (options.bytes !== Array)
                            object.buffer = $util.newBuffer(object.buffer);
                    }
                }
                if (message.uin != null && message.hasOwnProperty("uin"))
                    object.uin = message.uin;
                if (message.command != null && message.hasOwnProperty("command"))
                    object.command = message.command;
                if (message.seq != null && message.hasOwnProperty("seq"))
                    object.seq = message.seq;
                if (message.buffer != null && message.hasOwnProperty("buffer"))
                    object.buffer = options.bytes === String ? $util.base64.encode(message.buffer, 0, message.buffer.length) : options.bytes === Array ? Array.prototype.slice.call(message.buffer) : message.buffer;
                if (message.qua != null && message.hasOwnProperty("qua")) {
                    object.qua = message.qua;
                    if (options.oneofs)
                        object._qua = "qua";
                }
                return object;
            };

            /**
             * Converts this SignRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.SignRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SignRequest
             * @function getTypeUrl
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SignRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.SignRequest";
            };

            return SignRequest;
        })();

        developer.SignResponse = (function() {

            /**
             * Properties of a SignResponse.
             * @memberof kritor.developer
             * @interface ISignResponse
             * @property {Uint8Array|null} [sec_sig] SignResponse sec_sig
             * @property {Uint8Array|null} [sec_device_token] SignResponse sec_device_token
             * @property {Uint8Array|null} [sec_extra] SignResponse sec_extra
             */

            /**
             * Constructs a new SignResponse.
             * @memberof kritor.developer
             * @classdesc Represents a SignResponse.
             * @implements ISignResponse
             * @constructor
             * @param {kritor.developer.ISignResponse=} [properties] Properties to set
             */
            function SignResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SignResponse sec_sig.
             * @member {Uint8Array} sec_sig
             * @memberof kritor.developer.SignResponse
             * @instance
             */
            SignResponse.prototype.sec_sig = $util.newBuffer([]);

            /**
             * SignResponse sec_device_token.
             * @member {Uint8Array} sec_device_token
             * @memberof kritor.developer.SignResponse
             * @instance
             */
            SignResponse.prototype.sec_device_token = $util.newBuffer([]);

            /**
             * SignResponse sec_extra.
             * @member {Uint8Array} sec_extra
             * @memberof kritor.developer.SignResponse
             * @instance
             */
            SignResponse.prototype.sec_extra = $util.newBuffer([]);

            /**
             * Creates a new SignResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {kritor.developer.ISignResponse=} [properties] Properties to set
             * @returns {kritor.developer.SignResponse} SignResponse instance
             */
            SignResponse.create = function create(properties) {
                return new SignResponse(properties);
            };

            /**
             * Encodes the specified SignResponse message. Does not implicitly {@link kritor.developer.SignResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {kritor.developer.ISignResponse} message SignResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sec_sig != null && Object.hasOwnProperty.call(message, "sec_sig"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sec_sig);
                if (message.sec_device_token != null && Object.hasOwnProperty.call(message, "sec_device_token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.sec_device_token);
                if (message.sec_extra != null && Object.hasOwnProperty.call(message, "sec_extra"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.sec_extra);
                return writer;
            };

            /**
             * Encodes the specified SignResponse message, length delimited. Does not implicitly {@link kritor.developer.SignResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {kritor.developer.ISignResponse} message SignResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SignResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.SignResponse} SignResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.SignResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sec_sig = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.sec_device_token = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.sec_extra = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SignResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.SignResponse} SignResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SignResponse message.
             * @function verify
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sec_sig != null && message.hasOwnProperty("sec_sig"))
                    if (!(message.sec_sig && typeof message.sec_sig.length === "number" || $util.isString(message.sec_sig)))
                        return "sec_sig: buffer expected";
                if (message.sec_device_token != null && message.hasOwnProperty("sec_device_token"))
                    if (!(message.sec_device_token && typeof message.sec_device_token.length === "number" || $util.isString(message.sec_device_token)))
                        return "sec_device_token: buffer expected";
                if (message.sec_extra != null && message.hasOwnProperty("sec_extra"))
                    if (!(message.sec_extra && typeof message.sec_extra.length === "number" || $util.isString(message.sec_extra)))
                        return "sec_extra: buffer expected";
                return null;
            };

            /**
             * Creates a SignResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.SignResponse} SignResponse
             */
            SignResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.SignResponse)
                    return object;
                let message = new $root.kritor.developer.SignResponse();
                if (object.sec_sig != null)
                    if (typeof object.sec_sig === "string")
                        $util.base64.decode(object.sec_sig, message.sec_sig = $util.newBuffer($util.base64.length(object.sec_sig)), 0);
                    else if (object.sec_sig.length >= 0)
                        message.sec_sig = object.sec_sig;
                if (object.sec_device_token != null)
                    if (typeof object.sec_device_token === "string")
                        $util.base64.decode(object.sec_device_token, message.sec_device_token = $util.newBuffer($util.base64.length(object.sec_device_token)), 0);
                    else if (object.sec_device_token.length >= 0)
                        message.sec_device_token = object.sec_device_token;
                if (object.sec_extra != null)
                    if (typeof object.sec_extra === "string")
                        $util.base64.decode(object.sec_extra, message.sec_extra = $util.newBuffer($util.base64.length(object.sec_extra)), 0);
                    else if (object.sec_extra.length >= 0)
                        message.sec_extra = object.sec_extra;
                return message;
            };

            /**
             * Creates a plain object from a SignResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {kritor.developer.SignResponse} message SignResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.sec_sig = "";
                    else {
                        object.sec_sig = [];
                        if (options.bytes !== Array)
                            object.sec_sig = $util.newBuffer(object.sec_sig);
                    }
                    if (options.bytes === String)
                        object.sec_device_token = "";
                    else {
                        object.sec_device_token = [];
                        if (options.bytes !== Array)
                            object.sec_device_token = $util.newBuffer(object.sec_device_token);
                    }
                    if (options.bytes === String)
                        object.sec_extra = "";
                    else {
                        object.sec_extra = [];
                        if (options.bytes !== Array)
                            object.sec_extra = $util.newBuffer(object.sec_extra);
                    }
                }
                if (message.sec_sig != null && message.hasOwnProperty("sec_sig"))
                    object.sec_sig = options.bytes === String ? $util.base64.encode(message.sec_sig, 0, message.sec_sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.sec_sig) : message.sec_sig;
                if (message.sec_device_token != null && message.hasOwnProperty("sec_device_token"))
                    object.sec_device_token = options.bytes === String ? $util.base64.encode(message.sec_device_token, 0, message.sec_device_token.length) : options.bytes === Array ? Array.prototype.slice.call(message.sec_device_token) : message.sec_device_token;
                if (message.sec_extra != null && message.hasOwnProperty("sec_extra"))
                    object.sec_extra = options.bytes === String ? $util.base64.encode(message.sec_extra, 0, message.sec_extra.length) : options.bytes === Array ? Array.prototype.slice.call(message.sec_extra) : message.sec_extra;
                return object;
            };

            /**
             * Converts this SignResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.SignResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SignResponse
             * @function getTypeUrl
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SignResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.SignResponse";
            };

            return SignResponse;
        })();

        developer.EnergyRequest = (function() {

            /**
             * Properties of an EnergyRequest.
             * @memberof kritor.developer
             * @interface IEnergyRequest
             * @property {string|null} [data] EnergyRequest data
             * @property {Uint8Array|null} [salt] EnergyRequest salt
             */

            /**
             * Constructs a new EnergyRequest.
             * @memberof kritor.developer
             * @classdesc Represents an EnergyRequest.
             * @implements IEnergyRequest
             * @constructor
             * @param {kritor.developer.IEnergyRequest=} [properties] Properties to set
             */
            function EnergyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnergyRequest data.
             * @member {string} data
             * @memberof kritor.developer.EnergyRequest
             * @instance
             */
            EnergyRequest.prototype.data = "";

            /**
             * EnergyRequest salt.
             * @member {Uint8Array} salt
             * @memberof kritor.developer.EnergyRequest
             * @instance
             */
            EnergyRequest.prototype.salt = $util.newBuffer([]);

            /**
             * Creates a new EnergyRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {kritor.developer.IEnergyRequest=} [properties] Properties to set
             * @returns {kritor.developer.EnergyRequest} EnergyRequest instance
             */
            EnergyRequest.create = function create(properties) {
                return new EnergyRequest(properties);
            };

            /**
             * Encodes the specified EnergyRequest message. Does not implicitly {@link kritor.developer.EnergyRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {kritor.developer.IEnergyRequest} message EnergyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnergyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
                if (message.salt != null && Object.hasOwnProperty.call(message, "salt"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.salt);
                return writer;
            };

            /**
             * Encodes the specified EnergyRequest message, length delimited. Does not implicitly {@link kritor.developer.EnergyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {kritor.developer.IEnergyRequest} message EnergyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnergyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnergyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.EnergyRequest} EnergyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnergyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.EnergyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            message.data = reader.string();
                            break;
                        }
                    case 3: {
                            message.salt = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnergyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.EnergyRequest} EnergyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnergyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnergyRequest message.
             * @function verify
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnergyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isString(message.data))
                        return "data: string expected";
                if (message.salt != null && message.hasOwnProperty("salt"))
                    if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                        return "salt: buffer expected";
                return null;
            };

            /**
             * Creates an EnergyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.EnergyRequest} EnergyRequest
             */
            EnergyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.EnergyRequest)
                    return object;
                let message = new $root.kritor.developer.EnergyRequest();
                if (object.data != null)
                    message.data = String(object.data);
                if (object.salt != null)
                    if (typeof object.salt === "string")
                        $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                    else if (object.salt.length >= 0)
                        message.salt = object.salt;
                return message;
            };

            /**
             * Creates a plain object from an EnergyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {kritor.developer.EnergyRequest} message EnergyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnergyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.data = "";
                    if (options.bytes === String)
                        object.salt = "";
                    else {
                        object.salt = [];
                        if (options.bytes !== Array)
                            object.salt = $util.newBuffer(object.salt);
                    }
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                if (message.salt != null && message.hasOwnProperty("salt"))
                    object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
                return object;
            };

            /**
             * Converts this EnergyRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.EnergyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnergyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EnergyRequest
             * @function getTypeUrl
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EnergyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.EnergyRequest";
            };

            return EnergyRequest;
        })();

        developer.EnergyResponse = (function() {

            /**
             * Properties of an EnergyResponse.
             * @memberof kritor.developer
             * @interface IEnergyResponse
             * @property {Uint8Array|null} [result] EnergyResponse result
             */

            /**
             * Constructs a new EnergyResponse.
             * @memberof kritor.developer
             * @classdesc Represents an EnergyResponse.
             * @implements IEnergyResponse
             * @constructor
             * @param {kritor.developer.IEnergyResponse=} [properties] Properties to set
             */
            function EnergyResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnergyResponse result.
             * @member {Uint8Array} result
             * @memberof kritor.developer.EnergyResponse
             * @instance
             */
            EnergyResponse.prototype.result = $util.newBuffer([]);

            /**
             * Creates a new EnergyResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {kritor.developer.IEnergyResponse=} [properties] Properties to set
             * @returns {kritor.developer.EnergyResponse} EnergyResponse instance
             */
            EnergyResponse.create = function create(properties) {
                return new EnergyResponse(properties);
            };

            /**
             * Encodes the specified EnergyResponse message. Does not implicitly {@link kritor.developer.EnergyResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {kritor.developer.IEnergyResponse} message EnergyResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnergyResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.result);
                return writer;
            };

            /**
             * Encodes the specified EnergyResponse message, length delimited. Does not implicitly {@link kritor.developer.EnergyResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {kritor.developer.IEnergyResponse} message EnergyResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnergyResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnergyResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.EnergyResponse} EnergyResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnergyResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.EnergyResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.result = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnergyResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.EnergyResponse} EnergyResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnergyResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnergyResponse message.
             * @function verify
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnergyResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.result != null && message.hasOwnProperty("result"))
                    if (!(message.result && typeof message.result.length === "number" || $util.isString(message.result)))
                        return "result: buffer expected";
                return null;
            };

            /**
             * Creates an EnergyResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.EnergyResponse} EnergyResponse
             */
            EnergyResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.EnergyResponse)
                    return object;
                let message = new $root.kritor.developer.EnergyResponse();
                if (object.result != null)
                    if (typeof object.result === "string")
                        $util.base64.decode(object.result, message.result = $util.newBuffer($util.base64.length(object.result)), 0);
                    else if (object.result.length >= 0)
                        message.result = object.result;
                return message;
            };

            /**
             * Creates a plain object from an EnergyResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {kritor.developer.EnergyResponse} message EnergyResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnergyResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.result = "";
                    else {
                        object.result = [];
                        if (options.bytes !== Array)
                            object.result = $util.newBuffer(object.result);
                    }
                if (message.result != null && message.hasOwnProperty("result"))
                    object.result = options.bytes === String ? $util.base64.encode(message.result, 0, message.result.length) : options.bytes === Array ? Array.prototype.slice.call(message.result) : message.result;
                return object;
            };

            /**
             * Converts this EnergyResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.EnergyResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnergyResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EnergyResponse
             * @function getTypeUrl
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EnergyResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.EnergyResponse";
            };

            return EnergyResponse;
        })();

        developer.GetCmdWhitelistRequest = (function() {

            /**
             * Properties of a GetCmdWhitelistRequest.
             * @memberof kritor.developer
             * @interface IGetCmdWhitelistRequest
             */

            /**
             * Constructs a new GetCmdWhitelistRequest.
             * @memberof kritor.developer
             * @classdesc Represents a GetCmdWhitelistRequest.
             * @implements IGetCmdWhitelistRequest
             * @constructor
             * @param {kritor.developer.IGetCmdWhitelistRequest=} [properties] Properties to set
             */
            function GetCmdWhitelistRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetCmdWhitelistRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {kritor.developer.IGetCmdWhitelistRequest=} [properties] Properties to set
             * @returns {kritor.developer.GetCmdWhitelistRequest} GetCmdWhitelistRequest instance
             */
            GetCmdWhitelistRequest.create = function create(properties) {
                return new GetCmdWhitelistRequest(properties);
            };

            /**
             * Encodes the specified GetCmdWhitelistRequest message. Does not implicitly {@link kritor.developer.GetCmdWhitelistRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {kritor.developer.IGetCmdWhitelistRequest} message GetCmdWhitelistRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCmdWhitelistRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetCmdWhitelistRequest message, length delimited. Does not implicitly {@link kritor.developer.GetCmdWhitelistRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {kritor.developer.IGetCmdWhitelistRequest} message GetCmdWhitelistRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCmdWhitelistRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCmdWhitelistRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.GetCmdWhitelistRequest} GetCmdWhitelistRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCmdWhitelistRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.GetCmdWhitelistRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCmdWhitelistRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.GetCmdWhitelistRequest} GetCmdWhitelistRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCmdWhitelistRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCmdWhitelistRequest message.
             * @function verify
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCmdWhitelistRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetCmdWhitelistRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.GetCmdWhitelistRequest} GetCmdWhitelistRequest
             */
            GetCmdWhitelistRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.GetCmdWhitelistRequest)
                    return object;
                return new $root.kritor.developer.GetCmdWhitelistRequest();
            };

            /**
             * Creates a plain object from a GetCmdWhitelistRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {kritor.developer.GetCmdWhitelistRequest} message GetCmdWhitelistRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCmdWhitelistRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetCmdWhitelistRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCmdWhitelistRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCmdWhitelistRequest
             * @function getTypeUrl
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCmdWhitelistRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.GetCmdWhitelistRequest";
            };

            return GetCmdWhitelistRequest;
        })();

        developer.GetCmdWhitelistResponse = (function() {

            /**
             * Properties of a GetCmdWhitelistResponse.
             * @memberof kritor.developer
             * @interface IGetCmdWhitelistResponse
             * @property {Array.<string>|null} [commands] GetCmdWhitelistResponse commands
             */

            /**
             * Constructs a new GetCmdWhitelistResponse.
             * @memberof kritor.developer
             * @classdesc Represents a GetCmdWhitelistResponse.
             * @implements IGetCmdWhitelistResponse
             * @constructor
             * @param {kritor.developer.IGetCmdWhitelistResponse=} [properties] Properties to set
             */
            function GetCmdWhitelistResponse(properties) {
                this.commands = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCmdWhitelistResponse commands.
             * @member {Array.<string>} commands
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @instance
             */
            GetCmdWhitelistResponse.prototype.commands = $util.emptyArray;

            /**
             * Creates a new GetCmdWhitelistResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {kritor.developer.IGetCmdWhitelistResponse=} [properties] Properties to set
             * @returns {kritor.developer.GetCmdWhitelistResponse} GetCmdWhitelistResponse instance
             */
            GetCmdWhitelistResponse.create = function create(properties) {
                return new GetCmdWhitelistResponse(properties);
            };

            /**
             * Encodes the specified GetCmdWhitelistResponse message. Does not implicitly {@link kritor.developer.GetCmdWhitelistResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {kritor.developer.IGetCmdWhitelistResponse} message GetCmdWhitelistResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCmdWhitelistResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.commands != null && message.commands.length)
                    for (let i = 0; i < message.commands.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.commands[i]);
                return writer;
            };

            /**
             * Encodes the specified GetCmdWhitelistResponse message, length delimited. Does not implicitly {@link kritor.developer.GetCmdWhitelistResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {kritor.developer.IGetCmdWhitelistResponse} message GetCmdWhitelistResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCmdWhitelistResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCmdWhitelistResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.GetCmdWhitelistResponse} GetCmdWhitelistResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCmdWhitelistResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.GetCmdWhitelistResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.commands && message.commands.length))
                                message.commands = [];
                            message.commands.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCmdWhitelistResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.GetCmdWhitelistResponse} GetCmdWhitelistResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCmdWhitelistResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCmdWhitelistResponse message.
             * @function verify
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCmdWhitelistResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.commands != null && message.hasOwnProperty("commands")) {
                    if (!Array.isArray(message.commands))
                        return "commands: array expected";
                    for (let i = 0; i < message.commands.length; ++i)
                        if (!$util.isString(message.commands[i]))
                            return "commands: string[] expected";
                }
                return null;
            };

            /**
             * Creates a GetCmdWhitelistResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.GetCmdWhitelistResponse} GetCmdWhitelistResponse
             */
            GetCmdWhitelistResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.GetCmdWhitelistResponse)
                    return object;
                let message = new $root.kritor.developer.GetCmdWhitelistResponse();
                if (object.commands) {
                    if (!Array.isArray(object.commands))
                        throw TypeError(".kritor.developer.GetCmdWhitelistResponse.commands: array expected");
                    message.commands = [];
                    for (let i = 0; i < object.commands.length; ++i)
                        message.commands[i] = String(object.commands[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetCmdWhitelistResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {kritor.developer.GetCmdWhitelistResponse} message GetCmdWhitelistResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCmdWhitelistResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.commands = [];
                if (message.commands && message.commands.length) {
                    object.commands = [];
                    for (let j = 0; j < message.commands.length; ++j)
                        object.commands[j] = message.commands[j];
                }
                return object;
            };

            /**
             * Converts this GetCmdWhitelistResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCmdWhitelistResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCmdWhitelistResponse
             * @function getTypeUrl
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCmdWhitelistResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.GetCmdWhitelistResponse";
            };

            return GetCmdWhitelistResponse;
        })();

        return developer;
    })();

    kritor.event = (function() {

        /**
         * Namespace event.
         * @memberof kritor
         * @namespace
         */
        const event = {};

        event.EventService = (function() {

            /**
             * Constructs a new EventService service.
             * @memberof kritor.event
             * @classdesc Represents an EventService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function EventService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (EventService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = EventService;

            /**
             * Creates new EventService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.event.EventService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {EventService} RPC service. Useful where requests and/or responses are streamed.
             */
            EventService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.event.EventService#registerActiveListener}.
             * @memberof kritor.event.EventService
             * @typedef RegisterActiveListenerCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.event.EventStructure} [response] EventStructure
             */

            /**
             * Calls RegisterActiveListener.
             * @function registerActiveListener
             * @memberof kritor.event.EventService
             * @instance
             * @param {kritor.event.IRequestPushEvent} request RequestPushEvent message or plain object
             * @param {kritor.event.EventService.RegisterActiveListenerCallback} callback Node-style callback called with the error, if any, and EventStructure
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(EventService.prototype.registerActiveListener = function registerActiveListener(request, callback) {
                return this.rpcCall(registerActiveListener, $root.kritor.event.RequestPushEvent, $root.kritor.event.EventStructure, request, callback);
            }, "name", { value: "RegisterActiveListener" });

            /**
             * Calls RegisterActiveListener.
             * @function registerActiveListener
             * @memberof kritor.event.EventService
             * @instance
             * @param {kritor.event.IRequestPushEvent} request RequestPushEvent message or plain object
             * @returns {Promise<kritor.event.EventStructure>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.event.EventService#registerPassiveListener}.
             * @memberof kritor.event.EventService
             * @typedef RegisterPassiveListenerCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.event.RequestPushEvent} [response] RequestPushEvent
             */

            /**
             * Calls RegisterPassiveListener.
             * @function registerPassiveListener
             * @memberof kritor.event.EventService
             * @instance
             * @param {kritor.event.IEventStructure} request EventStructure message or plain object
             * @param {kritor.event.EventService.RegisterPassiveListenerCallback} callback Node-style callback called with the error, if any, and RequestPushEvent
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(EventService.prototype.registerPassiveListener = function registerPassiveListener(request, callback) {
                return this.rpcCall(registerPassiveListener, $root.kritor.event.EventStructure, $root.kritor.event.RequestPushEvent, request, callback);
            }, "name", { value: "RegisterPassiveListener" });

            /**
             * Calls RegisterPassiveListener.
             * @function registerPassiveListener
             * @memberof kritor.event.EventService
             * @instance
             * @param {kritor.event.IEventStructure} request EventStructure message or plain object
             * @returns {Promise<kritor.event.RequestPushEvent>} Promise
             * @variation 2
             */

            return EventService;
        })();

        /**
         * EventType enum.
         * @name kritor.event.EventType
         * @enum {number}
         * @property {number} EVENT_TYPE_CORE_EVENT=0 EVENT_TYPE_CORE_EVENT value
         * @property {number} EVENT_TYPE_MESSAGE=1 EVENT_TYPE_MESSAGE value
         * @property {number} EVENT_TYPE_NOTICE=2 EVENT_TYPE_NOTICE value
         * @property {number} EVENT_TYPE_REQUEST=3 EVENT_TYPE_REQUEST value
         */
        event.EventType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "EVENT_TYPE_CORE_EVENT"] = 0;
            values[valuesById[1] = "EVENT_TYPE_MESSAGE"] = 1;
            values[valuesById[2] = "EVENT_TYPE_NOTICE"] = 2;
            values[valuesById[3] = "EVENT_TYPE_REQUEST"] = 3;
            return values;
        })();

        event.RequestPushEvent = (function() {

            /**
             * Properties of a RequestPushEvent.
             * @memberof kritor.event
             * @interface IRequestPushEvent
             * @property {kritor.event.EventType|null} [type] RequestPushEvent type
             */

            /**
             * Constructs a new RequestPushEvent.
             * @memberof kritor.event
             * @classdesc Represents a RequestPushEvent.
             * @implements IRequestPushEvent
             * @constructor
             * @param {kritor.event.IRequestPushEvent=} [properties] Properties to set
             */
            function RequestPushEvent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RequestPushEvent type.
             * @member {kritor.event.EventType} type
             * @memberof kritor.event.RequestPushEvent
             * @instance
             */
            RequestPushEvent.prototype.type = 0;

            /**
             * Creates a new RequestPushEvent instance using the specified properties.
             * @function create
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {kritor.event.IRequestPushEvent=} [properties] Properties to set
             * @returns {kritor.event.RequestPushEvent} RequestPushEvent instance
             */
            RequestPushEvent.create = function create(properties) {
                return new RequestPushEvent(properties);
            };

            /**
             * Encodes the specified RequestPushEvent message. Does not implicitly {@link kritor.event.RequestPushEvent.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {kritor.event.IRequestPushEvent} message RequestPushEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestPushEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified RequestPushEvent message, length delimited. Does not implicitly {@link kritor.event.RequestPushEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {kritor.event.IRequestPushEvent} message RequestPushEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestPushEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RequestPushEvent message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.RequestPushEvent} RequestPushEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestPushEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.RequestPushEvent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RequestPushEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.RequestPushEvent} RequestPushEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestPushEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RequestPushEvent message.
             * @function verify
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RequestPushEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates a RequestPushEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.RequestPushEvent} RequestPushEvent
             */
            RequestPushEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.RequestPushEvent)
                    return object;
                let message = new $root.kritor.event.RequestPushEvent();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "EVENT_TYPE_CORE_EVENT":
                case 0:
                    message.type = 0;
                    break;
                case "EVENT_TYPE_MESSAGE":
                case 1:
                    message.type = 1;
                    break;
                case "EVENT_TYPE_NOTICE":
                case 2:
                    message.type = 2;
                    break;
                case "EVENT_TYPE_REQUEST":
                case 3:
                    message.type = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a RequestPushEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {kritor.event.RequestPushEvent} message RequestPushEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RequestPushEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "EVENT_TYPE_CORE_EVENT" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.EventType[message.type] === undefined ? message.type : $root.kritor.event.EventType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this RequestPushEvent to JSON.
             * @function toJSON
             * @memberof kritor.event.RequestPushEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RequestPushEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RequestPushEvent
             * @function getTypeUrl
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RequestPushEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.RequestPushEvent";
            };

            return RequestPushEvent;
        })();

        event.EventStructure = (function() {

            /**
             * Properties of an EventStructure.
             * @memberof kritor.event
             * @interface IEventStructure
             * @property {kritor.event.EventType|null} [type] EventStructure type
             * @property {kritor.common.IPushMessageBody|null} [message] EventStructure message
             * @property {kritor.event.IRequestEvent|null} [request] EventStructure request
             * @property {kritor.event.INoticeEvent|null} [notice] EventStructure notice
             */

            /**
             * Constructs a new EventStructure.
             * @memberof kritor.event
             * @classdesc Represents an EventStructure.
             * @implements IEventStructure
             * @constructor
             * @param {kritor.event.IEventStructure=} [properties] Properties to set
             */
            function EventStructure(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EventStructure type.
             * @member {kritor.event.EventType} type
             * @memberof kritor.event.EventStructure
             * @instance
             */
            EventStructure.prototype.type = 0;

            /**
             * EventStructure message.
             * @member {kritor.common.IPushMessageBody|null|undefined} message
             * @memberof kritor.event.EventStructure
             * @instance
             */
            EventStructure.prototype.message = null;

            /**
             * EventStructure request.
             * @member {kritor.event.IRequestEvent|null|undefined} request
             * @memberof kritor.event.EventStructure
             * @instance
             */
            EventStructure.prototype.request = null;

            /**
             * EventStructure notice.
             * @member {kritor.event.INoticeEvent|null|undefined} notice
             * @memberof kritor.event.EventStructure
             * @instance
             */
            EventStructure.prototype.notice = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * EventStructure event.
             * @member {"message"|"request"|"notice"|undefined} event
             * @memberof kritor.event.EventStructure
             * @instance
             */
            Object.defineProperty(EventStructure.prototype, "event", {
                get: $util.oneOfGetter($oneOfFields = ["message", "request", "notice"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new EventStructure instance using the specified properties.
             * @function create
             * @memberof kritor.event.EventStructure
             * @static
             * @param {kritor.event.IEventStructure=} [properties] Properties to set
             * @returns {kritor.event.EventStructure} EventStructure instance
             */
            EventStructure.create = function create(properties) {
                return new EventStructure(properties);
            };

            /**
             * Encodes the specified EventStructure message. Does not implicitly {@link kritor.event.EventStructure.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.EventStructure
             * @static
             * @param {kritor.event.IEventStructure} message EventStructure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EventStructure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.kritor.common.PushMessageBody.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.request != null && Object.hasOwnProperty.call(message, "request"))
                    $root.kritor.event.RequestEvent.encode(message.request, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.notice != null && Object.hasOwnProperty.call(message, "notice"))
                    $root.kritor.event.NoticeEvent.encode(message.notice, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EventStructure message, length delimited. Does not implicitly {@link kritor.event.EventStructure.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.EventStructure
             * @static
             * @param {kritor.event.IEventStructure} message EventStructure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EventStructure.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EventStructure message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.EventStructure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.EventStructure} EventStructure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EventStructure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.EventStructure();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.message = $root.kritor.common.PushMessageBody.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.request = $root.kritor.event.RequestEvent.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.notice = $root.kritor.event.NoticeEvent.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EventStructure message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.EventStructure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.EventStructure} EventStructure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EventStructure.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EventStructure message.
             * @function verify
             * @memberof kritor.event.EventStructure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EventStructure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.message != null && message.hasOwnProperty("message")) {
                    properties.event = 1;
                    {
                        let error = $root.kritor.common.PushMessageBody.verify(message.message);
                        if (error)
                            return "message." + error;
                    }
                }
                if (message.request != null && message.hasOwnProperty("request")) {
                    if (properties.event === 1)
                        return "event: multiple values";
                    properties.event = 1;
                    {
                        let error = $root.kritor.event.RequestEvent.verify(message.request);
                        if (error)
                            return "request." + error;
                    }
                }
                if (message.notice != null && message.hasOwnProperty("notice")) {
                    if (properties.event === 1)
                        return "event: multiple values";
                    properties.event = 1;
                    {
                        let error = $root.kritor.event.NoticeEvent.verify(message.notice);
                        if (error)
                            return "notice." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EventStructure message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.EventStructure
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.EventStructure} EventStructure
             */
            EventStructure.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.EventStructure)
                    return object;
                let message = new $root.kritor.event.EventStructure();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "EVENT_TYPE_CORE_EVENT":
                case 0:
                    message.type = 0;
                    break;
                case "EVENT_TYPE_MESSAGE":
                case 1:
                    message.type = 1;
                    break;
                case "EVENT_TYPE_NOTICE":
                case 2:
                    message.type = 2;
                    break;
                case "EVENT_TYPE_REQUEST":
                case 3:
                    message.type = 3;
                    break;
                }
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".kritor.event.EventStructure.message: object expected");
                    message.message = $root.kritor.common.PushMessageBody.fromObject(object.message);
                }
                if (object.request != null) {
                    if (typeof object.request !== "object")
                        throw TypeError(".kritor.event.EventStructure.request: object expected");
                    message.request = $root.kritor.event.RequestEvent.fromObject(object.request);
                }
                if (object.notice != null) {
                    if (typeof object.notice !== "object")
                        throw TypeError(".kritor.event.EventStructure.notice: object expected");
                    message.notice = $root.kritor.event.NoticeEvent.fromObject(object.notice);
                }
                return message;
            };

            /**
             * Creates a plain object from an EventStructure message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.EventStructure
             * @static
             * @param {kritor.event.EventStructure} message EventStructure
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EventStructure.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "EVENT_TYPE_CORE_EVENT" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.EventType[message.type] === undefined ? message.type : $root.kritor.event.EventType[message.type] : message.type;
                if (message.message != null && message.hasOwnProperty("message")) {
                    object.message = $root.kritor.common.PushMessageBody.toObject(message.message, options);
                    if (options.oneofs)
                        object.event = "message";
                }
                if (message.request != null && message.hasOwnProperty("request")) {
                    object.request = $root.kritor.event.RequestEvent.toObject(message.request, options);
                    if (options.oneofs)
                        object.event = "request";
                }
                if (message.notice != null && message.hasOwnProperty("notice")) {
                    object.notice = $root.kritor.event.NoticeEvent.toObject(message.notice, options);
                    if (options.oneofs)
                        object.event = "notice";
                }
                return object;
            };

            /**
             * Converts this EventStructure to JSON.
             * @function toJSON
             * @memberof kritor.event.EventStructure
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EventStructure.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EventStructure
             * @function getTypeUrl
             * @memberof kritor.event.EventStructure
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EventStructure.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.EventStructure";
            };

            return EventStructure;
        })();

        event.NoticeEvent = (function() {

            /**
             * Properties of a NoticeEvent.
             * @memberof kritor.event
             * @interface INoticeEvent
             * @property {kritor.event.NoticeEvent.NoticeType|null} [type] NoticeEvent type
             * @property {number|null} [time] NoticeEvent time
             * @property {string|null} [notice_id] NoticeEvent notice_id
             * @property {kritor.event.IFriendPokeNotice|null} [friend_poke] NoticeEvent friend_poke
             * @property {kritor.event.IFriendRecallNotice|null} [friend_recall] NoticeEvent friend_recall
             * @property {kritor.event.IFriendFileUploadedNotice|null} [friend_file_uploaded] NoticeEvent friend_file_uploaded
             * @property {kritor.event.IGroupPokeNotice|null} [group_poke] NoticeEvent group_poke
             * @property {kritor.event.IGroupCardChangedNotice|null} [group_card_changed] NoticeEvent group_card_changed
             * @property {kritor.event.IGroupUniqueTitleChangedNotice|null} [group_member_unique_title_changed] NoticeEvent group_member_unique_title_changed
             * @property {kritor.event.IGroupEssenceMessageNotice|null} [group_essence_changed] NoticeEvent group_essence_changed
             * @property {kritor.event.IGroupRecallNotice|null} [group_recall] NoticeEvent group_recall
             * @property {kritor.event.IGroupMemberIncreasedNotice|null} [group_member_increase] NoticeEvent group_member_increase
             * @property {kritor.event.IGroupMemberDecreasedNotice|null} [group_member_decrease] NoticeEvent group_member_decrease
             * @property {kritor.event.IGroupAdminChangedNotice|null} [group_admin_change] NoticeEvent group_admin_change
             * @property {kritor.event.IGroupMemberBanNotice|null} [group_member_ban] NoticeEvent group_member_ban
             * @property {kritor.event.IGroupSignInNotice|null} [group_sign_in] NoticeEvent group_sign_in
             * @property {kritor.event.IGroupWholeBanNotice|null} [group_whole_ban] NoticeEvent group_whole_ban
             * @property {kritor.event.IGroupFileUploadedNotice|null} [group_file_uploaded] NoticeEvent group_file_uploaded
             */

            /**
             * Constructs a new NoticeEvent.
             * @memberof kritor.event
             * @classdesc Represents a NoticeEvent.
             * @implements INoticeEvent
             * @constructor
             * @param {kritor.event.INoticeEvent=} [properties] Properties to set
             */
            function NoticeEvent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NoticeEvent type.
             * @member {kritor.event.NoticeEvent.NoticeType} type
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.type = 0;

            /**
             * NoticeEvent time.
             * @member {number} time
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.time = 0;

            /**
             * NoticeEvent notice_id.
             * @member {string} notice_id
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.notice_id = "";

            /**
             * NoticeEvent friend_poke.
             * @member {kritor.event.IFriendPokeNotice|null|undefined} friend_poke
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.friend_poke = null;

            /**
             * NoticeEvent friend_recall.
             * @member {kritor.event.IFriendRecallNotice|null|undefined} friend_recall
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.friend_recall = null;

            /**
             * NoticeEvent friend_file_uploaded.
             * @member {kritor.event.IFriendFileUploadedNotice|null|undefined} friend_file_uploaded
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.friend_file_uploaded = null;

            /**
             * NoticeEvent group_poke.
             * @member {kritor.event.IGroupPokeNotice|null|undefined} group_poke
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.group_poke = null;

            /**
             * NoticeEvent group_card_changed.
             * @member {kritor.event.IGroupCardChangedNotice|null|undefined} group_card_changed
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.group_card_changed = null;

            /**
             * NoticeEvent group_member_unique_title_changed.
             * @member {kritor.event.IGroupUniqueTitleChangedNotice|null|undefined} group_member_unique_title_changed
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.group_member_unique_title_changed = null;

            /**
             * NoticeEvent group_essence_changed.
             * @member {kritor.event.IGroupEssenceMessageNotice|null|undefined} group_essence_changed
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.group_essence_changed = null;

            /**
             * NoticeEvent group_recall.
             * @member {kritor.event.IGroupRecallNotice|null|undefined} group_recall
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.group_recall = null;

            /**
             * NoticeEvent group_member_increase.
             * @member {kritor.event.IGroupMemberIncreasedNotice|null|undefined} group_member_increase
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.group_member_increase = null;

            /**
             * NoticeEvent group_member_decrease.
             * @member {kritor.event.IGroupMemberDecreasedNotice|null|undefined} group_member_decrease
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.group_member_decrease = null;

            /**
             * NoticeEvent group_admin_change.
             * @member {kritor.event.IGroupAdminChangedNotice|null|undefined} group_admin_change
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.group_admin_change = null;

            /**
             * NoticeEvent group_member_ban.
             * @member {kritor.event.IGroupMemberBanNotice|null|undefined} group_member_ban
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.group_member_ban = null;

            /**
             * NoticeEvent group_sign_in.
             * @member {kritor.event.IGroupSignInNotice|null|undefined} group_sign_in
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.group_sign_in = null;

            /**
             * NoticeEvent group_whole_ban.
             * @member {kritor.event.IGroupWholeBanNotice|null|undefined} group_whole_ban
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.group_whole_ban = null;

            /**
             * NoticeEvent group_file_uploaded.
             * @member {kritor.event.IGroupFileUploadedNotice|null|undefined} group_file_uploaded
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.group_file_uploaded = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * NoticeEvent notice.
             * @member {"friend_poke"|"friend_recall"|"friend_file_uploaded"|"group_poke"|"group_card_changed"|"group_member_unique_title_changed"|"group_essence_changed"|"group_recall"|"group_member_increase"|"group_member_decrease"|"group_admin_change"|"group_member_ban"|"group_sign_in"|"group_whole_ban"|"group_file_uploaded"|undefined} notice
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            Object.defineProperty(NoticeEvent.prototype, "notice", {
                get: $util.oneOfGetter($oneOfFields = ["friend_poke", "friend_recall", "friend_file_uploaded", "group_poke", "group_card_changed", "group_member_unique_title_changed", "group_essence_changed", "group_recall", "group_member_increase", "group_member_decrease", "group_admin_change", "group_member_ban", "group_sign_in", "group_whole_ban", "group_file_uploaded"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new NoticeEvent instance using the specified properties.
             * @function create
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {kritor.event.INoticeEvent=} [properties] Properties to set
             * @returns {kritor.event.NoticeEvent} NoticeEvent instance
             */
            NoticeEvent.create = function create(properties) {
                return new NoticeEvent(properties);
            };

            /**
             * Encodes the specified NoticeEvent message. Does not implicitly {@link kritor.event.NoticeEvent.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {kritor.event.INoticeEvent} message NoticeEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NoticeEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.time);
                if (message.notice_id != null && Object.hasOwnProperty.call(message, "notice_id"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.notice_id);
                if (message.friend_poke != null && Object.hasOwnProperty.call(message, "friend_poke"))
                    $root.kritor.event.FriendPokeNotice.encode(message.friend_poke, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.friend_recall != null && Object.hasOwnProperty.call(message, "friend_recall"))
                    $root.kritor.event.FriendRecallNotice.encode(message.friend_recall, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.friend_file_uploaded != null && Object.hasOwnProperty.call(message, "friend_file_uploaded"))
                    $root.kritor.event.FriendFileUploadedNotice.encode(message.friend_file_uploaded, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.group_poke != null && Object.hasOwnProperty.call(message, "group_poke"))
                    $root.kritor.event.GroupPokeNotice.encode(message.group_poke, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.group_card_changed != null && Object.hasOwnProperty.call(message, "group_card_changed"))
                    $root.kritor.event.GroupCardChangedNotice.encode(message.group_card_changed, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.group_member_unique_title_changed != null && Object.hasOwnProperty.call(message, "group_member_unique_title_changed"))
                    $root.kritor.event.GroupUniqueTitleChangedNotice.encode(message.group_member_unique_title_changed, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.group_essence_changed != null && Object.hasOwnProperty.call(message, "group_essence_changed"))
                    $root.kritor.event.GroupEssenceMessageNotice.encode(message.group_essence_changed, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                if (message.group_recall != null && Object.hasOwnProperty.call(message, "group_recall"))
                    $root.kritor.event.GroupRecallNotice.encode(message.group_recall, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                if (message.group_member_increase != null && Object.hasOwnProperty.call(message, "group_member_increase"))
                    $root.kritor.event.GroupMemberIncreasedNotice.encode(message.group_member_increase, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                if (message.group_member_decrease != null && Object.hasOwnProperty.call(message, "group_member_decrease"))
                    $root.kritor.event.GroupMemberDecreasedNotice.encode(message.group_member_decrease, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                if (message.group_admin_change != null && Object.hasOwnProperty.call(message, "group_admin_change"))
                    $root.kritor.event.GroupAdminChangedNotice.encode(message.group_admin_change, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
                if (message.group_member_ban != null && Object.hasOwnProperty.call(message, "group_member_ban"))
                    $root.kritor.event.GroupMemberBanNotice.encode(message.group_member_ban, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
                if (message.group_sign_in != null && Object.hasOwnProperty.call(message, "group_sign_in"))
                    $root.kritor.event.GroupSignInNotice.encode(message.group_sign_in, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
                if (message.group_whole_ban != null && Object.hasOwnProperty.call(message, "group_whole_ban"))
                    $root.kritor.event.GroupWholeBanNotice.encode(message.group_whole_ban, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
                if (message.group_file_uploaded != null && Object.hasOwnProperty.call(message, "group_file_uploaded"))
                    $root.kritor.event.GroupFileUploadedNotice.encode(message.group_file_uploaded, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NoticeEvent message, length delimited. Does not implicitly {@link kritor.event.NoticeEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {kritor.event.INoticeEvent} message NoticeEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NoticeEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NoticeEvent message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.NoticeEvent} NoticeEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NoticeEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.NoticeEvent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.time = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.notice_id = reader.string();
                            break;
                        }
                    case 10: {
                            message.friend_poke = $root.kritor.event.FriendPokeNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.friend_recall = $root.kritor.event.FriendRecallNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.friend_file_uploaded = $root.kritor.event.FriendFileUploadedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 20: {
                            message.group_poke = $root.kritor.event.GroupPokeNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 21: {
                            message.group_card_changed = $root.kritor.event.GroupCardChangedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 22: {
                            message.group_member_unique_title_changed = $root.kritor.event.GroupUniqueTitleChangedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 23: {
                            message.group_essence_changed = $root.kritor.event.GroupEssenceMessageNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 24: {
                            message.group_recall = $root.kritor.event.GroupRecallNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 25: {
                            message.group_member_increase = $root.kritor.event.GroupMemberIncreasedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 26: {
                            message.group_member_decrease = $root.kritor.event.GroupMemberDecreasedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 27: {
                            message.group_admin_change = $root.kritor.event.GroupAdminChangedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 28: {
                            message.group_member_ban = $root.kritor.event.GroupMemberBanNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 29: {
                            message.group_sign_in = $root.kritor.event.GroupSignInNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 30: {
                            message.group_whole_ban = $root.kritor.event.GroupWholeBanNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 31: {
                            message.group_file_uploaded = $root.kritor.event.GroupFileUploadedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NoticeEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.NoticeEvent} NoticeEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NoticeEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NoticeEvent message.
             * @function verify
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NoticeEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 10:
                    case 11:
                    case 12:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                        break;
                    }
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time))
                        return "time: integer expected";
                if (message.notice_id != null && message.hasOwnProperty("notice_id"))
                    if (!$util.isString(message.notice_id))
                        return "notice_id: string expected";
                if (message.friend_poke != null && message.hasOwnProperty("friend_poke")) {
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.FriendPokeNotice.verify(message.friend_poke);
                        if (error)
                            return "friend_poke." + error;
                    }
                }
                if (message.friend_recall != null && message.hasOwnProperty("friend_recall")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.FriendRecallNotice.verify(message.friend_recall);
                        if (error)
                            return "friend_recall." + error;
                    }
                }
                if (message.friend_file_uploaded != null && message.hasOwnProperty("friend_file_uploaded")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.FriendFileUploadedNotice.verify(message.friend_file_uploaded);
                        if (error)
                            return "friend_file_uploaded." + error;
                    }
                }
                if (message.group_poke != null && message.hasOwnProperty("group_poke")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupPokeNotice.verify(message.group_poke);
                        if (error)
                            return "group_poke." + error;
                    }
                }
                if (message.group_card_changed != null && message.hasOwnProperty("group_card_changed")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupCardChangedNotice.verify(message.group_card_changed);
                        if (error)
                            return "group_card_changed." + error;
                    }
                }
                if (message.group_member_unique_title_changed != null && message.hasOwnProperty("group_member_unique_title_changed")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupUniqueTitleChangedNotice.verify(message.group_member_unique_title_changed);
                        if (error)
                            return "group_member_unique_title_changed." + error;
                    }
                }
                if (message.group_essence_changed != null && message.hasOwnProperty("group_essence_changed")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupEssenceMessageNotice.verify(message.group_essence_changed);
                        if (error)
                            return "group_essence_changed." + error;
                    }
                }
                if (message.group_recall != null && message.hasOwnProperty("group_recall")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupRecallNotice.verify(message.group_recall);
                        if (error)
                            return "group_recall." + error;
                    }
                }
                if (message.group_member_increase != null && message.hasOwnProperty("group_member_increase")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupMemberIncreasedNotice.verify(message.group_member_increase);
                        if (error)
                            return "group_member_increase." + error;
                    }
                }
                if (message.group_member_decrease != null && message.hasOwnProperty("group_member_decrease")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupMemberDecreasedNotice.verify(message.group_member_decrease);
                        if (error)
                            return "group_member_decrease." + error;
                    }
                }
                if (message.group_admin_change != null && message.hasOwnProperty("group_admin_change")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupAdminChangedNotice.verify(message.group_admin_change);
                        if (error)
                            return "group_admin_change." + error;
                    }
                }
                if (message.group_member_ban != null && message.hasOwnProperty("group_member_ban")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupMemberBanNotice.verify(message.group_member_ban);
                        if (error)
                            return "group_member_ban." + error;
                    }
                }
                if (message.group_sign_in != null && message.hasOwnProperty("group_sign_in")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupSignInNotice.verify(message.group_sign_in);
                        if (error)
                            return "group_sign_in." + error;
                    }
                }
                if (message.group_whole_ban != null && message.hasOwnProperty("group_whole_ban")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupWholeBanNotice.verify(message.group_whole_ban);
                        if (error)
                            return "group_whole_ban." + error;
                    }
                }
                if (message.group_file_uploaded != null && message.hasOwnProperty("group_file_uploaded")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupFileUploadedNotice.verify(message.group_file_uploaded);
                        if (error)
                            return "group_file_uploaded." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a NoticeEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.NoticeEvent} NoticeEvent
             */
            NoticeEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.NoticeEvent)
                    return object;
                let message = new $root.kritor.event.NoticeEvent();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "FRIEND_POKE":
                case 10:
                    message.type = 10;
                    break;
                case "FRIEND_RECALL":
                case 11:
                    message.type = 11;
                    break;
                case "FRIEND_FILE_COME":
                case 12:
                    message.type = 12;
                    break;
                case "GROUP_POKE":
                case 20:
                    message.type = 20;
                    break;
                case "GROUP_CARD_CHANGED":
                case 21:
                    message.type = 21;
                    break;
                case "GROUP_MEMBER_UNIQUE_TITLE_CHANGED":
                case 22:
                    message.type = 22;
                    break;
                case "GROUP_ESSENCE_CHANGED":
                case 23:
                    message.type = 23;
                    break;
                case "GROUP_RECALL":
                case 24:
                    message.type = 24;
                    break;
                case "GROUP_MEMBER_INCREASE":
                case 25:
                    message.type = 25;
                    break;
                case "GROUP_MEMBER_DECREASE":
                case 26:
                    message.type = 26;
                    break;
                case "GROUP_ADMIN_CHANGED":
                case 27:
                    message.type = 27;
                    break;
                case "GROUP_MEMBER_BANNED":
                case 28:
                    message.type = 28;
                    break;
                case "GROUP_SIGN":
                case 29:
                    message.type = 29;
                    break;
                case "GROUP_WHOLE_BAN":
                case 30:
                    message.type = 30;
                    break;
                case "GROUP_FILE_COME":
                case 31:
                    message.type = 31;
                    break;
                }
                if (object.time != null)
                    message.time = object.time >>> 0;
                if (object.notice_id != null)
                    message.notice_id = String(object.notice_id);
                if (object.friend_poke != null) {
                    if (typeof object.friend_poke !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.friend_poke: object expected");
                    message.friend_poke = $root.kritor.event.FriendPokeNotice.fromObject(object.friend_poke);
                }
                if (object.friend_recall != null) {
                    if (typeof object.friend_recall !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.friend_recall: object expected");
                    message.friend_recall = $root.kritor.event.FriendRecallNotice.fromObject(object.friend_recall);
                }
                if (object.friend_file_uploaded != null) {
                    if (typeof object.friend_file_uploaded !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.friend_file_uploaded: object expected");
                    message.friend_file_uploaded = $root.kritor.event.FriendFileUploadedNotice.fromObject(object.friend_file_uploaded);
                }
                if (object.group_poke != null) {
                    if (typeof object.group_poke !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.group_poke: object expected");
                    message.group_poke = $root.kritor.event.GroupPokeNotice.fromObject(object.group_poke);
                }
                if (object.group_card_changed != null) {
                    if (typeof object.group_card_changed !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.group_card_changed: object expected");
                    message.group_card_changed = $root.kritor.event.GroupCardChangedNotice.fromObject(object.group_card_changed);
                }
                if (object.group_member_unique_title_changed != null) {
                    if (typeof object.group_member_unique_title_changed !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.group_member_unique_title_changed: object expected");
                    message.group_member_unique_title_changed = $root.kritor.event.GroupUniqueTitleChangedNotice.fromObject(object.group_member_unique_title_changed);
                }
                if (object.group_essence_changed != null) {
                    if (typeof object.group_essence_changed !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.group_essence_changed: object expected");
                    message.group_essence_changed = $root.kritor.event.GroupEssenceMessageNotice.fromObject(object.group_essence_changed);
                }
                if (object.group_recall != null) {
                    if (typeof object.group_recall !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.group_recall: object expected");
                    message.group_recall = $root.kritor.event.GroupRecallNotice.fromObject(object.group_recall);
                }
                if (object.group_member_increase != null) {
                    if (typeof object.group_member_increase !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.group_member_increase: object expected");
                    message.group_member_increase = $root.kritor.event.GroupMemberIncreasedNotice.fromObject(object.group_member_increase);
                }
                if (object.group_member_decrease != null) {
                    if (typeof object.group_member_decrease !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.group_member_decrease: object expected");
                    message.group_member_decrease = $root.kritor.event.GroupMemberDecreasedNotice.fromObject(object.group_member_decrease);
                }
                if (object.group_admin_change != null) {
                    if (typeof object.group_admin_change !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.group_admin_change: object expected");
                    message.group_admin_change = $root.kritor.event.GroupAdminChangedNotice.fromObject(object.group_admin_change);
                }
                if (object.group_member_ban != null) {
                    if (typeof object.group_member_ban !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.group_member_ban: object expected");
                    message.group_member_ban = $root.kritor.event.GroupMemberBanNotice.fromObject(object.group_member_ban);
                }
                if (object.group_sign_in != null) {
                    if (typeof object.group_sign_in !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.group_sign_in: object expected");
                    message.group_sign_in = $root.kritor.event.GroupSignInNotice.fromObject(object.group_sign_in);
                }
                if (object.group_whole_ban != null) {
                    if (typeof object.group_whole_ban !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.group_whole_ban: object expected");
                    message.group_whole_ban = $root.kritor.event.GroupWholeBanNotice.fromObject(object.group_whole_ban);
                }
                if (object.group_file_uploaded != null) {
                    if (typeof object.group_file_uploaded !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.group_file_uploaded: object expected");
                    message.group_file_uploaded = $root.kritor.event.GroupFileUploadedNotice.fromObject(object.group_file_uploaded);
                }
                return message;
            };

            /**
             * Creates a plain object from a NoticeEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {kritor.event.NoticeEvent} message NoticeEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NoticeEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                    object.time = 0;
                    object.notice_id = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.NoticeEvent.NoticeType[message.type] === undefined ? message.type : $root.kritor.event.NoticeEvent.NoticeType[message.type] : message.type;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = message.time;
                if (message.notice_id != null && message.hasOwnProperty("notice_id"))
                    object.notice_id = message.notice_id;
                if (message.friend_poke != null && message.hasOwnProperty("friend_poke")) {
                    object.friend_poke = $root.kritor.event.FriendPokeNotice.toObject(message.friend_poke, options);
                    if (options.oneofs)
                        object.notice = "friend_poke";
                }
                if (message.friend_recall != null && message.hasOwnProperty("friend_recall")) {
                    object.friend_recall = $root.kritor.event.FriendRecallNotice.toObject(message.friend_recall, options);
                    if (options.oneofs)
                        object.notice = "friend_recall";
                }
                if (message.friend_file_uploaded != null && message.hasOwnProperty("friend_file_uploaded")) {
                    object.friend_file_uploaded = $root.kritor.event.FriendFileUploadedNotice.toObject(message.friend_file_uploaded, options);
                    if (options.oneofs)
                        object.notice = "friend_file_uploaded";
                }
                if (message.group_poke != null && message.hasOwnProperty("group_poke")) {
                    object.group_poke = $root.kritor.event.GroupPokeNotice.toObject(message.group_poke, options);
                    if (options.oneofs)
                        object.notice = "group_poke";
                }
                if (message.group_card_changed != null && message.hasOwnProperty("group_card_changed")) {
                    object.group_card_changed = $root.kritor.event.GroupCardChangedNotice.toObject(message.group_card_changed, options);
                    if (options.oneofs)
                        object.notice = "group_card_changed";
                }
                if (message.group_member_unique_title_changed != null && message.hasOwnProperty("group_member_unique_title_changed")) {
                    object.group_member_unique_title_changed = $root.kritor.event.GroupUniqueTitleChangedNotice.toObject(message.group_member_unique_title_changed, options);
                    if (options.oneofs)
                        object.notice = "group_member_unique_title_changed";
                }
                if (message.group_essence_changed != null && message.hasOwnProperty("group_essence_changed")) {
                    object.group_essence_changed = $root.kritor.event.GroupEssenceMessageNotice.toObject(message.group_essence_changed, options);
                    if (options.oneofs)
                        object.notice = "group_essence_changed";
                }
                if (message.group_recall != null && message.hasOwnProperty("group_recall")) {
                    object.group_recall = $root.kritor.event.GroupRecallNotice.toObject(message.group_recall, options);
                    if (options.oneofs)
                        object.notice = "group_recall";
                }
                if (message.group_member_increase != null && message.hasOwnProperty("group_member_increase")) {
                    object.group_member_increase = $root.kritor.event.GroupMemberIncreasedNotice.toObject(message.group_member_increase, options);
                    if (options.oneofs)
                        object.notice = "group_member_increase";
                }
                if (message.group_member_decrease != null && message.hasOwnProperty("group_member_decrease")) {
                    object.group_member_decrease = $root.kritor.event.GroupMemberDecreasedNotice.toObject(message.group_member_decrease, options);
                    if (options.oneofs)
                        object.notice = "group_member_decrease";
                }
                if (message.group_admin_change != null && message.hasOwnProperty("group_admin_change")) {
                    object.group_admin_change = $root.kritor.event.GroupAdminChangedNotice.toObject(message.group_admin_change, options);
                    if (options.oneofs)
                        object.notice = "group_admin_change";
                }
                if (message.group_member_ban != null && message.hasOwnProperty("group_member_ban")) {
                    object.group_member_ban = $root.kritor.event.GroupMemberBanNotice.toObject(message.group_member_ban, options);
                    if (options.oneofs)
                        object.notice = "group_member_ban";
                }
                if (message.group_sign_in != null && message.hasOwnProperty("group_sign_in")) {
                    object.group_sign_in = $root.kritor.event.GroupSignInNotice.toObject(message.group_sign_in, options);
                    if (options.oneofs)
                        object.notice = "group_sign_in";
                }
                if (message.group_whole_ban != null && message.hasOwnProperty("group_whole_ban")) {
                    object.group_whole_ban = $root.kritor.event.GroupWholeBanNotice.toObject(message.group_whole_ban, options);
                    if (options.oneofs)
                        object.notice = "group_whole_ban";
                }
                if (message.group_file_uploaded != null && message.hasOwnProperty("group_file_uploaded")) {
                    object.group_file_uploaded = $root.kritor.event.GroupFileUploadedNotice.toObject(message.group_file_uploaded, options);
                    if (options.oneofs)
                        object.notice = "group_file_uploaded";
                }
                return object;
            };

            /**
             * Converts this NoticeEvent to JSON.
             * @function toJSON
             * @memberof kritor.event.NoticeEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NoticeEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NoticeEvent
             * @function getTypeUrl
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NoticeEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.NoticeEvent";
            };

            /**
             * NoticeType enum.
             * @name kritor.event.NoticeEvent.NoticeType
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} FRIEND_POKE=10 FRIEND_POKE value
             * @property {number} FRIEND_RECALL=11 FRIEND_RECALL value
             * @property {number} FRIEND_FILE_COME=12 FRIEND_FILE_COME value
             * @property {number} GROUP_POKE=20 GROUP_POKE value
             * @property {number} GROUP_CARD_CHANGED=21 GROUP_CARD_CHANGED value
             * @property {number} GROUP_MEMBER_UNIQUE_TITLE_CHANGED=22 GROUP_MEMBER_UNIQUE_TITLE_CHANGED value
             * @property {number} GROUP_ESSENCE_CHANGED=23 GROUP_ESSENCE_CHANGED value
             * @property {number} GROUP_RECALL=24 GROUP_RECALL value
             * @property {number} GROUP_MEMBER_INCREASE=25 GROUP_MEMBER_INCREASE value
             * @property {number} GROUP_MEMBER_DECREASE=26 GROUP_MEMBER_DECREASE value
             * @property {number} GROUP_ADMIN_CHANGED=27 GROUP_ADMIN_CHANGED value
             * @property {number} GROUP_MEMBER_BANNED=28 GROUP_MEMBER_BANNED value
             * @property {number} GROUP_SIGN=29 GROUP_SIGN value
             * @property {number} GROUP_WHOLE_BAN=30 GROUP_WHOLE_BAN value
             * @property {number} GROUP_FILE_COME=31 GROUP_FILE_COME value
             */
            NoticeEvent.NoticeType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[10] = "FRIEND_POKE"] = 10;
                values[valuesById[11] = "FRIEND_RECALL"] = 11;
                values[valuesById[12] = "FRIEND_FILE_COME"] = 12;
                values[valuesById[20] = "GROUP_POKE"] = 20;
                values[valuesById[21] = "GROUP_CARD_CHANGED"] = 21;
                values[valuesById[22] = "GROUP_MEMBER_UNIQUE_TITLE_CHANGED"] = 22;
                values[valuesById[23] = "GROUP_ESSENCE_CHANGED"] = 23;
                values[valuesById[24] = "GROUP_RECALL"] = 24;
                values[valuesById[25] = "GROUP_MEMBER_INCREASE"] = 25;
                values[valuesById[26] = "GROUP_MEMBER_DECREASE"] = 26;
                values[valuesById[27] = "GROUP_ADMIN_CHANGED"] = 27;
                values[valuesById[28] = "GROUP_MEMBER_BANNED"] = 28;
                values[valuesById[29] = "GROUP_SIGN"] = 29;
                values[valuesById[30] = "GROUP_WHOLE_BAN"] = 30;
                values[valuesById[31] = "GROUP_FILE_COME"] = 31;
                return values;
            })();

            return NoticeEvent;
        })();

        event.FriendPokeNotice = (function() {

            /**
             * Properties of a FriendPokeNotice.
             * @memberof kritor.event
             * @interface IFriendPokeNotice
             * @property {string|null} [operator_uid] FriendPokeNotice operator_uid
             * @property {number|Long|null} [operator_uin] FriendPokeNotice operator_uin
             * @property {string|null} [action] FriendPokeNotice action
             * @property {string|null} [suffix] FriendPokeNotice suffix
             * @property {string|null} [action_image] FriendPokeNotice action_image
             */

            /**
             * Constructs a new FriendPokeNotice.
             * @memberof kritor.event
             * @classdesc Represents a FriendPokeNotice.
             * @implements IFriendPokeNotice
             * @constructor
             * @param {kritor.event.IFriendPokeNotice=} [properties] Properties to set
             */
            function FriendPokeNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendPokeNotice operator_uid.
             * @member {string} operator_uid
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             */
            FriendPokeNotice.prototype.operator_uid = "";

            /**
             * FriendPokeNotice operator_uin.
             * @member {number|Long} operator_uin
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             */
            FriendPokeNotice.prototype.operator_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendPokeNotice action.
             * @member {string} action
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             */
            FriendPokeNotice.prototype.action = "";

            /**
             * FriendPokeNotice suffix.
             * @member {string} suffix
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             */
            FriendPokeNotice.prototype.suffix = "";

            /**
             * FriendPokeNotice action_image.
             * @member {string} action_image
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             */
            FriendPokeNotice.prototype.action_image = "";

            /**
             * Creates a new FriendPokeNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {kritor.event.IFriendPokeNotice=} [properties] Properties to set
             * @returns {kritor.event.FriendPokeNotice} FriendPokeNotice instance
             */
            FriendPokeNotice.create = function create(properties) {
                return new FriendPokeNotice(properties);
            };

            /**
             * Encodes the specified FriendPokeNotice message. Does not implicitly {@link kritor.event.FriendPokeNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {kritor.event.IFriendPokeNotice} message FriendPokeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendPokeNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operator_uid != null && Object.hasOwnProperty.call(message, "operator_uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.operator_uid);
                if (message.operator_uin != null && Object.hasOwnProperty.call(message, "operator_uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.operator_uin);
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.action);
                if (message.suffix != null && Object.hasOwnProperty.call(message, "suffix"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.suffix);
                if (message.action_image != null && Object.hasOwnProperty.call(message, "action_image"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.action_image);
                return writer;
            };

            /**
             * Encodes the specified FriendPokeNotice message, length delimited. Does not implicitly {@link kritor.event.FriendPokeNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {kritor.event.IFriendPokeNotice} message FriendPokeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendPokeNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendPokeNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.FriendPokeNotice} FriendPokeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendPokeNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.FriendPokeNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.operator_uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.operator_uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.action = reader.string();
                            break;
                        }
                    case 4: {
                            message.suffix = reader.string();
                            break;
                        }
                    case 5: {
                            message.action_image = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendPokeNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.FriendPokeNotice} FriendPokeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendPokeNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendPokeNotice message.
             * @function verify
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendPokeNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    if (!$util.isString(message.operator_uid))
                        return "operator_uid: string expected";
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (!$util.isInteger(message.operator_uin) && !(message.operator_uin && $util.isInteger(message.operator_uin.low) && $util.isInteger(message.operator_uin.high)))
                        return "operator_uin: integer|Long expected";
                if (message.action != null && message.hasOwnProperty("action"))
                    if (!$util.isString(message.action))
                        return "action: string expected";
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    if (!$util.isString(message.suffix))
                        return "suffix: string expected";
                if (message.action_image != null && message.hasOwnProperty("action_image"))
                    if (!$util.isString(message.action_image))
                        return "action_image: string expected";
                return null;
            };

            /**
             * Creates a FriendPokeNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.FriendPokeNotice} FriendPokeNotice
             */
            FriendPokeNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.FriendPokeNotice)
                    return object;
                let message = new $root.kritor.event.FriendPokeNotice();
                if (object.operator_uid != null)
                    message.operator_uid = String(object.operator_uid);
                if (object.operator_uin != null)
                    if ($util.Long)
                        (message.operator_uin = $util.Long.fromValue(object.operator_uin)).unsigned = true;
                    else if (typeof object.operator_uin === "string")
                        message.operator_uin = parseInt(object.operator_uin, 10);
                    else if (typeof object.operator_uin === "number")
                        message.operator_uin = object.operator_uin;
                    else if (typeof object.operator_uin === "object")
                        message.operator_uin = new $util.LongBits(object.operator_uin.low >>> 0, object.operator_uin.high >>> 0).toNumber(true);
                if (object.action != null)
                    message.action = String(object.action);
                if (object.suffix != null)
                    message.suffix = String(object.suffix);
                if (object.action_image != null)
                    message.action_image = String(object.action_image);
                return message;
            };

            /**
             * Creates a plain object from a FriendPokeNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {kritor.event.FriendPokeNotice} message FriendPokeNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendPokeNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.operator_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator_uin = options.longs === String ? "0" : 0;
                    object.action = "";
                    object.suffix = "";
                    object.action_image = "";
                }
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    object.operator_uid = message.operator_uid;
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (typeof message.operator_uin === "number")
                        object.operator_uin = options.longs === String ? String(message.operator_uin) : message.operator_uin;
                    else
                        object.operator_uin = options.longs === String ? $util.Long.prototype.toString.call(message.operator_uin) : options.longs === Number ? new $util.LongBits(message.operator_uin.low >>> 0, message.operator_uin.high >>> 0).toNumber(true) : message.operator_uin;
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = message.action;
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    object.suffix = message.suffix;
                if (message.action_image != null && message.hasOwnProperty("action_image"))
                    object.action_image = message.action_image;
                return object;
            };

            /**
             * Converts this FriendPokeNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendPokeNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendPokeNotice
             * @function getTypeUrl
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendPokeNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.FriendPokeNotice";
            };

            return FriendPokeNotice;
        })();

        event.FriendRecallNotice = (function() {

            /**
             * Properties of a FriendRecallNotice.
             * @memberof kritor.event
             * @interface IFriendRecallNotice
             * @property {string|null} [operator_uid] FriendRecallNotice operator_uid
             * @property {number|Long|null} [operator_uin] FriendRecallNotice operator_uin
             * @property {string|null} [message_id] FriendRecallNotice message_id
             * @property {string|null} [tip_text] FriendRecallNotice tip_text
             */

            /**
             * Constructs a new FriendRecallNotice.
             * @memberof kritor.event
             * @classdesc Represents a FriendRecallNotice.
             * @implements IFriendRecallNotice
             * @constructor
             * @param {kritor.event.IFriendRecallNotice=} [properties] Properties to set
             */
            function FriendRecallNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendRecallNotice operator_uid.
             * @member {string} operator_uid
             * @memberof kritor.event.FriendRecallNotice
             * @instance
             */
            FriendRecallNotice.prototype.operator_uid = "";

            /**
             * FriendRecallNotice operator_uin.
             * @member {number|Long} operator_uin
             * @memberof kritor.event.FriendRecallNotice
             * @instance
             */
            FriendRecallNotice.prototype.operator_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendRecallNotice message_id.
             * @member {string} message_id
             * @memberof kritor.event.FriendRecallNotice
             * @instance
             */
            FriendRecallNotice.prototype.message_id = "";

            /**
             * FriendRecallNotice tip_text.
             * @member {string} tip_text
             * @memberof kritor.event.FriendRecallNotice
             * @instance
             */
            FriendRecallNotice.prototype.tip_text = "";

            /**
             * Creates a new FriendRecallNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {kritor.event.IFriendRecallNotice=} [properties] Properties to set
             * @returns {kritor.event.FriendRecallNotice} FriendRecallNotice instance
             */
            FriendRecallNotice.create = function create(properties) {
                return new FriendRecallNotice(properties);
            };

            /**
             * Encodes the specified FriendRecallNotice message. Does not implicitly {@link kritor.event.FriendRecallNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {kritor.event.IFriendRecallNotice} message FriendRecallNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendRecallNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operator_uid != null && Object.hasOwnProperty.call(message, "operator_uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.operator_uid);
                if (message.operator_uin != null && Object.hasOwnProperty.call(message, "operator_uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.operator_uin);
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.message_id);
                if (message.tip_text != null && Object.hasOwnProperty.call(message, "tip_text"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.tip_text);
                return writer;
            };

            /**
             * Encodes the specified FriendRecallNotice message, length delimited. Does not implicitly {@link kritor.event.FriendRecallNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {kritor.event.IFriendRecallNotice} message FriendRecallNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendRecallNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendRecallNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.FriendRecallNotice} FriendRecallNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendRecallNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.FriendRecallNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.operator_uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.operator_uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.message_id = reader.string();
                            break;
                        }
                    case 4: {
                            message.tip_text = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendRecallNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.FriendRecallNotice} FriendRecallNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendRecallNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendRecallNotice message.
             * @function verify
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendRecallNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    if (!$util.isString(message.operator_uid))
                        return "operator_uid: string expected";
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (!$util.isInteger(message.operator_uin) && !(message.operator_uin && $util.isInteger(message.operator_uin.low) && $util.isInteger(message.operator_uin.high)))
                        return "operator_uin: integer|Long expected";
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                if (message.tip_text != null && message.hasOwnProperty("tip_text"))
                    if (!$util.isString(message.tip_text))
                        return "tip_text: string expected";
                return null;
            };

            /**
             * Creates a FriendRecallNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.FriendRecallNotice} FriendRecallNotice
             */
            FriendRecallNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.FriendRecallNotice)
                    return object;
                let message = new $root.kritor.event.FriendRecallNotice();
                if (object.operator_uid != null)
                    message.operator_uid = String(object.operator_uid);
                if (object.operator_uin != null)
                    if ($util.Long)
                        (message.operator_uin = $util.Long.fromValue(object.operator_uin)).unsigned = true;
                    else if (typeof object.operator_uin === "string")
                        message.operator_uin = parseInt(object.operator_uin, 10);
                    else if (typeof object.operator_uin === "number")
                        message.operator_uin = object.operator_uin;
                    else if (typeof object.operator_uin === "object")
                        message.operator_uin = new $util.LongBits(object.operator_uin.low >>> 0, object.operator_uin.high >>> 0).toNumber(true);
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                if (object.tip_text != null)
                    message.tip_text = String(object.tip_text);
                return message;
            };

            /**
             * Creates a plain object from a FriendRecallNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {kritor.event.FriendRecallNotice} message FriendRecallNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendRecallNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.operator_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator_uin = options.longs === String ? "0" : 0;
                    object.message_id = "";
                    object.tip_text = "";
                }
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    object.operator_uid = message.operator_uid;
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (typeof message.operator_uin === "number")
                        object.operator_uin = options.longs === String ? String(message.operator_uin) : message.operator_uin;
                    else
                        object.operator_uin = options.longs === String ? $util.Long.prototype.toString.call(message.operator_uin) : options.longs === Number ? new $util.LongBits(message.operator_uin.low >>> 0, message.operator_uin.high >>> 0).toNumber(true) : message.operator_uin;
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    object.message_id = message.message_id;
                if (message.tip_text != null && message.hasOwnProperty("tip_text"))
                    object.tip_text = message.tip_text;
                return object;
            };

            /**
             * Converts this FriendRecallNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.FriendRecallNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendRecallNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendRecallNotice
             * @function getTypeUrl
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendRecallNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.FriendRecallNotice";
            };

            return FriendRecallNotice;
        })();

        event.GroupUniqueTitleChangedNotice = (function() {

            /**
             * Properties of a GroupUniqueTitleChangedNotice.
             * @memberof kritor.event
             * @interface IGroupUniqueTitleChangedNotice
             * @property {number|Long|null} [target] GroupUniqueTitleChangedNotice target
             * @property {string|null} [title] GroupUniqueTitleChangedNotice title
             * @property {number|Long|null} [group_id] GroupUniqueTitleChangedNotice group_id
             */

            /**
             * Constructs a new GroupUniqueTitleChangedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupUniqueTitleChangedNotice.
             * @implements IGroupUniqueTitleChangedNotice
             * @constructor
             * @param {kritor.event.IGroupUniqueTitleChangedNotice=} [properties] Properties to set
             */
            function GroupUniqueTitleChangedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupUniqueTitleChangedNotice target.
             * @member {number|Long} target
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @instance
             */
            GroupUniqueTitleChangedNotice.prototype.target = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupUniqueTitleChangedNotice title.
             * @member {string} title
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @instance
             */
            GroupUniqueTitleChangedNotice.prototype.title = "";

            /**
             * GroupUniqueTitleChangedNotice group_id.
             * @member {number|Long} group_id
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @instance
             */
            GroupUniqueTitleChangedNotice.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GroupUniqueTitleChangedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {kritor.event.IGroupUniqueTitleChangedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupUniqueTitleChangedNotice} GroupUniqueTitleChangedNotice instance
             */
            GroupUniqueTitleChangedNotice.create = function create(properties) {
                return new GroupUniqueTitleChangedNotice(properties);
            };

            /**
             * Encodes the specified GroupUniqueTitleChangedNotice message. Does not implicitly {@link kritor.event.GroupUniqueTitleChangedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {kritor.event.IGroupUniqueTitleChangedNotice} message GroupUniqueTitleChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupUniqueTitleChangedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.target);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.group_id);
                return writer;
            };

            /**
             * Encodes the specified GroupUniqueTitleChangedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupUniqueTitleChangedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {kritor.event.IGroupUniqueTitleChangedNotice} message GroupUniqueTitleChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupUniqueTitleChangedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupUniqueTitleChangedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupUniqueTitleChangedNotice} GroupUniqueTitleChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupUniqueTitleChangedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupUniqueTitleChangedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.target = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.title = reader.string();
                            break;
                        }
                    case 3: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupUniqueTitleChangedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupUniqueTitleChangedNotice} GroupUniqueTitleChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupUniqueTitleChangedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupUniqueTitleChangedNotice message.
             * @function verify
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupUniqueTitleChangedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.target != null && message.hasOwnProperty("target"))
                    if (!$util.isInteger(message.target) && !(message.target && $util.isInteger(message.target.low) && $util.isInteger(message.target.high)))
                        return "target: integer|Long expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                return null;
            };

            /**
             * Creates a GroupUniqueTitleChangedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupUniqueTitleChangedNotice} GroupUniqueTitleChangedNotice
             */
            GroupUniqueTitleChangedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupUniqueTitleChangedNotice)
                    return object;
                let message = new $root.kritor.event.GroupUniqueTitleChangedNotice();
                if (object.target != null)
                    if ($util.Long)
                        (message.target = $util.Long.fromValue(object.target)).unsigned = true;
                    else if (typeof object.target === "string")
                        message.target = parseInt(object.target, 10);
                    else if (typeof object.target === "number")
                        message.target = object.target;
                    else if (typeof object.target === "object")
                        message.target = new $util.LongBits(object.target.low >>> 0, object.target.high >>> 0).toNumber(true);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GroupUniqueTitleChangedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {kritor.event.GroupUniqueTitleChangedNotice} message GroupUniqueTitleChangedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupUniqueTitleChangedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.target = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.target = options.longs === String ? "0" : 0;
                    object.title = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                }
                if (message.target != null && message.hasOwnProperty("target"))
                    if (typeof message.target === "number")
                        object.target = options.longs === String ? String(message.target) : message.target;
                    else
                        object.target = options.longs === String ? $util.Long.prototype.toString.call(message.target) : options.longs === Number ? new $util.LongBits(message.target.low >>> 0, message.target.high >>> 0).toNumber(true) : message.target;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                return object;
            };

            /**
             * Converts this GroupUniqueTitleChangedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupUniqueTitleChangedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupUniqueTitleChangedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupUniqueTitleChangedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupUniqueTitleChangedNotice";
            };

            return GroupUniqueTitleChangedNotice;
        })();

        event.GroupEssenceMessageNotice = (function() {

            /**
             * Properties of a GroupEssenceMessageNotice.
             * @memberof kritor.event
             * @interface IGroupEssenceMessageNotice
             * @property {number|Long|null} [group_id] GroupEssenceMessageNotice group_id
             * @property {string|null} [operator_uid] GroupEssenceMessageNotice operator_uid
             * @property {number|Long|null} [operator_uin] GroupEssenceMessageNotice operator_uin
             * @property {string|null} [target_uid] GroupEssenceMessageNotice target_uid
             * @property {number|Long|null} [target_uin] GroupEssenceMessageNotice target_uin
             * @property {string|null} [message_id] GroupEssenceMessageNotice message_id
             * @property {number|null} [sub_type] GroupEssenceMessageNotice sub_type
             */

            /**
             * Constructs a new GroupEssenceMessageNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupEssenceMessageNotice.
             * @implements IGroupEssenceMessageNotice
             * @constructor
             * @param {kritor.event.IGroupEssenceMessageNotice=} [properties] Properties to set
             */
            function GroupEssenceMessageNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupEssenceMessageNotice group_id.
             * @member {number|Long} group_id
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             */
            GroupEssenceMessageNotice.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupEssenceMessageNotice operator_uid.
             * @member {string} operator_uid
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             */
            GroupEssenceMessageNotice.prototype.operator_uid = "";

            /**
             * GroupEssenceMessageNotice operator_uin.
             * @member {number|Long} operator_uin
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             */
            GroupEssenceMessageNotice.prototype.operator_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupEssenceMessageNotice target_uid.
             * @member {string} target_uid
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             */
            GroupEssenceMessageNotice.prototype.target_uid = "";

            /**
             * GroupEssenceMessageNotice target_uin.
             * @member {number|Long} target_uin
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             */
            GroupEssenceMessageNotice.prototype.target_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupEssenceMessageNotice message_id.
             * @member {string} message_id
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             */
            GroupEssenceMessageNotice.prototype.message_id = "";

            /**
             * GroupEssenceMessageNotice sub_type.
             * @member {number} sub_type
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             */
            GroupEssenceMessageNotice.prototype.sub_type = 0;

            /**
             * Creates a new GroupEssenceMessageNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {kritor.event.IGroupEssenceMessageNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupEssenceMessageNotice} GroupEssenceMessageNotice instance
             */
            GroupEssenceMessageNotice.create = function create(properties) {
                return new GroupEssenceMessageNotice(properties);
            };

            /**
             * Encodes the specified GroupEssenceMessageNotice message. Does not implicitly {@link kritor.event.GroupEssenceMessageNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {kritor.event.IGroupEssenceMessageNotice} message GroupEssenceMessageNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupEssenceMessageNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.operator_uid != null && Object.hasOwnProperty.call(message, "operator_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operator_uid);
                if (message.operator_uin != null && Object.hasOwnProperty.call(message, "operator_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operator_uin);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.target_uin);
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.message_id);
                if (message.sub_type != null && Object.hasOwnProperty.call(message, "sub_type"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.sub_type);
                return writer;
            };

            /**
             * Encodes the specified GroupEssenceMessageNotice message, length delimited. Does not implicitly {@link kritor.event.GroupEssenceMessageNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {kritor.event.IGroupEssenceMessageNotice} message GroupEssenceMessageNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupEssenceMessageNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupEssenceMessageNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupEssenceMessageNotice} GroupEssenceMessageNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupEssenceMessageNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupEssenceMessageNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operator_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operator_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 5: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.message_id = reader.string();
                            break;
                        }
                    case 7: {
                            message.sub_type = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupEssenceMessageNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupEssenceMessageNotice} GroupEssenceMessageNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupEssenceMessageNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupEssenceMessageNotice message.
             * @function verify
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupEssenceMessageNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    if (!$util.isString(message.operator_uid))
                        return "operator_uid: string expected";
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (!$util.isInteger(message.operator_uin) && !(message.operator_uin && $util.isInteger(message.operator_uin.low) && $util.isInteger(message.operator_uin.high)))
                        return "operator_uin: integer|Long expected";
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                if (message.sub_type != null && message.hasOwnProperty("sub_type"))
                    if (!$util.isInteger(message.sub_type))
                        return "sub_type: integer expected";
                return null;
            };

            /**
             * Creates a GroupEssenceMessageNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupEssenceMessageNotice} GroupEssenceMessageNotice
             */
            GroupEssenceMessageNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupEssenceMessageNotice)
                    return object;
                let message = new $root.kritor.event.GroupEssenceMessageNotice();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.operator_uid != null)
                    message.operator_uid = String(object.operator_uid);
                if (object.operator_uin != null)
                    if ($util.Long)
                        (message.operator_uin = $util.Long.fromValue(object.operator_uin)).unsigned = true;
                    else if (typeof object.operator_uin === "string")
                        message.operator_uin = parseInt(object.operator_uin, 10);
                    else if (typeof object.operator_uin === "number")
                        message.operator_uin = object.operator_uin;
                    else if (typeof object.operator_uin === "object")
                        message.operator_uin = new $util.LongBits(object.operator_uin.low >>> 0, object.operator_uin.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                if (object.sub_type != null)
                    message.sub_type = object.sub_type >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GroupEssenceMessageNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {kritor.event.GroupEssenceMessageNotice} message GroupEssenceMessageNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupEssenceMessageNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.operator_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator_uin = options.longs === String ? "0" : 0;
                    object.target_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.target_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.target_uin = options.longs === String ? "0" : 0;
                    object.message_id = "";
                    object.sub_type = 0;
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    object.operator_uid = message.operator_uid;
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (typeof message.operator_uin === "number")
                        object.operator_uin = options.longs === String ? String(message.operator_uin) : message.operator_uin;
                    else
                        object.operator_uin = options.longs === String ? $util.Long.prototype.toString.call(message.operator_uin) : options.longs === Number ? new $util.LongBits(message.operator_uin.low >>> 0, message.operator_uin.high >>> 0).toNumber(true) : message.operator_uin;
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    object.target_uid = message.target_uid;
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    object.message_id = message.message_id;
                if (message.sub_type != null && message.hasOwnProperty("sub_type"))
                    object.sub_type = message.sub_type;
                return object;
            };

            /**
             * Converts this GroupEssenceMessageNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupEssenceMessageNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupEssenceMessageNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupEssenceMessageNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupEssenceMessageNotice";
            };

            return GroupEssenceMessageNotice;
        })();

        event.GroupPokeNotice = (function() {

            /**
             * Properties of a GroupPokeNotice.
             * @memberof kritor.event
             * @interface IGroupPokeNotice
             * @property {number|Long|null} [group_id] GroupPokeNotice group_id
             * @property {string|null} [operator_uid] GroupPokeNotice operator_uid
             * @property {number|Long|null} [operator_uin] GroupPokeNotice operator_uin
             * @property {string|null} [target_uid] GroupPokeNotice target_uid
             * @property {number|Long|null} [target_uin] GroupPokeNotice target_uin
             * @property {string|null} [action] GroupPokeNotice action
             * @property {string|null} [suffix] GroupPokeNotice suffix
             * @property {string|null} [action_image] GroupPokeNotice action_image
             */

            /**
             * Constructs a new GroupPokeNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupPokeNotice.
             * @implements IGroupPokeNotice
             * @constructor
             * @param {kritor.event.IGroupPokeNotice=} [properties] Properties to set
             */
            function GroupPokeNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupPokeNotice group_id.
             * @member {number|Long} group_id
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupPokeNotice operator_uid.
             * @member {string} operator_uid
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.operator_uid = "";

            /**
             * GroupPokeNotice operator_uin.
             * @member {number|Long} operator_uin
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.operator_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupPokeNotice target_uid.
             * @member {string} target_uid
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.target_uid = "";

            /**
             * GroupPokeNotice target_uin.
             * @member {number|Long} target_uin
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.target_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupPokeNotice action.
             * @member {string} action
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.action = "";

            /**
             * GroupPokeNotice suffix.
             * @member {string} suffix
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.suffix = "";

            /**
             * GroupPokeNotice action_image.
             * @member {string} action_image
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.action_image = "";

            /**
             * Creates a new GroupPokeNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {kritor.event.IGroupPokeNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupPokeNotice} GroupPokeNotice instance
             */
            GroupPokeNotice.create = function create(properties) {
                return new GroupPokeNotice(properties);
            };

            /**
             * Encodes the specified GroupPokeNotice message. Does not implicitly {@link kritor.event.GroupPokeNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {kritor.event.IGroupPokeNotice} message GroupPokeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupPokeNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.operator_uid != null && Object.hasOwnProperty.call(message, "operator_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operator_uid);
                if (message.operator_uin != null && Object.hasOwnProperty.call(message, "operator_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operator_uin);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.target_uin);
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.action);
                if (message.suffix != null && Object.hasOwnProperty.call(message, "suffix"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.suffix);
                if (message.action_image != null && Object.hasOwnProperty.call(message, "action_image"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.action_image);
                return writer;
            };

            /**
             * Encodes the specified GroupPokeNotice message, length delimited. Does not implicitly {@link kritor.event.GroupPokeNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {kritor.event.IGroupPokeNotice} message GroupPokeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupPokeNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupPokeNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupPokeNotice} GroupPokeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupPokeNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupPokeNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operator_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operator_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 5: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.action = reader.string();
                            break;
                        }
                    case 7: {
                            message.suffix = reader.string();
                            break;
                        }
                    case 8: {
                            message.action_image = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupPokeNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupPokeNotice} GroupPokeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupPokeNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupPokeNotice message.
             * @function verify
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupPokeNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    if (!$util.isString(message.operator_uid))
                        return "operator_uid: string expected";
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (!$util.isInteger(message.operator_uin) && !(message.operator_uin && $util.isInteger(message.operator_uin.low) && $util.isInteger(message.operator_uin.high)))
                        return "operator_uin: integer|Long expected";
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                if (message.action != null && message.hasOwnProperty("action"))
                    if (!$util.isString(message.action))
                        return "action: string expected";
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    if (!$util.isString(message.suffix))
                        return "suffix: string expected";
                if (message.action_image != null && message.hasOwnProperty("action_image"))
                    if (!$util.isString(message.action_image))
                        return "action_image: string expected";
                return null;
            };

            /**
             * Creates a GroupPokeNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupPokeNotice} GroupPokeNotice
             */
            GroupPokeNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupPokeNotice)
                    return object;
                let message = new $root.kritor.event.GroupPokeNotice();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.operator_uid != null)
                    message.operator_uid = String(object.operator_uid);
                if (object.operator_uin != null)
                    if ($util.Long)
                        (message.operator_uin = $util.Long.fromValue(object.operator_uin)).unsigned = true;
                    else if (typeof object.operator_uin === "string")
                        message.operator_uin = parseInt(object.operator_uin, 10);
                    else if (typeof object.operator_uin === "number")
                        message.operator_uin = object.operator_uin;
                    else if (typeof object.operator_uin === "object")
                        message.operator_uin = new $util.LongBits(object.operator_uin.low >>> 0, object.operator_uin.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                if (object.action != null)
                    message.action = String(object.action);
                if (object.suffix != null)
                    message.suffix = String(object.suffix);
                if (object.action_image != null)
                    message.action_image = String(object.action_image);
                return message;
            };

            /**
             * Creates a plain object from a GroupPokeNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {kritor.event.GroupPokeNotice} message GroupPokeNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupPokeNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.operator_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator_uin = options.longs === String ? "0" : 0;
                    object.target_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.target_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.target_uin = options.longs === String ? "0" : 0;
                    object.action = "";
                    object.suffix = "";
                    object.action_image = "";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    object.operator_uid = message.operator_uid;
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (typeof message.operator_uin === "number")
                        object.operator_uin = options.longs === String ? String(message.operator_uin) : message.operator_uin;
                    else
                        object.operator_uin = options.longs === String ? $util.Long.prototype.toString.call(message.operator_uin) : options.longs === Number ? new $util.LongBits(message.operator_uin.low >>> 0, message.operator_uin.high >>> 0).toNumber(true) : message.operator_uin;
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    object.target_uid = message.target_uid;
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = message.action;
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    object.suffix = message.suffix;
                if (message.action_image != null && message.hasOwnProperty("action_image"))
                    object.action_image = message.action_image;
                return object;
            };

            /**
             * Converts this GroupPokeNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupPokeNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupPokeNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupPokeNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupPokeNotice";
            };

            return GroupPokeNotice;
        })();

        event.GroupCardChangedNotice = (function() {

            /**
             * Properties of a GroupCardChangedNotice.
             * @memberof kritor.event
             * @interface IGroupCardChangedNotice
             * @property {number|Long|null} [group_id] GroupCardChangedNotice group_id
             * @property {string|null} [operator_uid] GroupCardChangedNotice operator_uid
             * @property {number|Long|null} [operator_uin] GroupCardChangedNotice operator_uin
             * @property {string|null} [target_uid] GroupCardChangedNotice target_uid
             * @property {number|Long|null} [target_uin] GroupCardChangedNotice target_uin
             * @property {string|null} [new_card] GroupCardChangedNotice new_card
             */

            /**
             * Constructs a new GroupCardChangedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupCardChangedNotice.
             * @implements IGroupCardChangedNotice
             * @constructor
             * @param {kritor.event.IGroupCardChangedNotice=} [properties] Properties to set
             */
            function GroupCardChangedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupCardChangedNotice group_id.
             * @member {number|Long} group_id
             * @memberof kritor.event.GroupCardChangedNotice
             * @instance
             */
            GroupCardChangedNotice.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupCardChangedNotice operator_uid.
             * @member {string} operator_uid
             * @memberof kritor.event.GroupCardChangedNotice
             * @instance
             */
            GroupCardChangedNotice.prototype.operator_uid = "";

            /**
             * GroupCardChangedNotice operator_uin.
             * @member {number|Long} operator_uin
             * @memberof kritor.event.GroupCardChangedNotice
             * @instance
             */
            GroupCardChangedNotice.prototype.operator_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupCardChangedNotice target_uid.
             * @member {string} target_uid
             * @memberof kritor.event.GroupCardChangedNotice
             * @instance
             */
            GroupCardChangedNotice.prototype.target_uid = "";

            /**
             * GroupCardChangedNotice target_uin.
             * @member {number|Long} target_uin
             * @memberof kritor.event.GroupCardChangedNotice
             * @instance
             */
            GroupCardChangedNotice.prototype.target_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupCardChangedNotice new_card.
             * @member {string} new_card
             * @memberof kritor.event.GroupCardChangedNotice
             * @instance
             */
            GroupCardChangedNotice.prototype.new_card = "";

            /**
             * Creates a new GroupCardChangedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {kritor.event.IGroupCardChangedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupCardChangedNotice} GroupCardChangedNotice instance
             */
            GroupCardChangedNotice.create = function create(properties) {
                return new GroupCardChangedNotice(properties);
            };

            /**
             * Encodes the specified GroupCardChangedNotice message. Does not implicitly {@link kritor.event.GroupCardChangedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {kritor.event.IGroupCardChangedNotice} message GroupCardChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupCardChangedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.operator_uid != null && Object.hasOwnProperty.call(message, "operator_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operator_uid);
                if (message.operator_uin != null && Object.hasOwnProperty.call(message, "operator_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operator_uin);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.target_uin);
                if (message.new_card != null && Object.hasOwnProperty.call(message, "new_card"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.new_card);
                return writer;
            };

            /**
             * Encodes the specified GroupCardChangedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupCardChangedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {kritor.event.IGroupCardChangedNotice} message GroupCardChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupCardChangedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupCardChangedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupCardChangedNotice} GroupCardChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupCardChangedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupCardChangedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operator_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operator_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 5: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.new_card = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupCardChangedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupCardChangedNotice} GroupCardChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupCardChangedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupCardChangedNotice message.
             * @function verify
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupCardChangedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    if (!$util.isString(message.operator_uid))
                        return "operator_uid: string expected";
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (!$util.isInteger(message.operator_uin) && !(message.operator_uin && $util.isInteger(message.operator_uin.low) && $util.isInteger(message.operator_uin.high)))
                        return "operator_uin: integer|Long expected";
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                if (message.new_card != null && message.hasOwnProperty("new_card"))
                    if (!$util.isString(message.new_card))
                        return "new_card: string expected";
                return null;
            };

            /**
             * Creates a GroupCardChangedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupCardChangedNotice} GroupCardChangedNotice
             */
            GroupCardChangedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupCardChangedNotice)
                    return object;
                let message = new $root.kritor.event.GroupCardChangedNotice();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.operator_uid != null)
                    message.operator_uid = String(object.operator_uid);
                if (object.operator_uin != null)
                    if ($util.Long)
                        (message.operator_uin = $util.Long.fromValue(object.operator_uin)).unsigned = true;
                    else if (typeof object.operator_uin === "string")
                        message.operator_uin = parseInt(object.operator_uin, 10);
                    else if (typeof object.operator_uin === "number")
                        message.operator_uin = object.operator_uin;
                    else if (typeof object.operator_uin === "object")
                        message.operator_uin = new $util.LongBits(object.operator_uin.low >>> 0, object.operator_uin.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                if (object.new_card != null)
                    message.new_card = String(object.new_card);
                return message;
            };

            /**
             * Creates a plain object from a GroupCardChangedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {kritor.event.GroupCardChangedNotice} message GroupCardChangedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupCardChangedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.operator_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator_uin = options.longs === String ? "0" : 0;
                    object.target_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.target_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.target_uin = options.longs === String ? "0" : 0;
                    object.new_card = "";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    object.operator_uid = message.operator_uid;
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (typeof message.operator_uin === "number")
                        object.operator_uin = options.longs === String ? String(message.operator_uin) : message.operator_uin;
                    else
                        object.operator_uin = options.longs === String ? $util.Long.prototype.toString.call(message.operator_uin) : options.longs === Number ? new $util.LongBits(message.operator_uin.low >>> 0, message.operator_uin.high >>> 0).toNumber(true) : message.operator_uin;
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    object.target_uid = message.target_uid;
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                if (message.new_card != null && message.hasOwnProperty("new_card"))
                    object.new_card = message.new_card;
                return object;
            };

            /**
             * Converts this GroupCardChangedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupCardChangedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupCardChangedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupCardChangedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupCardChangedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupCardChangedNotice";
            };

            return GroupCardChangedNotice;
        })();

        event.GroupMemberIncreasedNotice = (function() {

            /**
             * Properties of a GroupMemberIncreasedNotice.
             * @memberof kritor.event
             * @interface IGroupMemberIncreasedNotice
             * @property {number|Long|null} [group_id] GroupMemberIncreasedNotice group_id
             * @property {string|null} [operator_uid] GroupMemberIncreasedNotice operator_uid
             * @property {number|Long|null} [operator_uin] GroupMemberIncreasedNotice operator_uin
             * @property {string|null} [target_uid] GroupMemberIncreasedNotice target_uid
             * @property {number|Long|null} [target_uin] GroupMemberIncreasedNotice target_uin
             * @property {kritor.event.GroupMemberIncreasedNotice.GroupMemberIncreasedType|null} [type] GroupMemberIncreasedNotice type
             */

            /**
             * Constructs a new GroupMemberIncreasedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupMemberIncreasedNotice.
             * @implements IGroupMemberIncreasedNotice
             * @constructor
             * @param {kritor.event.IGroupMemberIncreasedNotice=} [properties] Properties to set
             */
            function GroupMemberIncreasedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupMemberIncreasedNotice group_id.
             * @member {number|Long} group_id
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberIncreasedNotice operator_uid.
             * @member {string} operator_uid
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.operator_uid = "";

            /**
             * GroupMemberIncreasedNotice operator_uin.
             * @member {number|Long} operator_uin
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.operator_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberIncreasedNotice target_uid.
             * @member {string} target_uid
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.target_uid = "";

            /**
             * GroupMemberIncreasedNotice target_uin.
             * @member {number|Long} target_uin
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.target_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberIncreasedNotice type.
             * @member {kritor.event.GroupMemberIncreasedNotice.GroupMemberIncreasedType} type
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.type = 0;

            /**
             * Creates a new GroupMemberIncreasedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberIncreasedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupMemberIncreasedNotice} GroupMemberIncreasedNotice instance
             */
            GroupMemberIncreasedNotice.create = function create(properties) {
                return new GroupMemberIncreasedNotice(properties);
            };

            /**
             * Encodes the specified GroupMemberIncreasedNotice message. Does not implicitly {@link kritor.event.GroupMemberIncreasedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberIncreasedNotice} message GroupMemberIncreasedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberIncreasedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.operator_uid != null && Object.hasOwnProperty.call(message, "operator_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operator_uid);
                if (message.operator_uin != null && Object.hasOwnProperty.call(message, "operator_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operator_uin);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.target_uin);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified GroupMemberIncreasedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupMemberIncreasedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberIncreasedNotice} message GroupMemberIncreasedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberIncreasedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupMemberIncreasedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupMemberIncreasedNotice} GroupMemberIncreasedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberIncreasedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupMemberIncreasedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operator_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operator_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 5: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupMemberIncreasedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupMemberIncreasedNotice} GroupMemberIncreasedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberIncreasedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupMemberIncreasedNotice message.
             * @function verify
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupMemberIncreasedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    if (!$util.isString(message.operator_uid))
                        return "operator_uid: string expected";
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (!$util.isInteger(message.operator_uin) && !(message.operator_uin && $util.isInteger(message.operator_uin.low) && $util.isInteger(message.operator_uin.high)))
                        return "operator_uin: integer|Long expected";
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GroupMemberIncreasedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupMemberIncreasedNotice} GroupMemberIncreasedNotice
             */
            GroupMemberIncreasedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupMemberIncreasedNotice)
                    return object;
                let message = new $root.kritor.event.GroupMemberIncreasedNotice();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.operator_uid != null)
                    message.operator_uid = String(object.operator_uid);
                if (object.operator_uin != null)
                    if ($util.Long)
                        (message.operator_uin = $util.Long.fromValue(object.operator_uin)).unsigned = true;
                    else if (typeof object.operator_uin === "string")
                        message.operator_uin = parseInt(object.operator_uin, 10);
                    else if (typeof object.operator_uin === "number")
                        message.operator_uin = object.operator_uin;
                    else if (typeof object.operator_uin === "object")
                        message.operator_uin = new $util.LongBits(object.operator_uin.low >>> 0, object.operator_uin.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "APPROVE":
                case 0:
                    message.type = 0;
                    break;
                case "INVITE":
                case 1:
                    message.type = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupMemberIncreasedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {kritor.event.GroupMemberIncreasedNotice} message GroupMemberIncreasedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupMemberIncreasedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.operator_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator_uin = options.longs === String ? "0" : 0;
                    object.target_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.target_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.target_uin = options.longs === String ? "0" : 0;
                    object.type = options.enums === String ? "APPROVE" : 0;
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    object.operator_uid = message.operator_uid;
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (typeof message.operator_uin === "number")
                        object.operator_uin = options.longs === String ? String(message.operator_uin) : message.operator_uin;
                    else
                        object.operator_uin = options.longs === String ? $util.Long.prototype.toString.call(message.operator_uin) : options.longs === Number ? new $util.LongBits(message.operator_uin.low >>> 0, message.operator_uin.high >>> 0).toNumber(true) : message.operator_uin;
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    object.target_uid = message.target_uid;
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.GroupMemberIncreasedNotice.GroupMemberIncreasedType[message.type] === undefined ? message.type : $root.kritor.event.GroupMemberIncreasedNotice.GroupMemberIncreasedType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this GroupMemberIncreasedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupMemberIncreasedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupMemberIncreasedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupMemberIncreasedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupMemberIncreasedNotice";
            };

            /**
             * GroupMemberIncreasedType enum.
             * @name kritor.event.GroupMemberIncreasedNotice.GroupMemberIncreasedType
             * @enum {number}
             * @property {number} APPROVE=0 APPROVE value
             * @property {number} INVITE=1 INVITE value
             */
            GroupMemberIncreasedNotice.GroupMemberIncreasedType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "APPROVE"] = 0;
                values[valuesById[1] = "INVITE"] = 1;
                return values;
            })();

            return GroupMemberIncreasedNotice;
        })();

        event.GroupMemberDecreasedNotice = (function() {

            /**
             * Properties of a GroupMemberDecreasedNotice.
             * @memberof kritor.event
             * @interface IGroupMemberDecreasedNotice
             * @property {number|Long|null} [group_id] GroupMemberDecreasedNotice group_id
             * @property {string|null} [operator_uid] GroupMemberDecreasedNotice operator_uid
             * @property {number|Long|null} [operator_uin] GroupMemberDecreasedNotice operator_uin
             * @property {string|null} [target_uid] GroupMemberDecreasedNotice target_uid
             * @property {number|Long|null} [target_uin] GroupMemberDecreasedNotice target_uin
             * @property {kritor.event.GroupMemberDecreasedNotice.GroupMemberDecreasedType|null} [type] GroupMemberDecreasedNotice type
             */

            /**
             * Constructs a new GroupMemberDecreasedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupMemberDecreasedNotice.
             * @implements IGroupMemberDecreasedNotice
             * @constructor
             * @param {kritor.event.IGroupMemberDecreasedNotice=} [properties] Properties to set
             */
            function GroupMemberDecreasedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupMemberDecreasedNotice group_id.
             * @member {number|Long} group_id
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberDecreasedNotice operator_uid.
             * @member {string|null|undefined} operator_uid
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.operator_uid = null;

            /**
             * GroupMemberDecreasedNotice operator_uin.
             * @member {number|Long|null|undefined} operator_uin
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.operator_uin = null;

            /**
             * GroupMemberDecreasedNotice target_uid.
             * @member {string|null|undefined} target_uid
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.target_uid = null;

            /**
             * GroupMemberDecreasedNotice target_uin.
             * @member {number|Long|null|undefined} target_uin
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.target_uin = null;

            /**
             * GroupMemberDecreasedNotice type.
             * @member {kritor.event.GroupMemberDecreasedNotice.GroupMemberDecreasedType} type
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.type = 0;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GroupMemberDecreasedNotice _operator_uid.
             * @member {"operator_uid"|undefined} _operator_uid
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            Object.defineProperty(GroupMemberDecreasedNotice.prototype, "_operator_uid", {
                get: $util.oneOfGetter($oneOfFields = ["operator_uid"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GroupMemberDecreasedNotice _operator_uin.
             * @member {"operator_uin"|undefined} _operator_uin
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            Object.defineProperty(GroupMemberDecreasedNotice.prototype, "_operator_uin", {
                get: $util.oneOfGetter($oneOfFields = ["operator_uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GroupMemberDecreasedNotice _target_uid.
             * @member {"target_uid"|undefined} _target_uid
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            Object.defineProperty(GroupMemberDecreasedNotice.prototype, "_target_uid", {
                get: $util.oneOfGetter($oneOfFields = ["target_uid"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GroupMemberDecreasedNotice _target_uin.
             * @member {"target_uin"|undefined} _target_uin
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            Object.defineProperty(GroupMemberDecreasedNotice.prototype, "_target_uin", {
                get: $util.oneOfGetter($oneOfFields = ["target_uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GroupMemberDecreasedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberDecreasedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupMemberDecreasedNotice} GroupMemberDecreasedNotice instance
             */
            GroupMemberDecreasedNotice.create = function create(properties) {
                return new GroupMemberDecreasedNotice(properties);
            };

            /**
             * Encodes the specified GroupMemberDecreasedNotice message. Does not implicitly {@link kritor.event.GroupMemberDecreasedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberDecreasedNotice} message GroupMemberDecreasedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberDecreasedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.operator_uid != null && Object.hasOwnProperty.call(message, "operator_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operator_uid);
                if (message.operator_uin != null && Object.hasOwnProperty.call(message, "operator_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operator_uin);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.target_uin);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified GroupMemberDecreasedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupMemberDecreasedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberDecreasedNotice} message GroupMemberDecreasedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberDecreasedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupMemberDecreasedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupMemberDecreasedNotice} GroupMemberDecreasedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberDecreasedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupMemberDecreasedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operator_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operator_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 5: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupMemberDecreasedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupMemberDecreasedNotice} GroupMemberDecreasedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberDecreasedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupMemberDecreasedNotice message.
             * @function verify
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupMemberDecreasedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid")) {
                    properties._operator_uid = 1;
                    if (!$util.isString(message.operator_uid))
                        return "operator_uid: string expected";
                }
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin")) {
                    properties._operator_uin = 1;
                    if (!$util.isInteger(message.operator_uin) && !(message.operator_uin && $util.isInteger(message.operator_uin.low) && $util.isInteger(message.operator_uin.high)))
                        return "operator_uin: integer|Long expected";
                }
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    properties._target_uid = 1;
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    properties._target_uin = 1;
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GroupMemberDecreasedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupMemberDecreasedNotice} GroupMemberDecreasedNotice
             */
            GroupMemberDecreasedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupMemberDecreasedNotice)
                    return object;
                let message = new $root.kritor.event.GroupMemberDecreasedNotice();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.operator_uid != null)
                    message.operator_uid = String(object.operator_uid);
                if (object.operator_uin != null)
                    if ($util.Long)
                        (message.operator_uin = $util.Long.fromValue(object.operator_uin)).unsigned = true;
                    else if (typeof object.operator_uin === "string")
                        message.operator_uin = parseInt(object.operator_uin, 10);
                    else if (typeof object.operator_uin === "number")
                        message.operator_uin = object.operator_uin;
                    else if (typeof object.operator_uin === "object")
                        message.operator_uin = new $util.LongBits(object.operator_uin.low >>> 0, object.operator_uin.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "LEAVE":
                case 0:
                    message.type = 0;
                    break;
                case "KICK":
                case 1:
                    message.type = 1;
                    break;
                case "KICK_ME":
                case 2:
                    message.type = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupMemberDecreasedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {kritor.event.GroupMemberDecreasedNotice} message GroupMemberDecreasedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupMemberDecreasedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.type = options.enums === String ? "LEAVE" : 0;
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid")) {
                    object.operator_uid = message.operator_uid;
                    if (options.oneofs)
                        object._operator_uid = "operator_uid";
                }
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin")) {
                    if (typeof message.operator_uin === "number")
                        object.operator_uin = options.longs === String ? String(message.operator_uin) : message.operator_uin;
                    else
                        object.operator_uin = options.longs === String ? $util.Long.prototype.toString.call(message.operator_uin) : options.longs === Number ? new $util.LongBits(message.operator_uin.low >>> 0, message.operator_uin.high >>> 0).toNumber(true) : message.operator_uin;
                    if (options.oneofs)
                        object._operator_uin = "operator_uin";
                }
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    object.target_uid = message.target_uid;
                    if (options.oneofs)
                        object._target_uid = "target_uid";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                    if (options.oneofs)
                        object._target_uin = "target_uin";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.GroupMemberDecreasedNotice.GroupMemberDecreasedType[message.type] === undefined ? message.type : $root.kritor.event.GroupMemberDecreasedNotice.GroupMemberDecreasedType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this GroupMemberDecreasedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupMemberDecreasedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupMemberDecreasedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupMemberDecreasedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupMemberDecreasedNotice";
            };

            /**
             * GroupMemberDecreasedType enum.
             * @name kritor.event.GroupMemberDecreasedNotice.GroupMemberDecreasedType
             * @enum {number}
             * @property {number} LEAVE=0 LEAVE value
             * @property {number} KICK=1 KICK value
             * @property {number} KICK_ME=2 KICK_ME value
             */
            GroupMemberDecreasedNotice.GroupMemberDecreasedType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "LEAVE"] = 0;
                values[valuesById[1] = "KICK"] = 1;
                values[valuesById[2] = "KICK_ME"] = 2;
                return values;
            })();

            return GroupMemberDecreasedNotice;
        })();

        event.GroupAdminChangedNotice = (function() {

            /**
             * Properties of a GroupAdminChangedNotice.
             * @memberof kritor.event
             * @interface IGroupAdminChangedNotice
             * @property {number|Long|null} [group_id] GroupAdminChangedNotice group_id
             * @property {string|null} [target_uid] GroupAdminChangedNotice target_uid
             * @property {number|Long|null} [target_uin] GroupAdminChangedNotice target_uin
             * @property {boolean|null} [is_admin] GroupAdminChangedNotice is_admin
             */

            /**
             * Constructs a new GroupAdminChangedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupAdminChangedNotice.
             * @implements IGroupAdminChangedNotice
             * @constructor
             * @param {kritor.event.IGroupAdminChangedNotice=} [properties] Properties to set
             */
            function GroupAdminChangedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupAdminChangedNotice group_id.
             * @member {number|Long} group_id
             * @memberof kritor.event.GroupAdminChangedNotice
             * @instance
             */
            GroupAdminChangedNotice.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupAdminChangedNotice target_uid.
             * @member {string} target_uid
             * @memberof kritor.event.GroupAdminChangedNotice
             * @instance
             */
            GroupAdminChangedNotice.prototype.target_uid = "";

            /**
             * GroupAdminChangedNotice target_uin.
             * @member {number|Long} target_uin
             * @memberof kritor.event.GroupAdminChangedNotice
             * @instance
             */
            GroupAdminChangedNotice.prototype.target_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupAdminChangedNotice is_admin.
             * @member {boolean} is_admin
             * @memberof kritor.event.GroupAdminChangedNotice
             * @instance
             */
            GroupAdminChangedNotice.prototype.is_admin = false;

            /**
             * Creates a new GroupAdminChangedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {kritor.event.IGroupAdminChangedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupAdminChangedNotice} GroupAdminChangedNotice instance
             */
            GroupAdminChangedNotice.create = function create(properties) {
                return new GroupAdminChangedNotice(properties);
            };

            /**
             * Encodes the specified GroupAdminChangedNotice message. Does not implicitly {@link kritor.event.GroupAdminChangedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {kritor.event.IGroupAdminChangedNotice} message GroupAdminChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupAdminChangedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.target_uin);
                if (message.is_admin != null && Object.hasOwnProperty.call(message, "is_admin"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.is_admin);
                return writer;
            };

            /**
             * Encodes the specified GroupAdminChangedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupAdminChangedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {kritor.event.IGroupAdminChangedNotice} message GroupAdminChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupAdminChangedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupAdminChangedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupAdminChangedNotice} GroupAdminChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupAdminChangedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupAdminChangedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 5: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.is_admin = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupAdminChangedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupAdminChangedNotice} GroupAdminChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupAdminChangedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupAdminChangedNotice message.
             * @function verify
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupAdminChangedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                if (message.is_admin != null && message.hasOwnProperty("is_admin"))
                    if (typeof message.is_admin !== "boolean")
                        return "is_admin: boolean expected";
                return null;
            };

            /**
             * Creates a GroupAdminChangedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupAdminChangedNotice} GroupAdminChangedNotice
             */
            GroupAdminChangedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupAdminChangedNotice)
                    return object;
                let message = new $root.kritor.event.GroupAdminChangedNotice();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                if (object.is_admin != null)
                    message.is_admin = Boolean(object.is_admin);
                return message;
            };

            /**
             * Creates a plain object from a GroupAdminChangedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {kritor.event.GroupAdminChangedNotice} message GroupAdminChangedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupAdminChangedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.target_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.target_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.target_uin = options.longs === String ? "0" : 0;
                    object.is_admin = false;
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    object.target_uid = message.target_uid;
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                if (message.is_admin != null && message.hasOwnProperty("is_admin"))
                    object.is_admin = message.is_admin;
                return object;
            };

            /**
             * Converts this GroupAdminChangedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupAdminChangedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupAdminChangedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupAdminChangedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupAdminChangedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupAdminChangedNotice";
            };

            return GroupAdminChangedNotice;
        })();

        event.GroupMemberBanNotice = (function() {

            /**
             * Properties of a GroupMemberBanNotice.
             * @memberof kritor.event
             * @interface IGroupMemberBanNotice
             * @property {number|Long|null} [group_id] GroupMemberBanNotice group_id
             * @property {string|null} [operator_uid] GroupMemberBanNotice operator_uid
             * @property {number|Long|null} [operator_uin] GroupMemberBanNotice operator_uin
             * @property {string|null} [target_uid] GroupMemberBanNotice target_uid
             * @property {number|Long|null} [target_uin] GroupMemberBanNotice target_uin
             * @property {number|null} [duration] GroupMemberBanNotice duration
             * @property {kritor.event.GroupMemberBanNotice.GroupMemberBanType|null} [type] GroupMemberBanNotice type
             */

            /**
             * Constructs a new GroupMemberBanNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupMemberBanNotice.
             * @implements IGroupMemberBanNotice
             * @constructor
             * @param {kritor.event.IGroupMemberBanNotice=} [properties] Properties to set
             */
            function GroupMemberBanNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupMemberBanNotice group_id.
             * @member {number|Long} group_id
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             */
            GroupMemberBanNotice.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberBanNotice operator_uid.
             * @member {string} operator_uid
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             */
            GroupMemberBanNotice.prototype.operator_uid = "";

            /**
             * GroupMemberBanNotice operator_uin.
             * @member {number|Long} operator_uin
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             */
            GroupMemberBanNotice.prototype.operator_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberBanNotice target_uid.
             * @member {string} target_uid
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             */
            GroupMemberBanNotice.prototype.target_uid = "";

            /**
             * GroupMemberBanNotice target_uin.
             * @member {number|Long} target_uin
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             */
            GroupMemberBanNotice.prototype.target_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberBanNotice duration.
             * @member {number} duration
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             */
            GroupMemberBanNotice.prototype.duration = 0;

            /**
             * GroupMemberBanNotice type.
             * @member {kritor.event.GroupMemberBanNotice.GroupMemberBanType} type
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             */
            GroupMemberBanNotice.prototype.type = 0;

            /**
             * Creates a new GroupMemberBanNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {kritor.event.IGroupMemberBanNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupMemberBanNotice} GroupMemberBanNotice instance
             */
            GroupMemberBanNotice.create = function create(properties) {
                return new GroupMemberBanNotice(properties);
            };

            /**
             * Encodes the specified GroupMemberBanNotice message. Does not implicitly {@link kritor.event.GroupMemberBanNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {kritor.event.IGroupMemberBanNotice} message GroupMemberBanNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberBanNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.operator_uid != null && Object.hasOwnProperty.call(message, "operator_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operator_uid);
                if (message.operator_uin != null && Object.hasOwnProperty.call(message, "operator_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operator_uin);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.target_uin);
                if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.duration);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified GroupMemberBanNotice message, length delimited. Does not implicitly {@link kritor.event.GroupMemberBanNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {kritor.event.IGroupMemberBanNotice} message GroupMemberBanNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberBanNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupMemberBanNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupMemberBanNotice} GroupMemberBanNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberBanNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupMemberBanNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operator_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operator_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 5: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.duration = reader.int32();
                            break;
                        }
                    case 7: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupMemberBanNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupMemberBanNotice} GroupMemberBanNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberBanNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupMemberBanNotice message.
             * @function verify
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupMemberBanNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    if (!$util.isString(message.operator_uid))
                        return "operator_uid: string expected";
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (!$util.isInteger(message.operator_uin) && !(message.operator_uin && $util.isInteger(message.operator_uin.low) && $util.isInteger(message.operator_uin.high)))
                        return "operator_uin: integer|Long expected";
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                if (message.duration != null && message.hasOwnProperty("duration"))
                    if (!$util.isInteger(message.duration))
                        return "duration: integer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GroupMemberBanNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupMemberBanNotice} GroupMemberBanNotice
             */
            GroupMemberBanNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupMemberBanNotice)
                    return object;
                let message = new $root.kritor.event.GroupMemberBanNotice();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.operator_uid != null)
                    message.operator_uid = String(object.operator_uid);
                if (object.operator_uin != null)
                    if ($util.Long)
                        (message.operator_uin = $util.Long.fromValue(object.operator_uin)).unsigned = true;
                    else if (typeof object.operator_uin === "string")
                        message.operator_uin = parseInt(object.operator_uin, 10);
                    else if (typeof object.operator_uin === "number")
                        message.operator_uin = object.operator_uin;
                    else if (typeof object.operator_uin === "object")
                        message.operator_uin = new $util.LongBits(object.operator_uin.low >>> 0, object.operator_uin.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                if (object.duration != null)
                    message.duration = object.duration | 0;
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "LIFT_BAN":
                case 0:
                    message.type = 0;
                    break;
                case "BAN":
                case 1:
                    message.type = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupMemberBanNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {kritor.event.GroupMemberBanNotice} message GroupMemberBanNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupMemberBanNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.operator_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator_uin = options.longs === String ? "0" : 0;
                    object.target_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.target_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.target_uin = options.longs === String ? "0" : 0;
                    object.duration = 0;
                    object.type = options.enums === String ? "LIFT_BAN" : 0;
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    object.operator_uid = message.operator_uid;
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (typeof message.operator_uin === "number")
                        object.operator_uin = options.longs === String ? String(message.operator_uin) : message.operator_uin;
                    else
                        object.operator_uin = options.longs === String ? $util.Long.prototype.toString.call(message.operator_uin) : options.longs === Number ? new $util.LongBits(message.operator_uin.low >>> 0, message.operator_uin.high >>> 0).toNumber(true) : message.operator_uin;
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    object.target_uid = message.target_uid;
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                if (message.duration != null && message.hasOwnProperty("duration"))
                    object.duration = message.duration;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.GroupMemberBanNotice.GroupMemberBanType[message.type] === undefined ? message.type : $root.kritor.event.GroupMemberBanNotice.GroupMemberBanType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this GroupMemberBanNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupMemberBanNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupMemberBanNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupMemberBanNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupMemberBanNotice";
            };

            /**
             * GroupMemberBanType enum.
             * @name kritor.event.GroupMemberBanNotice.GroupMemberBanType
             * @enum {number}
             * @property {number} LIFT_BAN=0 LIFT_BAN value
             * @property {number} BAN=1 BAN value
             */
            GroupMemberBanNotice.GroupMemberBanType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "LIFT_BAN"] = 0;
                values[valuesById[1] = "BAN"] = 1;
                return values;
            })();

            return GroupMemberBanNotice;
        })();

        event.GroupRecallNotice = (function() {

            /**
             * Properties of a GroupRecallNotice.
             * @memberof kritor.event
             * @interface IGroupRecallNotice
             * @property {number|Long|null} [group_id] GroupRecallNotice group_id
             * @property {string|null} [message_id] GroupRecallNotice message_id
             * @property {string|null} [tip_text] GroupRecallNotice tip_text
             * @property {string|null} [operator_uid] GroupRecallNotice operator_uid
             * @property {number|Long|null} [operator_uin] GroupRecallNotice operator_uin
             * @property {string|null} [target_uid] GroupRecallNotice target_uid
             * @property {number|Long|null} [target_uin] GroupRecallNotice target_uin
             * @property {number|Long|null} [message_seq] GroupRecallNotice message_seq
             */

            /**
             * Constructs a new GroupRecallNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupRecallNotice.
             * @implements IGroupRecallNotice
             * @constructor
             * @param {kritor.event.IGroupRecallNotice=} [properties] Properties to set
             */
            function GroupRecallNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupRecallNotice group_id.
             * @member {number|Long} group_id
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupRecallNotice message_id.
             * @member {string} message_id
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.message_id = "";

            /**
             * GroupRecallNotice tip_text.
             * @member {string} tip_text
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.tip_text = "";

            /**
             * GroupRecallNotice operator_uid.
             * @member {string} operator_uid
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.operator_uid = "";

            /**
             * GroupRecallNotice operator_uin.
             * @member {number|Long} operator_uin
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.operator_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupRecallNotice target_uid.
             * @member {string} target_uid
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.target_uid = "";

            /**
             * GroupRecallNotice target_uin.
             * @member {number|Long} target_uin
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.target_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupRecallNotice message_seq.
             * @member {number|Long} message_seq
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.message_seq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GroupRecallNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {kritor.event.IGroupRecallNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupRecallNotice} GroupRecallNotice instance
             */
            GroupRecallNotice.create = function create(properties) {
                return new GroupRecallNotice(properties);
            };

            /**
             * Encodes the specified GroupRecallNotice message. Does not implicitly {@link kritor.event.GroupRecallNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {kritor.event.IGroupRecallNotice} message GroupRecallNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupRecallNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message_id);
                if (message.tip_text != null && Object.hasOwnProperty.call(message, "tip_text"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tip_text);
                if (message.operator_uid != null && Object.hasOwnProperty.call(message, "operator_uid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.operator_uid);
                if (message.operator_uin != null && Object.hasOwnProperty.call(message, "operator_uin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.operator_uin);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.target_uin);
                if (message.message_seq != null && Object.hasOwnProperty.call(message, "message_seq"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.message_seq);
                return writer;
            };

            /**
             * Encodes the specified GroupRecallNotice message, length delimited. Does not implicitly {@link kritor.event.GroupRecallNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {kritor.event.IGroupRecallNotice} message GroupRecallNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupRecallNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupRecallNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupRecallNotice} GroupRecallNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupRecallNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupRecallNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.message_id = reader.string();
                            break;
                        }
                    case 3: {
                            message.tip_text = reader.string();
                            break;
                        }
                    case 4: {
                            message.operator_uid = reader.string();
                            break;
                        }
                    case 5: {
                            message.operator_uin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 7: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.message_seq = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupRecallNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupRecallNotice} GroupRecallNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupRecallNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupRecallNotice message.
             * @function verify
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupRecallNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                if (message.tip_text != null && message.hasOwnProperty("tip_text"))
                    if (!$util.isString(message.tip_text))
                        return "tip_text: string expected";
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    if (!$util.isString(message.operator_uid))
                        return "operator_uid: string expected";
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (!$util.isInteger(message.operator_uin) && !(message.operator_uin && $util.isInteger(message.operator_uin.low) && $util.isInteger(message.operator_uin.high)))
                        return "operator_uin: integer|Long expected";
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                if (message.message_seq != null && message.hasOwnProperty("message_seq"))
                    if (!$util.isInteger(message.message_seq) && !(message.message_seq && $util.isInteger(message.message_seq.low) && $util.isInteger(message.message_seq.high)))
                        return "message_seq: integer|Long expected";
                return null;
            };

            /**
             * Creates a GroupRecallNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupRecallNotice} GroupRecallNotice
             */
            GroupRecallNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupRecallNotice)
                    return object;
                let message = new $root.kritor.event.GroupRecallNotice();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                if (object.tip_text != null)
                    message.tip_text = String(object.tip_text);
                if (object.operator_uid != null)
                    message.operator_uid = String(object.operator_uid);
                if (object.operator_uin != null)
                    if ($util.Long)
                        (message.operator_uin = $util.Long.fromValue(object.operator_uin)).unsigned = true;
                    else if (typeof object.operator_uin === "string")
                        message.operator_uin = parseInt(object.operator_uin, 10);
                    else if (typeof object.operator_uin === "number")
                        message.operator_uin = object.operator_uin;
                    else if (typeof object.operator_uin === "object")
                        message.operator_uin = new $util.LongBits(object.operator_uin.low >>> 0, object.operator_uin.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                if (object.message_seq != null)
                    if ($util.Long)
                        (message.message_seq = $util.Long.fromValue(object.message_seq)).unsigned = true;
                    else if (typeof object.message_seq === "string")
                        message.message_seq = parseInt(object.message_seq, 10);
                    else if (typeof object.message_seq === "number")
                        message.message_seq = object.message_seq;
                    else if (typeof object.message_seq === "object")
                        message.message_seq = new $util.LongBits(object.message_seq.low >>> 0, object.message_seq.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GroupRecallNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {kritor.event.GroupRecallNotice} message GroupRecallNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupRecallNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.message_id = "";
                    object.tip_text = "";
                    object.operator_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator_uin = options.longs === String ? "0" : 0;
                    object.target_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.target_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.target_uin = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.message_seq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.message_seq = options.longs === String ? "0" : 0;
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    object.message_id = message.message_id;
                if (message.tip_text != null && message.hasOwnProperty("tip_text"))
                    object.tip_text = message.tip_text;
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    object.operator_uid = message.operator_uid;
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (typeof message.operator_uin === "number")
                        object.operator_uin = options.longs === String ? String(message.operator_uin) : message.operator_uin;
                    else
                        object.operator_uin = options.longs === String ? $util.Long.prototype.toString.call(message.operator_uin) : options.longs === Number ? new $util.LongBits(message.operator_uin.low >>> 0, message.operator_uin.high >>> 0).toNumber(true) : message.operator_uin;
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    object.target_uid = message.target_uid;
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                if (message.message_seq != null && message.hasOwnProperty("message_seq"))
                    if (typeof message.message_seq === "number")
                        object.message_seq = options.longs === String ? String(message.message_seq) : message.message_seq;
                    else
                        object.message_seq = options.longs === String ? $util.Long.prototype.toString.call(message.message_seq) : options.longs === Number ? new $util.LongBits(message.message_seq.low >>> 0, message.message_seq.high >>> 0).toNumber(true) : message.message_seq;
                return object;
            };

            /**
             * Converts this GroupRecallNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupRecallNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupRecallNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupRecallNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupRecallNotice";
            };

            return GroupRecallNotice;
        })();

        event.GroupSignInNotice = (function() {

            /**
             * Properties of a GroupSignInNotice.
             * @memberof kritor.event
             * @interface IGroupSignInNotice
             * @property {number|Long|null} [group_id] GroupSignInNotice group_id
             * @property {string|null} [target_uid] GroupSignInNotice target_uid
             * @property {number|Long|null} [target_uin] GroupSignInNotice target_uin
             * @property {string|null} [action] GroupSignInNotice action
             * @property {string|null} [suffix] GroupSignInNotice suffix
             * @property {string|null} [rank_image] GroupSignInNotice rank_image
             */

            /**
             * Constructs a new GroupSignInNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupSignInNotice.
             * @implements IGroupSignInNotice
             * @constructor
             * @param {kritor.event.IGroupSignInNotice=} [properties] Properties to set
             */
            function GroupSignInNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupSignInNotice group_id.
             * @member {number|Long} group_id
             * @memberof kritor.event.GroupSignInNotice
             * @instance
             */
            GroupSignInNotice.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupSignInNotice target_uid.
             * @member {string} target_uid
             * @memberof kritor.event.GroupSignInNotice
             * @instance
             */
            GroupSignInNotice.prototype.target_uid = "";

            /**
             * GroupSignInNotice target_uin.
             * @member {number|Long} target_uin
             * @memberof kritor.event.GroupSignInNotice
             * @instance
             */
            GroupSignInNotice.prototype.target_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupSignInNotice action.
             * @member {string} action
             * @memberof kritor.event.GroupSignInNotice
             * @instance
             */
            GroupSignInNotice.prototype.action = "";

            /**
             * GroupSignInNotice suffix.
             * @member {string} suffix
             * @memberof kritor.event.GroupSignInNotice
             * @instance
             */
            GroupSignInNotice.prototype.suffix = "";

            /**
             * GroupSignInNotice rank_image.
             * @member {string} rank_image
             * @memberof kritor.event.GroupSignInNotice
             * @instance
             */
            GroupSignInNotice.prototype.rank_image = "";

            /**
             * Creates a new GroupSignInNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {kritor.event.IGroupSignInNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupSignInNotice} GroupSignInNotice instance
             */
            GroupSignInNotice.create = function create(properties) {
                return new GroupSignInNotice(properties);
            };

            /**
             * Encodes the specified GroupSignInNotice message. Does not implicitly {@link kritor.event.GroupSignInNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {kritor.event.IGroupSignInNotice} message GroupSignInNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupSignInNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.target_uin);
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.action);
                if (message.suffix != null && Object.hasOwnProperty.call(message, "suffix"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.suffix);
                if (message.rank_image != null && Object.hasOwnProperty.call(message, "rank_image"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.rank_image);
                return writer;
            };

            /**
             * Encodes the specified GroupSignInNotice message, length delimited. Does not implicitly {@link kritor.event.GroupSignInNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {kritor.event.IGroupSignInNotice} message GroupSignInNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupSignInNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupSignInNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupSignInNotice} GroupSignInNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupSignInNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupSignInNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.action = reader.string();
                            break;
                        }
                    case 5: {
                            message.suffix = reader.string();
                            break;
                        }
                    case 6: {
                            message.rank_image = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupSignInNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupSignInNotice} GroupSignInNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupSignInNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupSignInNotice message.
             * @function verify
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupSignInNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                if (message.action != null && message.hasOwnProperty("action"))
                    if (!$util.isString(message.action))
                        return "action: string expected";
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    if (!$util.isString(message.suffix))
                        return "suffix: string expected";
                if (message.rank_image != null && message.hasOwnProperty("rank_image"))
                    if (!$util.isString(message.rank_image))
                        return "rank_image: string expected";
                return null;
            };

            /**
             * Creates a GroupSignInNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupSignInNotice} GroupSignInNotice
             */
            GroupSignInNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupSignInNotice)
                    return object;
                let message = new $root.kritor.event.GroupSignInNotice();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                if (object.action != null)
                    message.action = String(object.action);
                if (object.suffix != null)
                    message.suffix = String(object.suffix);
                if (object.rank_image != null)
                    message.rank_image = String(object.rank_image);
                return message;
            };

            /**
             * Creates a plain object from a GroupSignInNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {kritor.event.GroupSignInNotice} message GroupSignInNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupSignInNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.target_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.target_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.target_uin = options.longs === String ? "0" : 0;
                    object.action = "";
                    object.suffix = "";
                    object.rank_image = "";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.target_uid != null && message.hasOwnProperty("target_uid"))
                    object.target_uid = message.target_uid;
                if (message.target_uin != null && message.hasOwnProperty("target_uin"))
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = message.action;
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    object.suffix = message.suffix;
                if (message.rank_image != null && message.hasOwnProperty("rank_image"))
                    object.rank_image = message.rank_image;
                return object;
            };

            /**
             * Converts this GroupSignInNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupSignInNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupSignInNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupSignInNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupSignInNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupSignInNotice";
            };

            return GroupSignInNotice;
        })();

        event.GroupWholeBanNotice = (function() {

            /**
             * Properties of a GroupWholeBanNotice.
             * @memberof kritor.event
             * @interface IGroupWholeBanNotice
             * @property {number|Long|null} [group_id] GroupWholeBanNotice group_id
             * @property {string|null} [operator_uid] GroupWholeBanNotice operator_uid
             * @property {number|Long|null} [operator_uin] GroupWholeBanNotice operator_uin
             * @property {boolean|null} [is_ban] GroupWholeBanNotice is_ban
             */

            /**
             * Constructs a new GroupWholeBanNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupWholeBanNotice.
             * @implements IGroupWholeBanNotice
             * @constructor
             * @param {kritor.event.IGroupWholeBanNotice=} [properties] Properties to set
             */
            function GroupWholeBanNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupWholeBanNotice group_id.
             * @member {number|Long} group_id
             * @memberof kritor.event.GroupWholeBanNotice
             * @instance
             */
            GroupWholeBanNotice.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupWholeBanNotice operator_uid.
             * @member {string} operator_uid
             * @memberof kritor.event.GroupWholeBanNotice
             * @instance
             */
            GroupWholeBanNotice.prototype.operator_uid = "";

            /**
             * GroupWholeBanNotice operator_uin.
             * @member {number|Long} operator_uin
             * @memberof kritor.event.GroupWholeBanNotice
             * @instance
             */
            GroupWholeBanNotice.prototype.operator_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupWholeBanNotice is_ban.
             * @member {boolean} is_ban
             * @memberof kritor.event.GroupWholeBanNotice
             * @instance
             */
            GroupWholeBanNotice.prototype.is_ban = false;

            /**
             * Creates a new GroupWholeBanNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {kritor.event.IGroupWholeBanNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupWholeBanNotice} GroupWholeBanNotice instance
             */
            GroupWholeBanNotice.create = function create(properties) {
                return new GroupWholeBanNotice(properties);
            };

            /**
             * Encodes the specified GroupWholeBanNotice message. Does not implicitly {@link kritor.event.GroupWholeBanNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {kritor.event.IGroupWholeBanNotice} message GroupWholeBanNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupWholeBanNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.operator_uid != null && Object.hasOwnProperty.call(message, "operator_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operator_uid);
                if (message.operator_uin != null && Object.hasOwnProperty.call(message, "operator_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operator_uin);
                if (message.is_ban != null && Object.hasOwnProperty.call(message, "is_ban"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_ban);
                return writer;
            };

            /**
             * Encodes the specified GroupWholeBanNotice message, length delimited. Does not implicitly {@link kritor.event.GroupWholeBanNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {kritor.event.IGroupWholeBanNotice} message GroupWholeBanNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupWholeBanNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupWholeBanNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupWholeBanNotice} GroupWholeBanNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupWholeBanNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupWholeBanNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operator_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operator_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.is_ban = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupWholeBanNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupWholeBanNotice} GroupWholeBanNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupWholeBanNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupWholeBanNotice message.
             * @function verify
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupWholeBanNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    if (!$util.isString(message.operator_uid))
                        return "operator_uid: string expected";
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (!$util.isInteger(message.operator_uin) && !(message.operator_uin && $util.isInteger(message.operator_uin.low) && $util.isInteger(message.operator_uin.high)))
                        return "operator_uin: integer|Long expected";
                if (message.is_ban != null && message.hasOwnProperty("is_ban"))
                    if (typeof message.is_ban !== "boolean")
                        return "is_ban: boolean expected";
                return null;
            };

            /**
             * Creates a GroupWholeBanNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupWholeBanNotice} GroupWholeBanNotice
             */
            GroupWholeBanNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupWholeBanNotice)
                    return object;
                let message = new $root.kritor.event.GroupWholeBanNotice();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.operator_uid != null)
                    message.operator_uid = String(object.operator_uid);
                if (object.operator_uin != null)
                    if ($util.Long)
                        (message.operator_uin = $util.Long.fromValue(object.operator_uin)).unsigned = true;
                    else if (typeof object.operator_uin === "string")
                        message.operator_uin = parseInt(object.operator_uin, 10);
                    else if (typeof object.operator_uin === "number")
                        message.operator_uin = object.operator_uin;
                    else if (typeof object.operator_uin === "object")
                        message.operator_uin = new $util.LongBits(object.operator_uin.low >>> 0, object.operator_uin.high >>> 0).toNumber(true);
                if (object.is_ban != null)
                    message.is_ban = Boolean(object.is_ban);
                return message;
            };

            /**
             * Creates a plain object from a GroupWholeBanNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {kritor.event.GroupWholeBanNotice} message GroupWholeBanNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupWholeBanNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.operator_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator_uin = options.longs === String ? "0" : 0;
                    object.is_ban = false;
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    object.operator_uid = message.operator_uid;
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (typeof message.operator_uin === "number")
                        object.operator_uin = options.longs === String ? String(message.operator_uin) : message.operator_uin;
                    else
                        object.operator_uin = options.longs === String ? $util.Long.prototype.toString.call(message.operator_uin) : options.longs === Number ? new $util.LongBits(message.operator_uin.low >>> 0, message.operator_uin.high >>> 0).toNumber(true) : message.operator_uin;
                if (message.is_ban != null && message.hasOwnProperty("is_ban"))
                    object.is_ban = message.is_ban;
                return object;
            };

            /**
             * Converts this GroupWholeBanNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupWholeBanNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupWholeBanNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupWholeBanNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupWholeBanNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupWholeBanNotice";
            };

            return GroupWholeBanNotice;
        })();

        event.FriendFileUploadedNotice = (function() {

            /**
             * Properties of a FriendFileUploadedNotice.
             * @memberof kritor.event
             * @interface IFriendFileUploadedNotice
             * @property {string|null} [operator_uid] FriendFileUploadedNotice operator_uid
             * @property {number|Long|null} [operator_uin] FriendFileUploadedNotice operator_uin
             * @property {string|null} [file_id] FriendFileUploadedNotice file_id
             * @property {string|null} [file_sub_id] FriendFileUploadedNotice file_sub_id
             * @property {string|null} [file_name] FriendFileUploadedNotice file_name
             * @property {number|Long|null} [file_size] FriendFileUploadedNotice file_size
             * @property {number|null} [expire_time] FriendFileUploadedNotice expire_time
             * @property {string|null} [url] FriendFileUploadedNotice url
             */

            /**
             * Constructs a new FriendFileUploadedNotice.
             * @memberof kritor.event
             * @classdesc Represents a FriendFileUploadedNotice.
             * @implements IFriendFileUploadedNotice
             * @constructor
             * @param {kritor.event.IFriendFileUploadedNotice=} [properties] Properties to set
             */
            function FriendFileUploadedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendFileUploadedNotice operator_uid.
             * @member {string} operator_uid
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.operator_uid = "";

            /**
             * FriendFileUploadedNotice operator_uin.
             * @member {number|Long} operator_uin
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.operator_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendFileUploadedNotice file_id.
             * @member {string} file_id
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.file_id = "";

            /**
             * FriendFileUploadedNotice file_sub_id.
             * @member {string} file_sub_id
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.file_sub_id = "";

            /**
             * FriendFileUploadedNotice file_name.
             * @member {string} file_name
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.file_name = "";

            /**
             * FriendFileUploadedNotice file_size.
             * @member {number|Long} file_size
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.file_size = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendFileUploadedNotice expire_time.
             * @member {number} expire_time
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.expire_time = 0;

            /**
             * FriendFileUploadedNotice url.
             * @member {string} url
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.url = "";

            /**
             * Creates a new FriendFileUploadedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {kritor.event.IFriendFileUploadedNotice=} [properties] Properties to set
             * @returns {kritor.event.FriendFileUploadedNotice} FriendFileUploadedNotice instance
             */
            FriendFileUploadedNotice.create = function create(properties) {
                return new FriendFileUploadedNotice(properties);
            };

            /**
             * Encodes the specified FriendFileUploadedNotice message. Does not implicitly {@link kritor.event.FriendFileUploadedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {kritor.event.IFriendFileUploadedNotice} message FriendFileUploadedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendFileUploadedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operator_uid != null && Object.hasOwnProperty.call(message, "operator_uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.operator_uid);
                if (message.operator_uin != null && Object.hasOwnProperty.call(message, "operator_uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.operator_uin);
                if (message.file_id != null && Object.hasOwnProperty.call(message, "file_id"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.file_id);
                if (message.file_sub_id != null && Object.hasOwnProperty.call(message, "file_sub_id"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.file_sub_id);
                if (message.file_name != null && Object.hasOwnProperty.call(message, "file_name"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.file_name);
                if (message.file_size != null && Object.hasOwnProperty.call(message, "file_size"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.file_size);
                if (message.expire_time != null && Object.hasOwnProperty.call(message, "expire_time"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.expire_time);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.url);
                return writer;
            };

            /**
             * Encodes the specified FriendFileUploadedNotice message, length delimited. Does not implicitly {@link kritor.event.FriendFileUploadedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {kritor.event.IFriendFileUploadedNotice} message FriendFileUploadedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendFileUploadedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendFileUploadedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.FriendFileUploadedNotice} FriendFileUploadedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendFileUploadedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.FriendFileUploadedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.operator_uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.operator_uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.file_id = reader.string();
                            break;
                        }
                    case 4: {
                            message.file_sub_id = reader.string();
                            break;
                        }
                    case 5: {
                            message.file_name = reader.string();
                            break;
                        }
                    case 6: {
                            message.file_size = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.expire_time = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.url = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendFileUploadedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.FriendFileUploadedNotice} FriendFileUploadedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendFileUploadedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendFileUploadedNotice message.
             * @function verify
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendFileUploadedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    if (!$util.isString(message.operator_uid))
                        return "operator_uid: string expected";
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (!$util.isInteger(message.operator_uin) && !(message.operator_uin && $util.isInteger(message.operator_uin.low) && $util.isInteger(message.operator_uin.high)))
                        return "operator_uin: integer|Long expected";
                if (message.file_id != null && message.hasOwnProperty("file_id"))
                    if (!$util.isString(message.file_id))
                        return "file_id: string expected";
                if (message.file_sub_id != null && message.hasOwnProperty("file_sub_id"))
                    if (!$util.isString(message.file_sub_id))
                        return "file_sub_id: string expected";
                if (message.file_name != null && message.hasOwnProperty("file_name"))
                    if (!$util.isString(message.file_name))
                        return "file_name: string expected";
                if (message.file_size != null && message.hasOwnProperty("file_size"))
                    if (!$util.isInteger(message.file_size) && !(message.file_size && $util.isInteger(message.file_size.low) && $util.isInteger(message.file_size.high)))
                        return "file_size: integer|Long expected";
                if (message.expire_time != null && message.hasOwnProperty("expire_time"))
                    if (!$util.isInteger(message.expire_time))
                        return "expire_time: integer expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                return null;
            };

            /**
             * Creates a FriendFileUploadedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.FriendFileUploadedNotice} FriendFileUploadedNotice
             */
            FriendFileUploadedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.FriendFileUploadedNotice)
                    return object;
                let message = new $root.kritor.event.FriendFileUploadedNotice();
                if (object.operator_uid != null)
                    message.operator_uid = String(object.operator_uid);
                if (object.operator_uin != null)
                    if ($util.Long)
                        (message.operator_uin = $util.Long.fromValue(object.operator_uin)).unsigned = true;
                    else if (typeof object.operator_uin === "string")
                        message.operator_uin = parseInt(object.operator_uin, 10);
                    else if (typeof object.operator_uin === "number")
                        message.operator_uin = object.operator_uin;
                    else if (typeof object.operator_uin === "object")
                        message.operator_uin = new $util.LongBits(object.operator_uin.low >>> 0, object.operator_uin.high >>> 0).toNumber(true);
                if (object.file_id != null)
                    message.file_id = String(object.file_id);
                if (object.file_sub_id != null)
                    message.file_sub_id = String(object.file_sub_id);
                if (object.file_name != null)
                    message.file_name = String(object.file_name);
                if (object.file_size != null)
                    if ($util.Long)
                        (message.file_size = $util.Long.fromValue(object.file_size)).unsigned = true;
                    else if (typeof object.file_size === "string")
                        message.file_size = parseInt(object.file_size, 10);
                    else if (typeof object.file_size === "number")
                        message.file_size = object.file_size;
                    else if (typeof object.file_size === "object")
                        message.file_size = new $util.LongBits(object.file_size.low >>> 0, object.file_size.high >>> 0).toNumber(true);
                if (object.expire_time != null)
                    message.expire_time = object.expire_time >>> 0;
                if (object.url != null)
                    message.url = String(object.url);
                return message;
            };

            /**
             * Creates a plain object from a FriendFileUploadedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {kritor.event.FriendFileUploadedNotice} message FriendFileUploadedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendFileUploadedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.operator_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator_uin = options.longs === String ? "0" : 0;
                    object.file_id = "";
                    object.file_sub_id = "";
                    object.file_name = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.file_size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.file_size = options.longs === String ? "0" : 0;
                    object.expire_time = 0;
                    object.url = "";
                }
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    object.operator_uid = message.operator_uid;
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (typeof message.operator_uin === "number")
                        object.operator_uin = options.longs === String ? String(message.operator_uin) : message.operator_uin;
                    else
                        object.operator_uin = options.longs === String ? $util.Long.prototype.toString.call(message.operator_uin) : options.longs === Number ? new $util.LongBits(message.operator_uin.low >>> 0, message.operator_uin.high >>> 0).toNumber(true) : message.operator_uin;
                if (message.file_id != null && message.hasOwnProperty("file_id"))
                    object.file_id = message.file_id;
                if (message.file_sub_id != null && message.hasOwnProperty("file_sub_id"))
                    object.file_sub_id = message.file_sub_id;
                if (message.file_name != null && message.hasOwnProperty("file_name"))
                    object.file_name = message.file_name;
                if (message.file_size != null && message.hasOwnProperty("file_size"))
                    if (typeof message.file_size === "number")
                        object.file_size = options.longs === String ? String(message.file_size) : message.file_size;
                    else
                        object.file_size = options.longs === String ? $util.Long.prototype.toString.call(message.file_size) : options.longs === Number ? new $util.LongBits(message.file_size.low >>> 0, message.file_size.high >>> 0).toNumber(true) : message.file_size;
                if (message.expire_time != null && message.hasOwnProperty("expire_time"))
                    object.expire_time = message.expire_time;
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                return object;
            };

            /**
             * Converts this FriendFileUploadedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendFileUploadedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendFileUploadedNotice
             * @function getTypeUrl
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendFileUploadedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.FriendFileUploadedNotice";
            };

            return FriendFileUploadedNotice;
        })();

        event.GroupFileUploadedNotice = (function() {

            /**
             * Properties of a GroupFileUploadedNotice.
             * @memberof kritor.event
             * @interface IGroupFileUploadedNotice
             * @property {number|Long|null} [group_id] GroupFileUploadedNotice group_id
             * @property {string|null} [operator_uid] GroupFileUploadedNotice operator_uid
             * @property {number|Long|null} [operator_uin] GroupFileUploadedNotice operator_uin
             * @property {string|null} [file_id] GroupFileUploadedNotice file_id
             * @property {string|null} [file_sub_id] GroupFileUploadedNotice file_sub_id
             * @property {string|null} [file_name] GroupFileUploadedNotice file_name
             * @property {number|Long|null} [file_size] GroupFileUploadedNotice file_size
             * @property {number|null} [expire_time] GroupFileUploadedNotice expire_time
             * @property {number|null} [biz] GroupFileUploadedNotice biz
             * @property {string|null} [url] GroupFileUploadedNotice url
             */

            /**
             * Constructs a new GroupFileUploadedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupFileUploadedNotice.
             * @implements IGroupFileUploadedNotice
             * @constructor
             * @param {kritor.event.IGroupFileUploadedNotice=} [properties] Properties to set
             */
            function GroupFileUploadedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupFileUploadedNotice group_id.
             * @member {number|Long} group_id
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupFileUploadedNotice operator_uid.
             * @member {string} operator_uid
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.operator_uid = "";

            /**
             * GroupFileUploadedNotice operator_uin.
             * @member {number|Long} operator_uin
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.operator_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupFileUploadedNotice file_id.
             * @member {string} file_id
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.file_id = "";

            /**
             * GroupFileUploadedNotice file_sub_id.
             * @member {string} file_sub_id
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.file_sub_id = "";

            /**
             * GroupFileUploadedNotice file_name.
             * @member {string} file_name
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.file_name = "";

            /**
             * GroupFileUploadedNotice file_size.
             * @member {number|Long} file_size
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.file_size = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupFileUploadedNotice expire_time.
             * @member {number} expire_time
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.expire_time = 0;

            /**
             * GroupFileUploadedNotice biz.
             * @member {number} biz
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.biz = 0;

            /**
             * GroupFileUploadedNotice url.
             * @member {string} url
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.url = "";

            /**
             * Creates a new GroupFileUploadedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {kritor.event.IGroupFileUploadedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupFileUploadedNotice} GroupFileUploadedNotice instance
             */
            GroupFileUploadedNotice.create = function create(properties) {
                return new GroupFileUploadedNotice(properties);
            };

            /**
             * Encodes the specified GroupFileUploadedNotice message. Does not implicitly {@link kritor.event.GroupFileUploadedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {kritor.event.IGroupFileUploadedNotice} message GroupFileUploadedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupFileUploadedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.operator_uid != null && Object.hasOwnProperty.call(message, "operator_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operator_uid);
                if (message.operator_uin != null && Object.hasOwnProperty.call(message, "operator_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operator_uin);
                if (message.file_id != null && Object.hasOwnProperty.call(message, "file_id"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.file_id);
                if (message.file_sub_id != null && Object.hasOwnProperty.call(message, "file_sub_id"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.file_sub_id);
                if (message.file_name != null && Object.hasOwnProperty.call(message, "file_name"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.file_name);
                if (message.file_size != null && Object.hasOwnProperty.call(message, "file_size"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.file_size);
                if (message.expire_time != null && Object.hasOwnProperty.call(message, "expire_time"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.expire_time);
                if (message.biz != null && Object.hasOwnProperty.call(message, "biz"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.biz);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.url);
                return writer;
            };

            /**
             * Encodes the specified GroupFileUploadedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupFileUploadedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {kritor.event.IGroupFileUploadedNotice} message GroupFileUploadedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupFileUploadedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupFileUploadedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupFileUploadedNotice} GroupFileUploadedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupFileUploadedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupFileUploadedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operator_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operator_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.file_id = reader.string();
                            break;
                        }
                    case 5: {
                            message.file_sub_id = reader.string();
                            break;
                        }
                    case 6: {
                            message.file_name = reader.string();
                            break;
                        }
                    case 7: {
                            message.file_size = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.expire_time = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.biz = reader.int32();
                            break;
                        }
                    case 10: {
                            message.url = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupFileUploadedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupFileUploadedNotice} GroupFileUploadedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupFileUploadedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupFileUploadedNotice message.
             * @function verify
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupFileUploadedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    if (!$util.isString(message.operator_uid))
                        return "operator_uid: string expected";
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (!$util.isInteger(message.operator_uin) && !(message.operator_uin && $util.isInteger(message.operator_uin.low) && $util.isInteger(message.operator_uin.high)))
                        return "operator_uin: integer|Long expected";
                if (message.file_id != null && message.hasOwnProperty("file_id"))
                    if (!$util.isString(message.file_id))
                        return "file_id: string expected";
                if (message.file_sub_id != null && message.hasOwnProperty("file_sub_id"))
                    if (!$util.isString(message.file_sub_id))
                        return "file_sub_id: string expected";
                if (message.file_name != null && message.hasOwnProperty("file_name"))
                    if (!$util.isString(message.file_name))
                        return "file_name: string expected";
                if (message.file_size != null && message.hasOwnProperty("file_size"))
                    if (!$util.isInteger(message.file_size) && !(message.file_size && $util.isInteger(message.file_size.low) && $util.isInteger(message.file_size.high)))
                        return "file_size: integer|Long expected";
                if (message.expire_time != null && message.hasOwnProperty("expire_time"))
                    if (!$util.isInteger(message.expire_time))
                        return "expire_time: integer expected";
                if (message.biz != null && message.hasOwnProperty("biz"))
                    if (!$util.isInteger(message.biz))
                        return "biz: integer expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                return null;
            };

            /**
             * Creates a GroupFileUploadedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupFileUploadedNotice} GroupFileUploadedNotice
             */
            GroupFileUploadedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupFileUploadedNotice)
                    return object;
                let message = new $root.kritor.event.GroupFileUploadedNotice();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.operator_uid != null)
                    message.operator_uid = String(object.operator_uid);
                if (object.operator_uin != null)
                    if ($util.Long)
                        (message.operator_uin = $util.Long.fromValue(object.operator_uin)).unsigned = true;
                    else if (typeof object.operator_uin === "string")
                        message.operator_uin = parseInt(object.operator_uin, 10);
                    else if (typeof object.operator_uin === "number")
                        message.operator_uin = object.operator_uin;
                    else if (typeof object.operator_uin === "object")
                        message.operator_uin = new $util.LongBits(object.operator_uin.low >>> 0, object.operator_uin.high >>> 0).toNumber(true);
                if (object.file_id != null)
                    message.file_id = String(object.file_id);
                if (object.file_sub_id != null)
                    message.file_sub_id = String(object.file_sub_id);
                if (object.file_name != null)
                    message.file_name = String(object.file_name);
                if (object.file_size != null)
                    if ($util.Long)
                        (message.file_size = $util.Long.fromValue(object.file_size)).unsigned = true;
                    else if (typeof object.file_size === "string")
                        message.file_size = parseInt(object.file_size, 10);
                    else if (typeof object.file_size === "number")
                        message.file_size = object.file_size;
                    else if (typeof object.file_size === "object")
                        message.file_size = new $util.LongBits(object.file_size.low >>> 0, object.file_size.high >>> 0).toNumber(true);
                if (object.expire_time != null)
                    message.expire_time = object.expire_time >>> 0;
                if (object.biz != null)
                    message.biz = object.biz | 0;
                if (object.url != null)
                    message.url = String(object.url);
                return message;
            };

            /**
             * Creates a plain object from a GroupFileUploadedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {kritor.event.GroupFileUploadedNotice} message GroupFileUploadedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupFileUploadedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.operator_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator_uin = options.longs === String ? "0" : 0;
                    object.file_id = "";
                    object.file_sub_id = "";
                    object.file_name = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.file_size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.file_size = options.longs === String ? "0" : 0;
                    object.expire_time = 0;
                    object.biz = 0;
                    object.url = "";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.operator_uid != null && message.hasOwnProperty("operator_uid"))
                    object.operator_uid = message.operator_uid;
                if (message.operator_uin != null && message.hasOwnProperty("operator_uin"))
                    if (typeof message.operator_uin === "number")
                        object.operator_uin = options.longs === String ? String(message.operator_uin) : message.operator_uin;
                    else
                        object.operator_uin = options.longs === String ? $util.Long.prototype.toString.call(message.operator_uin) : options.longs === Number ? new $util.LongBits(message.operator_uin.low >>> 0, message.operator_uin.high >>> 0).toNumber(true) : message.operator_uin;
                if (message.file_id != null && message.hasOwnProperty("file_id"))
                    object.file_id = message.file_id;
                if (message.file_sub_id != null && message.hasOwnProperty("file_sub_id"))
                    object.file_sub_id = message.file_sub_id;
                if (message.file_name != null && message.hasOwnProperty("file_name"))
                    object.file_name = message.file_name;
                if (message.file_size != null && message.hasOwnProperty("file_size"))
                    if (typeof message.file_size === "number")
                        object.file_size = options.longs === String ? String(message.file_size) : message.file_size;
                    else
                        object.file_size = options.longs === String ? $util.Long.prototype.toString.call(message.file_size) : options.longs === Number ? new $util.LongBits(message.file_size.low >>> 0, message.file_size.high >>> 0).toNumber(true) : message.file_size;
                if (message.expire_time != null && message.hasOwnProperty("expire_time"))
                    object.expire_time = message.expire_time;
                if (message.biz != null && message.hasOwnProperty("biz"))
                    object.biz = message.biz;
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                return object;
            };

            /**
             * Converts this GroupFileUploadedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupFileUploadedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupFileUploadedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupFileUploadedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupFileUploadedNotice";
            };

            return GroupFileUploadedNotice;
        })();

        event.RequestEvent = (function() {

            /**
             * Properties of a RequestEvent.
             * @memberof kritor.event
             * @interface IRequestEvent
             * @property {kritor.event.RequestEvent.RequestType|null} [type] RequestEvent type
             * @property {number|null} [time] RequestEvent time
             * @property {string|null} [request_id] RequestEvent request_id
             * @property {kritor.event.IFriendApplyRequest|null} [friend_apply] RequestEvent friend_apply
             * @property {kritor.event.IGroupApplyRequest|null} [group_apply] RequestEvent group_apply
             * @property {kritor.event.IInvitedJoinGroupRequest|null} [invited_group] RequestEvent invited_group
             */

            /**
             * Constructs a new RequestEvent.
             * @memberof kritor.event
             * @classdesc Represents a RequestEvent.
             * @implements IRequestEvent
             * @constructor
             * @param {kritor.event.IRequestEvent=} [properties] Properties to set
             */
            function RequestEvent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RequestEvent type.
             * @member {kritor.event.RequestEvent.RequestType} type
             * @memberof kritor.event.RequestEvent
             * @instance
             */
            RequestEvent.prototype.type = 0;

            /**
             * RequestEvent time.
             * @member {number} time
             * @memberof kritor.event.RequestEvent
             * @instance
             */
            RequestEvent.prototype.time = 0;

            /**
             * RequestEvent request_id.
             * @member {string} request_id
             * @memberof kritor.event.RequestEvent
             * @instance
             */
            RequestEvent.prototype.request_id = "";

            /**
             * RequestEvent friend_apply.
             * @member {kritor.event.IFriendApplyRequest|null|undefined} friend_apply
             * @memberof kritor.event.RequestEvent
             * @instance
             */
            RequestEvent.prototype.friend_apply = null;

            /**
             * RequestEvent group_apply.
             * @member {kritor.event.IGroupApplyRequest|null|undefined} group_apply
             * @memberof kritor.event.RequestEvent
             * @instance
             */
            RequestEvent.prototype.group_apply = null;

            /**
             * RequestEvent invited_group.
             * @member {kritor.event.IInvitedJoinGroupRequest|null|undefined} invited_group
             * @memberof kritor.event.RequestEvent
             * @instance
             */
            RequestEvent.prototype.invited_group = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * RequestEvent request.
             * @member {"friend_apply"|"group_apply"|"invited_group"|undefined} request
             * @memberof kritor.event.RequestEvent
             * @instance
             */
            Object.defineProperty(RequestEvent.prototype, "request", {
                get: $util.oneOfGetter($oneOfFields = ["friend_apply", "group_apply", "invited_group"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new RequestEvent instance using the specified properties.
             * @function create
             * @memberof kritor.event.RequestEvent
             * @static
             * @param {kritor.event.IRequestEvent=} [properties] Properties to set
             * @returns {kritor.event.RequestEvent} RequestEvent instance
             */
            RequestEvent.create = function create(properties) {
                return new RequestEvent(properties);
            };

            /**
             * Encodes the specified RequestEvent message. Does not implicitly {@link kritor.event.RequestEvent.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.RequestEvent
             * @static
             * @param {kritor.event.IRequestEvent} message RequestEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.time);
                if (message.request_id != null && Object.hasOwnProperty.call(message, "request_id"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.request_id);
                if (message.friend_apply != null && Object.hasOwnProperty.call(message, "friend_apply"))
                    $root.kritor.event.FriendApplyRequest.encode(message.friend_apply, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.group_apply != null && Object.hasOwnProperty.call(message, "group_apply"))
                    $root.kritor.event.GroupApplyRequest.encode(message.group_apply, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.invited_group != null && Object.hasOwnProperty.call(message, "invited_group"))
                    $root.kritor.event.InvitedJoinGroupRequest.encode(message.invited_group, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RequestEvent message, length delimited. Does not implicitly {@link kritor.event.RequestEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.RequestEvent
             * @static
             * @param {kritor.event.IRequestEvent} message RequestEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RequestEvent message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.RequestEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.RequestEvent} RequestEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.RequestEvent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.time = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.request_id = reader.string();
                            break;
                        }
                    case 10: {
                            message.friend_apply = $root.kritor.event.FriendApplyRequest.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.group_apply = $root.kritor.event.GroupApplyRequest.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.invited_group = $root.kritor.event.InvitedJoinGroupRequest.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RequestEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.RequestEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.RequestEvent} RequestEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RequestEvent message.
             * @function verify
             * @memberof kritor.event.RequestEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RequestEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time))
                        return "time: integer expected";
                if (message.request_id != null && message.hasOwnProperty("request_id"))
                    if (!$util.isString(message.request_id))
                        return "request_id: string expected";
                if (message.friend_apply != null && message.hasOwnProperty("friend_apply")) {
                    properties.request = 1;
                    {
                        let error = $root.kritor.event.FriendApplyRequest.verify(message.friend_apply);
                        if (error)
                            return "friend_apply." + error;
                    }
                }
                if (message.group_apply != null && message.hasOwnProperty("group_apply")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        let error = $root.kritor.event.GroupApplyRequest.verify(message.group_apply);
                        if (error)
                            return "group_apply." + error;
                    }
                }
                if (message.invited_group != null && message.hasOwnProperty("invited_group")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        let error = $root.kritor.event.InvitedJoinGroupRequest.verify(message.invited_group);
                        if (error)
                            return "invited_group." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a RequestEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.RequestEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.RequestEvent} RequestEvent
             */
            RequestEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.RequestEvent)
                    return object;
                let message = new $root.kritor.event.RequestEvent();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "FRIEND_APPLY":
                case 0:
                    message.type = 0;
                    break;
                case "GROUP_APPLY":
                case 1:
                    message.type = 1;
                    break;
                case "INVITED_GROUP":
                case 2:
                    message.type = 2;
                    break;
                }
                if (object.time != null)
                    message.time = object.time >>> 0;
                if (object.request_id != null)
                    message.request_id = String(object.request_id);
                if (object.friend_apply != null) {
                    if (typeof object.friend_apply !== "object")
                        throw TypeError(".kritor.event.RequestEvent.friend_apply: object expected");
                    message.friend_apply = $root.kritor.event.FriendApplyRequest.fromObject(object.friend_apply);
                }
                if (object.group_apply != null) {
                    if (typeof object.group_apply !== "object")
                        throw TypeError(".kritor.event.RequestEvent.group_apply: object expected");
                    message.group_apply = $root.kritor.event.GroupApplyRequest.fromObject(object.group_apply);
                }
                if (object.invited_group != null) {
                    if (typeof object.invited_group !== "object")
                        throw TypeError(".kritor.event.RequestEvent.invited_group: object expected");
                    message.invited_group = $root.kritor.event.InvitedJoinGroupRequest.fromObject(object.invited_group);
                }
                return message;
            };

            /**
             * Creates a plain object from a RequestEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.RequestEvent
             * @static
             * @param {kritor.event.RequestEvent} message RequestEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RequestEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "FRIEND_APPLY" : 0;
                    object.time = 0;
                    object.request_id = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.RequestEvent.RequestType[message.type] === undefined ? message.type : $root.kritor.event.RequestEvent.RequestType[message.type] : message.type;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = message.time;
                if (message.request_id != null && message.hasOwnProperty("request_id"))
                    object.request_id = message.request_id;
                if (message.friend_apply != null && message.hasOwnProperty("friend_apply")) {
                    object.friend_apply = $root.kritor.event.FriendApplyRequest.toObject(message.friend_apply, options);
                    if (options.oneofs)
                        object.request = "friend_apply";
                }
                if (message.group_apply != null && message.hasOwnProperty("group_apply")) {
                    object.group_apply = $root.kritor.event.GroupApplyRequest.toObject(message.group_apply, options);
                    if (options.oneofs)
                        object.request = "group_apply";
                }
                if (message.invited_group != null && message.hasOwnProperty("invited_group")) {
                    object.invited_group = $root.kritor.event.InvitedJoinGroupRequest.toObject(message.invited_group, options);
                    if (options.oneofs)
                        object.request = "invited_group";
                }
                return object;
            };

            /**
             * Converts this RequestEvent to JSON.
             * @function toJSON
             * @memberof kritor.event.RequestEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RequestEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RequestEvent
             * @function getTypeUrl
             * @memberof kritor.event.RequestEvent
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RequestEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.RequestEvent";
            };

            /**
             * RequestType enum.
             * @name kritor.event.RequestEvent.RequestType
             * @enum {number}
             * @property {number} FRIEND_APPLY=0 FRIEND_APPLY value
             * @property {number} GROUP_APPLY=1 GROUP_APPLY value
             * @property {number} INVITED_GROUP=2 INVITED_GROUP value
             */
            RequestEvent.RequestType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "FRIEND_APPLY"] = 0;
                values[valuesById[1] = "GROUP_APPLY"] = 1;
                values[valuesById[2] = "INVITED_GROUP"] = 2;
                return values;
            })();

            return RequestEvent;
        })();

        event.FriendApplyRequest = (function() {

            /**
             * Properties of a FriendApplyRequest.
             * @memberof kritor.event
             * @interface IFriendApplyRequest
             * @property {string|null} [applier_uid] FriendApplyRequest applier_uid
             * @property {number|Long|null} [applier_uin] FriendApplyRequest applier_uin
             * @property {string|null} [message] FriendApplyRequest message
             */

            /**
             * Constructs a new FriendApplyRequest.
             * @memberof kritor.event
             * @classdesc Represents a FriendApplyRequest.
             * @implements IFriendApplyRequest
             * @constructor
             * @param {kritor.event.IFriendApplyRequest=} [properties] Properties to set
             */
            function FriendApplyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendApplyRequest applier_uid.
             * @member {string} applier_uid
             * @memberof kritor.event.FriendApplyRequest
             * @instance
             */
            FriendApplyRequest.prototype.applier_uid = "";

            /**
             * FriendApplyRequest applier_uin.
             * @member {number|Long} applier_uin
             * @memberof kritor.event.FriendApplyRequest
             * @instance
             */
            FriendApplyRequest.prototype.applier_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendApplyRequest message.
             * @member {string} message
             * @memberof kritor.event.FriendApplyRequest
             * @instance
             */
            FriendApplyRequest.prototype.message = "";

            /**
             * Creates a new FriendApplyRequest instance using the specified properties.
             * @function create
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {kritor.event.IFriendApplyRequest=} [properties] Properties to set
             * @returns {kritor.event.FriendApplyRequest} FriendApplyRequest instance
             */
            FriendApplyRequest.create = function create(properties) {
                return new FriendApplyRequest(properties);
            };

            /**
             * Encodes the specified FriendApplyRequest message. Does not implicitly {@link kritor.event.FriendApplyRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {kritor.event.IFriendApplyRequest} message FriendApplyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendApplyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.applier_uid != null && Object.hasOwnProperty.call(message, "applier_uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.applier_uid);
                if (message.applier_uin != null && Object.hasOwnProperty.call(message, "applier_uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.applier_uin);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.message);
                return writer;
            };

            /**
             * Encodes the specified FriendApplyRequest message, length delimited. Does not implicitly {@link kritor.event.FriendApplyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {kritor.event.IFriendApplyRequest} message FriendApplyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendApplyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendApplyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.FriendApplyRequest} FriendApplyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendApplyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.FriendApplyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.applier_uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.applier_uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.message = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendApplyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.FriendApplyRequest} FriendApplyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendApplyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendApplyRequest message.
             * @function verify
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendApplyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.applier_uid != null && message.hasOwnProperty("applier_uid"))
                    if (!$util.isString(message.applier_uid))
                        return "applier_uid: string expected";
                if (message.applier_uin != null && message.hasOwnProperty("applier_uin"))
                    if (!$util.isInteger(message.applier_uin) && !(message.applier_uin && $util.isInteger(message.applier_uin.low) && $util.isInteger(message.applier_uin.high)))
                        return "applier_uin: integer|Long expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                return null;
            };

            /**
             * Creates a FriendApplyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.FriendApplyRequest} FriendApplyRequest
             */
            FriendApplyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.FriendApplyRequest)
                    return object;
                let message = new $root.kritor.event.FriendApplyRequest();
                if (object.applier_uid != null)
                    message.applier_uid = String(object.applier_uid);
                if (object.applier_uin != null)
                    if ($util.Long)
                        (message.applier_uin = $util.Long.fromValue(object.applier_uin)).unsigned = true;
                    else if (typeof object.applier_uin === "string")
                        message.applier_uin = parseInt(object.applier_uin, 10);
                    else if (typeof object.applier_uin === "number")
                        message.applier_uin = object.applier_uin;
                    else if (typeof object.applier_uin === "object")
                        message.applier_uin = new $util.LongBits(object.applier_uin.low >>> 0, object.applier_uin.high >>> 0).toNumber(true);
                if (object.message != null)
                    message.message = String(object.message);
                return message;
            };

            /**
             * Creates a plain object from a FriendApplyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {kritor.event.FriendApplyRequest} message FriendApplyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendApplyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.applier_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.applier_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.applier_uin = options.longs === String ? "0" : 0;
                    object.message = "";
                }
                if (message.applier_uid != null && message.hasOwnProperty("applier_uid"))
                    object.applier_uid = message.applier_uid;
                if (message.applier_uin != null && message.hasOwnProperty("applier_uin"))
                    if (typeof message.applier_uin === "number")
                        object.applier_uin = options.longs === String ? String(message.applier_uin) : message.applier_uin;
                    else
                        object.applier_uin = options.longs === String ? $util.Long.prototype.toString.call(message.applier_uin) : options.longs === Number ? new $util.LongBits(message.applier_uin.low >>> 0, message.applier_uin.high >>> 0).toNumber(true) : message.applier_uin;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                return object;
            };

            /**
             * Converts this FriendApplyRequest to JSON.
             * @function toJSON
             * @memberof kritor.event.FriendApplyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendApplyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendApplyRequest
             * @function getTypeUrl
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendApplyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.FriendApplyRequest";
            };

            return FriendApplyRequest;
        })();

        event.GroupApplyRequest = (function() {

            /**
             * Properties of a GroupApplyRequest.
             * @memberof kritor.event
             * @interface IGroupApplyRequest
             * @property {number|Long|null} [group_id] GroupApplyRequest group_id
             * @property {string|null} [applier_uid] GroupApplyRequest applier_uid
             * @property {number|Long|null} [applier_uin] GroupApplyRequest applier_uin
             * @property {string|null} [inviter_uid] GroupApplyRequest inviter_uid
             * @property {number|Long|null} [inviter_uin] GroupApplyRequest inviter_uin
             * @property {string|null} [reason] GroupApplyRequest reason
             */

            /**
             * Constructs a new GroupApplyRequest.
             * @memberof kritor.event
             * @classdesc Represents a GroupApplyRequest.
             * @implements IGroupApplyRequest
             * @constructor
             * @param {kritor.event.IGroupApplyRequest=} [properties] Properties to set
             */
            function GroupApplyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupApplyRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupApplyRequest applier_uid.
             * @member {string} applier_uid
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.applier_uid = "";

            /**
             * GroupApplyRequest applier_uin.
             * @member {number|Long} applier_uin
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.applier_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupApplyRequest inviter_uid.
             * @member {string} inviter_uid
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.inviter_uid = "";

            /**
             * GroupApplyRequest inviter_uin.
             * @member {number|Long} inviter_uin
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.inviter_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupApplyRequest reason.
             * @member {string} reason
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.reason = "";

            /**
             * Creates a new GroupApplyRequest instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {kritor.event.IGroupApplyRequest=} [properties] Properties to set
             * @returns {kritor.event.GroupApplyRequest} GroupApplyRequest instance
             */
            GroupApplyRequest.create = function create(properties) {
                return new GroupApplyRequest(properties);
            };

            /**
             * Encodes the specified GroupApplyRequest message. Does not implicitly {@link kritor.event.GroupApplyRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {kritor.event.IGroupApplyRequest} message GroupApplyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupApplyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.applier_uid != null && Object.hasOwnProperty.call(message, "applier_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.applier_uid);
                if (message.applier_uin != null && Object.hasOwnProperty.call(message, "applier_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.applier_uin);
                if (message.inviter_uid != null && Object.hasOwnProperty.call(message, "inviter_uid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.inviter_uid);
                if (message.inviter_uin != null && Object.hasOwnProperty.call(message, "inviter_uin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.inviter_uin);
                if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.reason);
                return writer;
            };

            /**
             * Encodes the specified GroupApplyRequest message, length delimited. Does not implicitly {@link kritor.event.GroupApplyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {kritor.event.IGroupApplyRequest} message GroupApplyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupApplyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupApplyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupApplyRequest} GroupApplyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupApplyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupApplyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.applier_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.applier_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.inviter_uid = reader.string();
                            break;
                        }
                    case 5: {
                            message.inviter_uin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.reason = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupApplyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupApplyRequest} GroupApplyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupApplyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupApplyRequest message.
             * @function verify
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupApplyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.applier_uid != null && message.hasOwnProperty("applier_uid"))
                    if (!$util.isString(message.applier_uid))
                        return "applier_uid: string expected";
                if (message.applier_uin != null && message.hasOwnProperty("applier_uin"))
                    if (!$util.isInteger(message.applier_uin) && !(message.applier_uin && $util.isInteger(message.applier_uin.low) && $util.isInteger(message.applier_uin.high)))
                        return "applier_uin: integer|Long expected";
                if (message.inviter_uid != null && message.hasOwnProperty("inviter_uid"))
                    if (!$util.isString(message.inviter_uid))
                        return "inviter_uid: string expected";
                if (message.inviter_uin != null && message.hasOwnProperty("inviter_uin"))
                    if (!$util.isInteger(message.inviter_uin) && !(message.inviter_uin && $util.isInteger(message.inviter_uin.low) && $util.isInteger(message.inviter_uin.high)))
                        return "inviter_uin: integer|Long expected";
                if (message.reason != null && message.hasOwnProperty("reason"))
                    if (!$util.isString(message.reason))
                        return "reason: string expected";
                return null;
            };

            /**
             * Creates a GroupApplyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupApplyRequest} GroupApplyRequest
             */
            GroupApplyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupApplyRequest)
                    return object;
                let message = new $root.kritor.event.GroupApplyRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.applier_uid != null)
                    message.applier_uid = String(object.applier_uid);
                if (object.applier_uin != null)
                    if ($util.Long)
                        (message.applier_uin = $util.Long.fromValue(object.applier_uin)).unsigned = true;
                    else if (typeof object.applier_uin === "string")
                        message.applier_uin = parseInt(object.applier_uin, 10);
                    else if (typeof object.applier_uin === "number")
                        message.applier_uin = object.applier_uin;
                    else if (typeof object.applier_uin === "object")
                        message.applier_uin = new $util.LongBits(object.applier_uin.low >>> 0, object.applier_uin.high >>> 0).toNumber(true);
                if (object.inviter_uid != null)
                    message.inviter_uid = String(object.inviter_uid);
                if (object.inviter_uin != null)
                    if ($util.Long)
                        (message.inviter_uin = $util.Long.fromValue(object.inviter_uin)).unsigned = true;
                    else if (typeof object.inviter_uin === "string")
                        message.inviter_uin = parseInt(object.inviter_uin, 10);
                    else if (typeof object.inviter_uin === "number")
                        message.inviter_uin = object.inviter_uin;
                    else if (typeof object.inviter_uin === "object")
                        message.inviter_uin = new $util.LongBits(object.inviter_uin.low >>> 0, object.inviter_uin.high >>> 0).toNumber(true);
                if (object.reason != null)
                    message.reason = String(object.reason);
                return message;
            };

            /**
             * Creates a plain object from a GroupApplyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {kritor.event.GroupApplyRequest} message GroupApplyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupApplyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.applier_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.applier_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.applier_uin = options.longs === String ? "0" : 0;
                    object.inviter_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.inviter_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.inviter_uin = options.longs === String ? "0" : 0;
                    object.reason = "";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.applier_uid != null && message.hasOwnProperty("applier_uid"))
                    object.applier_uid = message.applier_uid;
                if (message.applier_uin != null && message.hasOwnProperty("applier_uin"))
                    if (typeof message.applier_uin === "number")
                        object.applier_uin = options.longs === String ? String(message.applier_uin) : message.applier_uin;
                    else
                        object.applier_uin = options.longs === String ? $util.Long.prototype.toString.call(message.applier_uin) : options.longs === Number ? new $util.LongBits(message.applier_uin.low >>> 0, message.applier_uin.high >>> 0).toNumber(true) : message.applier_uin;
                if (message.inviter_uid != null && message.hasOwnProperty("inviter_uid"))
                    object.inviter_uid = message.inviter_uid;
                if (message.inviter_uin != null && message.hasOwnProperty("inviter_uin"))
                    if (typeof message.inviter_uin === "number")
                        object.inviter_uin = options.longs === String ? String(message.inviter_uin) : message.inviter_uin;
                    else
                        object.inviter_uin = options.longs === String ? $util.Long.prototype.toString.call(message.inviter_uin) : options.longs === Number ? new $util.LongBits(message.inviter_uin.low >>> 0, message.inviter_uin.high >>> 0).toNumber(true) : message.inviter_uin;
                if (message.reason != null && message.hasOwnProperty("reason"))
                    object.reason = message.reason;
                return object;
            };

            /**
             * Converts this GroupApplyRequest to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupApplyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupApplyRequest
             * @function getTypeUrl
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupApplyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupApplyRequest";
            };

            return GroupApplyRequest;
        })();

        event.InvitedJoinGroupRequest = (function() {

            /**
             * Properties of an InvitedJoinGroupRequest.
             * @memberof kritor.event
             * @interface IInvitedJoinGroupRequest
             * @property {number|Long|null} [group_id] InvitedJoinGroupRequest group_id
             * @property {string|null} [inviter_uid] InvitedJoinGroupRequest inviter_uid
             * @property {number|Long|null} [inviter_uin] InvitedJoinGroupRequest inviter_uin
             */

            /**
             * Constructs a new InvitedJoinGroupRequest.
             * @memberof kritor.event
             * @classdesc Represents an InvitedJoinGroupRequest.
             * @implements IInvitedJoinGroupRequest
             * @constructor
             * @param {kritor.event.IInvitedJoinGroupRequest=} [properties] Properties to set
             */
            function InvitedJoinGroupRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InvitedJoinGroupRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @instance
             */
            InvitedJoinGroupRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * InvitedJoinGroupRequest inviter_uid.
             * @member {string} inviter_uid
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @instance
             */
            InvitedJoinGroupRequest.prototype.inviter_uid = "";

            /**
             * InvitedJoinGroupRequest inviter_uin.
             * @member {number|Long} inviter_uin
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @instance
             */
            InvitedJoinGroupRequest.prototype.inviter_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new InvitedJoinGroupRequest instance using the specified properties.
             * @function create
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {kritor.event.IInvitedJoinGroupRequest=} [properties] Properties to set
             * @returns {kritor.event.InvitedJoinGroupRequest} InvitedJoinGroupRequest instance
             */
            InvitedJoinGroupRequest.create = function create(properties) {
                return new InvitedJoinGroupRequest(properties);
            };

            /**
             * Encodes the specified InvitedJoinGroupRequest message. Does not implicitly {@link kritor.event.InvitedJoinGroupRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {kritor.event.IInvitedJoinGroupRequest} message InvitedJoinGroupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InvitedJoinGroupRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.inviter_uid != null && Object.hasOwnProperty.call(message, "inviter_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inviter_uid);
                if (message.inviter_uin != null && Object.hasOwnProperty.call(message, "inviter_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.inviter_uin);
                return writer;
            };

            /**
             * Encodes the specified InvitedJoinGroupRequest message, length delimited. Does not implicitly {@link kritor.event.InvitedJoinGroupRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {kritor.event.IInvitedJoinGroupRequest} message InvitedJoinGroupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InvitedJoinGroupRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InvitedJoinGroupRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.InvitedJoinGroupRequest} InvitedJoinGroupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InvitedJoinGroupRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.InvitedJoinGroupRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.inviter_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.inviter_uin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InvitedJoinGroupRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.InvitedJoinGroupRequest} InvitedJoinGroupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InvitedJoinGroupRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InvitedJoinGroupRequest message.
             * @function verify
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InvitedJoinGroupRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.inviter_uid != null && message.hasOwnProperty("inviter_uid"))
                    if (!$util.isString(message.inviter_uid))
                        return "inviter_uid: string expected";
                if (message.inviter_uin != null && message.hasOwnProperty("inviter_uin"))
                    if (!$util.isInteger(message.inviter_uin) && !(message.inviter_uin && $util.isInteger(message.inviter_uin.low) && $util.isInteger(message.inviter_uin.high)))
                        return "inviter_uin: integer|Long expected";
                return null;
            };

            /**
             * Creates an InvitedJoinGroupRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.InvitedJoinGroupRequest} InvitedJoinGroupRequest
             */
            InvitedJoinGroupRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.InvitedJoinGroupRequest)
                    return object;
                let message = new $root.kritor.event.InvitedJoinGroupRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.inviter_uid != null)
                    message.inviter_uid = String(object.inviter_uid);
                if (object.inviter_uin != null)
                    if ($util.Long)
                        (message.inviter_uin = $util.Long.fromValue(object.inviter_uin)).unsigned = true;
                    else if (typeof object.inviter_uin === "string")
                        message.inviter_uin = parseInt(object.inviter_uin, 10);
                    else if (typeof object.inviter_uin === "number")
                        message.inviter_uin = object.inviter_uin;
                    else if (typeof object.inviter_uin === "object")
                        message.inviter_uin = new $util.LongBits(object.inviter_uin.low >>> 0, object.inviter_uin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an InvitedJoinGroupRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {kritor.event.InvitedJoinGroupRequest} message InvitedJoinGroupRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InvitedJoinGroupRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.inviter_uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.inviter_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.inviter_uin = options.longs === String ? "0" : 0;
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.inviter_uid != null && message.hasOwnProperty("inviter_uid"))
                    object.inviter_uid = message.inviter_uid;
                if (message.inviter_uin != null && message.hasOwnProperty("inviter_uin"))
                    if (typeof message.inviter_uin === "number")
                        object.inviter_uin = options.longs === String ? String(message.inviter_uin) : message.inviter_uin;
                    else
                        object.inviter_uin = options.longs === String ? $util.Long.prototype.toString.call(message.inviter_uin) : options.longs === Number ? new $util.LongBits(message.inviter_uin.low >>> 0, message.inviter_uin.high >>> 0).toNumber(true) : message.inviter_uin;
                return object;
            };

            /**
             * Converts this InvitedJoinGroupRequest to JSON.
             * @function toJSON
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InvitedJoinGroupRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for InvitedJoinGroupRequest
             * @function getTypeUrl
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            InvitedJoinGroupRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.InvitedJoinGroupRequest";
            };

            return InvitedJoinGroupRequest;
        })();

        return event;
    })();

    kritor.file = (function() {

        /**
         * Namespace file.
         * @memberof kritor
         * @namespace
         */
        const file = {};

        file.File = (function() {

            /**
             * Properties of a File.
             * @memberof kritor.file
             * @interface IFile
             * @property {string|null} [file_id] File file_id
             * @property {string|null} [file_name] File file_name
             * @property {number|Long|null} [file_size] File file_size
             * @property {number|null} [bus_id] File bus_id
             * @property {number|null} [upload_time] File upload_time
             * @property {number|null} [dead_time] File dead_time
             * @property {number|null} [modify_time] File modify_time
             * @property {number|null} [download_times] File download_times
             * @property {number|Long|null} [uploader] File uploader
             * @property {string|null} [uploader_name] File uploader_name
             * @property {string|null} [sha] File sha
             * @property {string|null} [sha3] File sha3
             * @property {string|null} [md5] File md5
             */

            /**
             * Constructs a new File.
             * @memberof kritor.file
             * @classdesc Represents a File.
             * @implements IFile
             * @constructor
             * @param {kritor.file.IFile=} [properties] Properties to set
             */
            function File(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * File file_id.
             * @member {string} file_id
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.file_id = "";

            /**
             * File file_name.
             * @member {string} file_name
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.file_name = "";

            /**
             * File file_size.
             * @member {number|Long} file_size
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.file_size = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * File bus_id.
             * @member {number} bus_id
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.bus_id = 0;

            /**
             * File upload_time.
             * @member {number} upload_time
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.upload_time = 0;

            /**
             * File dead_time.
             * @member {number} dead_time
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.dead_time = 0;

            /**
             * File modify_time.
             * @member {number} modify_time
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.modify_time = 0;

            /**
             * File download_times.
             * @member {number} download_times
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.download_times = 0;

            /**
             * File uploader.
             * @member {number|Long} uploader
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.uploader = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * File uploader_name.
             * @member {string} uploader_name
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.uploader_name = "";

            /**
             * File sha.
             * @member {string} sha
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.sha = "";

            /**
             * File sha3.
             * @member {string} sha3
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.sha3 = "";

            /**
             * File md5.
             * @member {string} md5
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.md5 = "";

            /**
             * Creates a new File instance using the specified properties.
             * @function create
             * @memberof kritor.file.File
             * @static
             * @param {kritor.file.IFile=} [properties] Properties to set
             * @returns {kritor.file.File} File instance
             */
            File.create = function create(properties) {
                return new File(properties);
            };

            /**
             * Encodes the specified File message. Does not implicitly {@link kritor.file.File.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.File
             * @static
             * @param {kritor.file.IFile} message File message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            File.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file_id != null && Object.hasOwnProperty.call(message, "file_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.file_id);
                if (message.file_name != null && Object.hasOwnProperty.call(message, "file_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.file_name);
                if (message.file_size != null && Object.hasOwnProperty.call(message, "file_size"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.file_size);
                if (message.bus_id != null && Object.hasOwnProperty.call(message, "bus_id"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.bus_id);
                if (message.upload_time != null && Object.hasOwnProperty.call(message, "upload_time"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.upload_time);
                if (message.dead_time != null && Object.hasOwnProperty.call(message, "dead_time"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.dead_time);
                if (message.modify_time != null && Object.hasOwnProperty.call(message, "modify_time"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.modify_time);
                if (message.download_times != null && Object.hasOwnProperty.call(message, "download_times"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.download_times);
                if (message.uploader != null && Object.hasOwnProperty.call(message, "uploader"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.uploader);
                if (message.uploader_name != null && Object.hasOwnProperty.call(message, "uploader_name"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.uploader_name);
                if (message.sha != null && Object.hasOwnProperty.call(message, "sha"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.sha);
                if (message.sha3 != null && Object.hasOwnProperty.call(message, "sha3"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.sha3);
                if (message.md5 != null && Object.hasOwnProperty.call(message, "md5"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.md5);
                return writer;
            };

            /**
             * Encodes the specified File message, length delimited. Does not implicitly {@link kritor.file.File.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.File
             * @static
             * @param {kritor.file.IFile} message File message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            File.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a File message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.File
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.File} File
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            File.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.File();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file_id = reader.string();
                            break;
                        }
                    case 2: {
                            message.file_name = reader.string();
                            break;
                        }
                    case 3: {
                            message.file_size = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.bus_id = reader.int32();
                            break;
                        }
                    case 5: {
                            message.upload_time = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.dead_time = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.modify_time = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.download_times = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.uploader = reader.uint64();
                            break;
                        }
                    case 10: {
                            message.uploader_name = reader.string();
                            break;
                        }
                    case 11: {
                            message.sha = reader.string();
                            break;
                        }
                    case 12: {
                            message.sha3 = reader.string();
                            break;
                        }
                    case 13: {
                            message.md5 = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a File message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.File
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.File} File
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            File.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a File message.
             * @function verify
             * @memberof kritor.file.File
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            File.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file_id != null && message.hasOwnProperty("file_id"))
                    if (!$util.isString(message.file_id))
                        return "file_id: string expected";
                if (message.file_name != null && message.hasOwnProperty("file_name"))
                    if (!$util.isString(message.file_name))
                        return "file_name: string expected";
                if (message.file_size != null && message.hasOwnProperty("file_size"))
                    if (!$util.isInteger(message.file_size) && !(message.file_size && $util.isInteger(message.file_size.low) && $util.isInteger(message.file_size.high)))
                        return "file_size: integer|Long expected";
                if (message.bus_id != null && message.hasOwnProperty("bus_id"))
                    if (!$util.isInteger(message.bus_id))
                        return "bus_id: integer expected";
                if (message.upload_time != null && message.hasOwnProperty("upload_time"))
                    if (!$util.isInteger(message.upload_time))
                        return "upload_time: integer expected";
                if (message.dead_time != null && message.hasOwnProperty("dead_time"))
                    if (!$util.isInteger(message.dead_time))
                        return "dead_time: integer expected";
                if (message.modify_time != null && message.hasOwnProperty("modify_time"))
                    if (!$util.isInteger(message.modify_time))
                        return "modify_time: integer expected";
                if (message.download_times != null && message.hasOwnProperty("download_times"))
                    if (!$util.isInteger(message.download_times))
                        return "download_times: integer expected";
                if (message.uploader != null && message.hasOwnProperty("uploader"))
                    if (!$util.isInteger(message.uploader) && !(message.uploader && $util.isInteger(message.uploader.low) && $util.isInteger(message.uploader.high)))
                        return "uploader: integer|Long expected";
                if (message.uploader_name != null && message.hasOwnProperty("uploader_name"))
                    if (!$util.isString(message.uploader_name))
                        return "uploader_name: string expected";
                if (message.sha != null && message.hasOwnProperty("sha"))
                    if (!$util.isString(message.sha))
                        return "sha: string expected";
                if (message.sha3 != null && message.hasOwnProperty("sha3"))
                    if (!$util.isString(message.sha3))
                        return "sha3: string expected";
                if (message.md5 != null && message.hasOwnProperty("md5"))
                    if (!$util.isString(message.md5))
                        return "md5: string expected";
                return null;
            };

            /**
             * Creates a File message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.File
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.File} File
             */
            File.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.File)
                    return object;
                let message = new $root.kritor.file.File();
                if (object.file_id != null)
                    message.file_id = String(object.file_id);
                if (object.file_name != null)
                    message.file_name = String(object.file_name);
                if (object.file_size != null)
                    if ($util.Long)
                        (message.file_size = $util.Long.fromValue(object.file_size)).unsigned = true;
                    else if (typeof object.file_size === "string")
                        message.file_size = parseInt(object.file_size, 10);
                    else if (typeof object.file_size === "number")
                        message.file_size = object.file_size;
                    else if (typeof object.file_size === "object")
                        message.file_size = new $util.LongBits(object.file_size.low >>> 0, object.file_size.high >>> 0).toNumber(true);
                if (object.bus_id != null)
                    message.bus_id = object.bus_id | 0;
                if (object.upload_time != null)
                    message.upload_time = object.upload_time >>> 0;
                if (object.dead_time != null)
                    message.dead_time = object.dead_time >>> 0;
                if (object.modify_time != null)
                    message.modify_time = object.modify_time >>> 0;
                if (object.download_times != null)
                    message.download_times = object.download_times >>> 0;
                if (object.uploader != null)
                    if ($util.Long)
                        (message.uploader = $util.Long.fromValue(object.uploader)).unsigned = true;
                    else if (typeof object.uploader === "string")
                        message.uploader = parseInt(object.uploader, 10);
                    else if (typeof object.uploader === "number")
                        message.uploader = object.uploader;
                    else if (typeof object.uploader === "object")
                        message.uploader = new $util.LongBits(object.uploader.low >>> 0, object.uploader.high >>> 0).toNumber(true);
                if (object.uploader_name != null)
                    message.uploader_name = String(object.uploader_name);
                if (object.sha != null)
                    message.sha = String(object.sha);
                if (object.sha3 != null)
                    message.sha3 = String(object.sha3);
                if (object.md5 != null)
                    message.md5 = String(object.md5);
                return message;
            };

            /**
             * Creates a plain object from a File message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.File
             * @static
             * @param {kritor.file.File} message File
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            File.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.file_id = "";
                    object.file_name = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.file_size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.file_size = options.longs === String ? "0" : 0;
                    object.bus_id = 0;
                    object.upload_time = 0;
                    object.dead_time = 0;
                    object.modify_time = 0;
                    object.download_times = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uploader = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uploader = options.longs === String ? "0" : 0;
                    object.uploader_name = "";
                    object.sha = "";
                    object.sha3 = "";
                    object.md5 = "";
                }
                if (message.file_id != null && message.hasOwnProperty("file_id"))
                    object.file_id = message.file_id;
                if (message.file_name != null && message.hasOwnProperty("file_name"))
                    object.file_name = message.file_name;
                if (message.file_size != null && message.hasOwnProperty("file_size"))
                    if (typeof message.file_size === "number")
                        object.file_size = options.longs === String ? String(message.file_size) : message.file_size;
                    else
                        object.file_size = options.longs === String ? $util.Long.prototype.toString.call(message.file_size) : options.longs === Number ? new $util.LongBits(message.file_size.low >>> 0, message.file_size.high >>> 0).toNumber(true) : message.file_size;
                if (message.bus_id != null && message.hasOwnProperty("bus_id"))
                    object.bus_id = message.bus_id;
                if (message.upload_time != null && message.hasOwnProperty("upload_time"))
                    object.upload_time = message.upload_time;
                if (message.dead_time != null && message.hasOwnProperty("dead_time"))
                    object.dead_time = message.dead_time;
                if (message.modify_time != null && message.hasOwnProperty("modify_time"))
                    object.modify_time = message.modify_time;
                if (message.download_times != null && message.hasOwnProperty("download_times"))
                    object.download_times = message.download_times;
                if (message.uploader != null && message.hasOwnProperty("uploader"))
                    if (typeof message.uploader === "number")
                        object.uploader = options.longs === String ? String(message.uploader) : message.uploader;
                    else
                        object.uploader = options.longs === String ? $util.Long.prototype.toString.call(message.uploader) : options.longs === Number ? new $util.LongBits(message.uploader.low >>> 0, message.uploader.high >>> 0).toNumber(true) : message.uploader;
                if (message.uploader_name != null && message.hasOwnProperty("uploader_name"))
                    object.uploader_name = message.uploader_name;
                if (message.sha != null && message.hasOwnProperty("sha"))
                    object.sha = message.sha;
                if (message.sha3 != null && message.hasOwnProperty("sha3"))
                    object.sha3 = message.sha3;
                if (message.md5 != null && message.hasOwnProperty("md5"))
                    object.md5 = message.md5;
                return object;
            };

            /**
             * Converts this File to JSON.
             * @function toJSON
             * @memberof kritor.file.File
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            File.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for File
             * @function getTypeUrl
             * @memberof kritor.file.File
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            File.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.File";
            };

            return File;
        })();

        file.Folder = (function() {

            /**
             * Properties of a Folder.
             * @memberof kritor.file
             * @interface IFolder
             * @property {string|null} [folder_id] Folder folder_id
             * @property {string|null} [folder_name] Folder folder_name
             * @property {number|null} [total_file_count] Folder total_file_count
             * @property {number|null} [create_time] Folder create_time
             * @property {number|Long|null} [creator] Folder creator
             * @property {string|null} [creator_name] Folder creator_name
             */

            /**
             * Constructs a new Folder.
             * @memberof kritor.file
             * @classdesc Represents a Folder.
             * @implements IFolder
             * @constructor
             * @param {kritor.file.IFolder=} [properties] Properties to set
             */
            function Folder(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Folder folder_id.
             * @member {string} folder_id
             * @memberof kritor.file.Folder
             * @instance
             */
            Folder.prototype.folder_id = "";

            /**
             * Folder folder_name.
             * @member {string} folder_name
             * @memberof kritor.file.Folder
             * @instance
             */
            Folder.prototype.folder_name = "";

            /**
             * Folder total_file_count.
             * @member {number} total_file_count
             * @memberof kritor.file.Folder
             * @instance
             */
            Folder.prototype.total_file_count = 0;

            /**
             * Folder create_time.
             * @member {number} create_time
             * @memberof kritor.file.Folder
             * @instance
             */
            Folder.prototype.create_time = 0;

            /**
             * Folder creator.
             * @member {number|Long} creator
             * @memberof kritor.file.Folder
             * @instance
             */
            Folder.prototype.creator = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Folder creator_name.
             * @member {string} creator_name
             * @memberof kritor.file.Folder
             * @instance
             */
            Folder.prototype.creator_name = "";

            /**
             * Creates a new Folder instance using the specified properties.
             * @function create
             * @memberof kritor.file.Folder
             * @static
             * @param {kritor.file.IFolder=} [properties] Properties to set
             * @returns {kritor.file.Folder} Folder instance
             */
            Folder.create = function create(properties) {
                return new Folder(properties);
            };

            /**
             * Encodes the specified Folder message. Does not implicitly {@link kritor.file.Folder.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.Folder
             * @static
             * @param {kritor.file.IFolder} message Folder message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Folder.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.folder_id != null && Object.hasOwnProperty.call(message, "folder_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.folder_id);
                if (message.folder_name != null && Object.hasOwnProperty.call(message, "folder_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.folder_name);
                if (message.total_file_count != null && Object.hasOwnProperty.call(message, "total_file_count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.total_file_count);
                if (message.create_time != null && Object.hasOwnProperty.call(message, "create_time"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.create_time);
                if (message.creator != null && Object.hasOwnProperty.call(message, "creator"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.creator);
                if (message.creator_name != null && Object.hasOwnProperty.call(message, "creator_name"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.creator_name);
                return writer;
            };

            /**
             * Encodes the specified Folder message, length delimited. Does not implicitly {@link kritor.file.Folder.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.Folder
             * @static
             * @param {kritor.file.IFolder} message Folder message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Folder.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Folder message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.Folder
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.Folder} Folder
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Folder.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.Folder();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.folder_id = reader.string();
                            break;
                        }
                    case 2: {
                            message.folder_name = reader.string();
                            break;
                        }
                    case 3: {
                            message.total_file_count = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.create_time = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.creator = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.creator_name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Folder message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.Folder
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.Folder} Folder
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Folder.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Folder message.
             * @function verify
             * @memberof kritor.file.Folder
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Folder.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.folder_id != null && message.hasOwnProperty("folder_id"))
                    if (!$util.isString(message.folder_id))
                        return "folder_id: string expected";
                if (message.folder_name != null && message.hasOwnProperty("folder_name"))
                    if (!$util.isString(message.folder_name))
                        return "folder_name: string expected";
                if (message.total_file_count != null && message.hasOwnProperty("total_file_count"))
                    if (!$util.isInteger(message.total_file_count))
                        return "total_file_count: integer expected";
                if (message.create_time != null && message.hasOwnProperty("create_time"))
                    if (!$util.isInteger(message.create_time))
                        return "create_time: integer expected";
                if (message.creator != null && message.hasOwnProperty("creator"))
                    if (!$util.isInteger(message.creator) && !(message.creator && $util.isInteger(message.creator.low) && $util.isInteger(message.creator.high)))
                        return "creator: integer|Long expected";
                if (message.creator_name != null && message.hasOwnProperty("creator_name"))
                    if (!$util.isString(message.creator_name))
                        return "creator_name: string expected";
                return null;
            };

            /**
             * Creates a Folder message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.Folder
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.Folder} Folder
             */
            Folder.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.Folder)
                    return object;
                let message = new $root.kritor.file.Folder();
                if (object.folder_id != null)
                    message.folder_id = String(object.folder_id);
                if (object.folder_name != null)
                    message.folder_name = String(object.folder_name);
                if (object.total_file_count != null)
                    message.total_file_count = object.total_file_count >>> 0;
                if (object.create_time != null)
                    message.create_time = object.create_time >>> 0;
                if (object.creator != null)
                    if ($util.Long)
                        (message.creator = $util.Long.fromValue(object.creator)).unsigned = true;
                    else if (typeof object.creator === "string")
                        message.creator = parseInt(object.creator, 10);
                    else if (typeof object.creator === "number")
                        message.creator = object.creator;
                    else if (typeof object.creator === "object")
                        message.creator = new $util.LongBits(object.creator.low >>> 0, object.creator.high >>> 0).toNumber(true);
                if (object.creator_name != null)
                    message.creator_name = String(object.creator_name);
                return message;
            };

            /**
             * Creates a plain object from a Folder message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.Folder
             * @static
             * @param {kritor.file.Folder} message Folder
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Folder.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.folder_id = "";
                    object.folder_name = "";
                    object.total_file_count = 0;
                    object.create_time = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.creator = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.creator = options.longs === String ? "0" : 0;
                    object.creator_name = "";
                }
                if (message.folder_id != null && message.hasOwnProperty("folder_id"))
                    object.folder_id = message.folder_id;
                if (message.folder_name != null && message.hasOwnProperty("folder_name"))
                    object.folder_name = message.folder_name;
                if (message.total_file_count != null && message.hasOwnProperty("total_file_count"))
                    object.total_file_count = message.total_file_count;
                if (message.create_time != null && message.hasOwnProperty("create_time"))
                    object.create_time = message.create_time;
                if (message.creator != null && message.hasOwnProperty("creator"))
                    if (typeof message.creator === "number")
                        object.creator = options.longs === String ? String(message.creator) : message.creator;
                    else
                        object.creator = options.longs === String ? $util.Long.prototype.toString.call(message.creator) : options.longs === Number ? new $util.LongBits(message.creator.low >>> 0, message.creator.high >>> 0).toNumber(true) : message.creator;
                if (message.creator_name != null && message.hasOwnProperty("creator_name"))
                    object.creator_name = message.creator_name;
                return object;
            };

            /**
             * Converts this Folder to JSON.
             * @function toJSON
             * @memberof kritor.file.Folder
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Folder.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Folder
             * @function getTypeUrl
             * @memberof kritor.file.Folder
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Folder.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.Folder";
            };

            return Folder;
        })();

        file.GroupFileService = (function() {

            /**
             * Constructs a new GroupFileService service.
             * @memberof kritor.file
             * @classdesc Represents a GroupFileService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function GroupFileService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (GroupFileService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = GroupFileService;

            /**
             * Creates new GroupFileService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.file.GroupFileService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {GroupFileService} RPC service. Useful where requests and/or responses are streamed.
             */
            GroupFileService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.file.GroupFileService#createFolder}.
             * @memberof kritor.file.GroupFileService
             * @typedef CreateFolderCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.file.CreateFolderResponse} [response] CreateFolderResponse
             */

            /**
             * Calls CreateFolder.
             * @function createFolder
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.ICreateFolderRequest} request CreateFolderRequest message or plain object
             * @param {kritor.file.GroupFileService.CreateFolderCallback} callback Node-style callback called with the error, if any, and CreateFolderResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.createFolder = function createFolder(request, callback) {
                return this.rpcCall(createFolder, $root.kritor.file.CreateFolderRequest, $root.kritor.file.CreateFolderResponse, request, callback);
            }, "name", { value: "CreateFolder" });

            /**
             * Calls CreateFolder.
             * @function createFolder
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.ICreateFolderRequest} request CreateFolderRequest message or plain object
             * @returns {Promise<kritor.file.CreateFolderResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.file.GroupFileService#renameFolder}.
             * @memberof kritor.file.GroupFileService
             * @typedef RenameFolderCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.file.RenameFolderResponse} [response] RenameFolderResponse
             */

            /**
             * Calls RenameFolder.
             * @function renameFolder
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IRenameFolderRequest} request RenameFolderRequest message or plain object
             * @param {kritor.file.GroupFileService.RenameFolderCallback} callback Node-style callback called with the error, if any, and RenameFolderResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.renameFolder = function renameFolder(request, callback) {
                return this.rpcCall(renameFolder, $root.kritor.file.RenameFolderRequest, $root.kritor.file.RenameFolderResponse, request, callback);
            }, "name", { value: "RenameFolder" });

            /**
             * Calls RenameFolder.
             * @function renameFolder
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IRenameFolderRequest} request RenameFolderRequest message or plain object
             * @returns {Promise<kritor.file.RenameFolderResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.file.GroupFileService#deleteFolder}.
             * @memberof kritor.file.GroupFileService
             * @typedef DeleteFolderCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.file.DeleteFolderResponse} [response] DeleteFolderResponse
             */

            /**
             * Calls DeleteFolder.
             * @function deleteFolder
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IDeleteFolderRequest} request DeleteFolderRequest message or plain object
             * @param {kritor.file.GroupFileService.DeleteFolderCallback} callback Node-style callback called with the error, if any, and DeleteFolderResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.deleteFolder = function deleteFolder(request, callback) {
                return this.rpcCall(deleteFolder, $root.kritor.file.DeleteFolderRequest, $root.kritor.file.DeleteFolderResponse, request, callback);
            }, "name", { value: "DeleteFolder" });

            /**
             * Calls DeleteFolder.
             * @function deleteFolder
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IDeleteFolderRequest} request DeleteFolderRequest message or plain object
             * @returns {Promise<kritor.file.DeleteFolderResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.file.GroupFileService#uploadFile}.
             * @memberof kritor.file.GroupFileService
             * @typedef UploadFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.file.UploadFileResponse} [response] UploadFileResponse
             */

            /**
             * Calls UploadFile.
             * @function uploadFile
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IUploadFileRequest} request UploadFileRequest message or plain object
             * @param {kritor.file.GroupFileService.UploadFileCallback} callback Node-style callback called with the error, if any, and UploadFileResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.uploadFile = function uploadFile(request, callback) {
                return this.rpcCall(uploadFile, $root.kritor.file.UploadFileRequest, $root.kritor.file.UploadFileResponse, request, callback);
            }, "name", { value: "UploadFile" });

            /**
             * Calls UploadFile.
             * @function uploadFile
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IUploadFileRequest} request UploadFileRequest message or plain object
             * @returns {Promise<kritor.file.UploadFileResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.file.GroupFileService#deleteFile}.
             * @memberof kritor.file.GroupFileService
             * @typedef DeleteFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.file.DeleteFileResponse} [response] DeleteFileResponse
             */

            /**
             * Calls DeleteFile.
             * @function deleteFile
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IDeleteFileRequest} request DeleteFileRequest message or plain object
             * @param {kritor.file.GroupFileService.DeleteFileCallback} callback Node-style callback called with the error, if any, and DeleteFileResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.deleteFile = function deleteFile(request, callback) {
                return this.rpcCall(deleteFile, $root.kritor.file.DeleteFileRequest, $root.kritor.file.DeleteFileResponse, request, callback);
            }, "name", { value: "DeleteFile" });

            /**
             * Calls DeleteFile.
             * @function deleteFile
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IDeleteFileRequest} request DeleteFileRequest message or plain object
             * @returns {Promise<kritor.file.DeleteFileResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.file.GroupFileService#getFileSystemInfo}.
             * @memberof kritor.file.GroupFileService
             * @typedef GetFileSystemInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.file.GetFileSystemInfoResponse} [response] GetFileSystemInfoResponse
             */

            /**
             * Calls GetFileSystemInfo.
             * @function getFileSystemInfo
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IGetFileSystemInfoRequest} request GetFileSystemInfoRequest message or plain object
             * @param {kritor.file.GroupFileService.GetFileSystemInfoCallback} callback Node-style callback called with the error, if any, and GetFileSystemInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.getFileSystemInfo = function getFileSystemInfo(request, callback) {
                return this.rpcCall(getFileSystemInfo, $root.kritor.file.GetFileSystemInfoRequest, $root.kritor.file.GetFileSystemInfoResponse, request, callback);
            }, "name", { value: "GetFileSystemInfo" });

            /**
             * Calls GetFileSystemInfo.
             * @function getFileSystemInfo
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IGetFileSystemInfoRequest} request GetFileSystemInfoRequest message or plain object
             * @returns {Promise<kritor.file.GetFileSystemInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.file.GroupFileService#getFileList}.
             * @memberof kritor.file.GroupFileService
             * @typedef GetFileListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.file.GetFileListResponse} [response] GetFileListResponse
             */

            /**
             * Calls GetFileList.
             * @function getFileList
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IGetFileListRequest} request GetFileListRequest message or plain object
             * @param {kritor.file.GroupFileService.GetFileListCallback} callback Node-style callback called with the error, if any, and GetFileListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.getFileList = function getFileList(request, callback) {
                return this.rpcCall(getFileList, $root.kritor.file.GetFileListRequest, $root.kritor.file.GetFileListResponse, request, callback);
            }, "name", { value: "GetFileList" });

            /**
             * Calls GetFileList.
             * @function getFileList
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IGetFileListRequest} request GetFileListRequest message or plain object
             * @returns {Promise<kritor.file.GetFileListResponse>} Promise
             * @variation 2
             */

            return GroupFileService;
        })();

        file.CreateFolderRequest = (function() {

            /**
             * Properties of a CreateFolderRequest.
             * @memberof kritor.file
             * @interface ICreateFolderRequest
             * @property {number|Long|null} [group_id] CreateFolderRequest group_id
             * @property {string|null} [name] CreateFolderRequest name
             */

            /**
             * Constructs a new CreateFolderRequest.
             * @memberof kritor.file
             * @classdesc Represents a CreateFolderRequest.
             * @implements ICreateFolderRequest
             * @constructor
             * @param {kritor.file.ICreateFolderRequest=} [properties] Properties to set
             */
            function CreateFolderRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateFolderRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.file.CreateFolderRequest
             * @instance
             */
            CreateFolderRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * CreateFolderRequest name.
             * @member {string} name
             * @memberof kritor.file.CreateFolderRequest
             * @instance
             */
            CreateFolderRequest.prototype.name = "";

            /**
             * Creates a new CreateFolderRequest instance using the specified properties.
             * @function create
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {kritor.file.ICreateFolderRequest=} [properties] Properties to set
             * @returns {kritor.file.CreateFolderRequest} CreateFolderRequest instance
             */
            CreateFolderRequest.create = function create(properties) {
                return new CreateFolderRequest(properties);
            };

            /**
             * Encodes the specified CreateFolderRequest message. Does not implicitly {@link kritor.file.CreateFolderRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {kritor.file.ICreateFolderRequest} message CreateFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateFolderRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified CreateFolderRequest message, length delimited. Does not implicitly {@link kritor.file.CreateFolderRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {kritor.file.ICreateFolderRequest} message CreateFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateFolderRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateFolderRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.CreateFolderRequest} CreateFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateFolderRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.CreateFolderRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateFolderRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.CreateFolderRequest} CreateFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateFolderRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateFolderRequest message.
             * @function verify
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateFolderRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a CreateFolderRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.CreateFolderRequest} CreateFolderRequest
             */
            CreateFolderRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.CreateFolderRequest)
                    return object;
                let message = new $root.kritor.file.CreateFolderRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a CreateFolderRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {kritor.file.CreateFolderRequest} message CreateFolderRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateFolderRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.name = "";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this CreateFolderRequest to JSON.
             * @function toJSON
             * @memberof kritor.file.CreateFolderRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateFolderRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateFolderRequest
             * @function getTypeUrl
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateFolderRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.CreateFolderRequest";
            };

            return CreateFolderRequest;
        })();

        file.CreateFolderResponse = (function() {

            /**
             * Properties of a CreateFolderResponse.
             * @memberof kritor.file
             * @interface ICreateFolderResponse
             * @property {string|null} [id] CreateFolderResponse id
             * @property {number|Long|null} [used_space] CreateFolderResponse used_space
             */

            /**
             * Constructs a new CreateFolderResponse.
             * @memberof kritor.file
             * @classdesc Represents a CreateFolderResponse.
             * @implements ICreateFolderResponse
             * @constructor
             * @param {kritor.file.ICreateFolderResponse=} [properties] Properties to set
             */
            function CreateFolderResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateFolderResponse id.
             * @member {string} id
             * @memberof kritor.file.CreateFolderResponse
             * @instance
             */
            CreateFolderResponse.prototype.id = "";

            /**
             * CreateFolderResponse used_space.
             * @member {number|Long} used_space
             * @memberof kritor.file.CreateFolderResponse
             * @instance
             */
            CreateFolderResponse.prototype.used_space = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new CreateFolderResponse instance using the specified properties.
             * @function create
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {kritor.file.ICreateFolderResponse=} [properties] Properties to set
             * @returns {kritor.file.CreateFolderResponse} CreateFolderResponse instance
             */
            CreateFolderResponse.create = function create(properties) {
                return new CreateFolderResponse(properties);
            };

            /**
             * Encodes the specified CreateFolderResponse message. Does not implicitly {@link kritor.file.CreateFolderResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {kritor.file.ICreateFolderResponse} message CreateFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateFolderResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.used_space != null && Object.hasOwnProperty.call(message, "used_space"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.used_space);
                return writer;
            };

            /**
             * Encodes the specified CreateFolderResponse message, length delimited. Does not implicitly {@link kritor.file.CreateFolderResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {kritor.file.ICreateFolderResponse} message CreateFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateFolderResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateFolderResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.CreateFolderResponse} CreateFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateFolderResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.CreateFolderResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    case 2: {
                            message.used_space = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateFolderResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.CreateFolderResponse} CreateFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateFolderResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateFolderResponse message.
             * @function verify
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateFolderResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.used_space != null && message.hasOwnProperty("used_space"))
                    if (!$util.isInteger(message.used_space) && !(message.used_space && $util.isInteger(message.used_space.low) && $util.isInteger(message.used_space.high)))
                        return "used_space: integer|Long expected";
                return null;
            };

            /**
             * Creates a CreateFolderResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.CreateFolderResponse} CreateFolderResponse
             */
            CreateFolderResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.CreateFolderResponse)
                    return object;
                let message = new $root.kritor.file.CreateFolderResponse();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.used_space != null)
                    if ($util.Long)
                        (message.used_space = $util.Long.fromValue(object.used_space)).unsigned = true;
                    else if (typeof object.used_space === "string")
                        message.used_space = parseInt(object.used_space, 10);
                    else if (typeof object.used_space === "number")
                        message.used_space = object.used_space;
                    else if (typeof object.used_space === "object")
                        message.used_space = new $util.LongBits(object.used_space.low >>> 0, object.used_space.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a CreateFolderResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {kritor.file.CreateFolderResponse} message CreateFolderResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateFolderResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.used_space = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.used_space = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.used_space != null && message.hasOwnProperty("used_space"))
                    if (typeof message.used_space === "number")
                        object.used_space = options.longs === String ? String(message.used_space) : message.used_space;
                    else
                        object.used_space = options.longs === String ? $util.Long.prototype.toString.call(message.used_space) : options.longs === Number ? new $util.LongBits(message.used_space.low >>> 0, message.used_space.high >>> 0).toNumber(true) : message.used_space;
                return object;
            };

            /**
             * Converts this CreateFolderResponse to JSON.
             * @function toJSON
             * @memberof kritor.file.CreateFolderResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateFolderResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateFolderResponse
             * @function getTypeUrl
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateFolderResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.CreateFolderResponse";
            };

            return CreateFolderResponse;
        })();

        file.RenameFolderRequest = (function() {

            /**
             * Properties of a RenameFolderRequest.
             * @memberof kritor.file
             * @interface IRenameFolderRequest
             * @property {number|Long|null} [group_id] RenameFolderRequest group_id
             * @property {string|null} [folder_id] RenameFolderRequest folder_id
             * @property {string|null} [name] RenameFolderRequest name
             */

            /**
             * Constructs a new RenameFolderRequest.
             * @memberof kritor.file
             * @classdesc Represents a RenameFolderRequest.
             * @implements IRenameFolderRequest
             * @constructor
             * @param {kritor.file.IRenameFolderRequest=} [properties] Properties to set
             */
            function RenameFolderRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RenameFolderRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.file.RenameFolderRequest
             * @instance
             */
            RenameFolderRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RenameFolderRequest folder_id.
             * @member {string} folder_id
             * @memberof kritor.file.RenameFolderRequest
             * @instance
             */
            RenameFolderRequest.prototype.folder_id = "";

            /**
             * RenameFolderRequest name.
             * @member {string} name
             * @memberof kritor.file.RenameFolderRequest
             * @instance
             */
            RenameFolderRequest.prototype.name = "";

            /**
             * Creates a new RenameFolderRequest instance using the specified properties.
             * @function create
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {kritor.file.IRenameFolderRequest=} [properties] Properties to set
             * @returns {kritor.file.RenameFolderRequest} RenameFolderRequest instance
             */
            RenameFolderRequest.create = function create(properties) {
                return new RenameFolderRequest(properties);
            };

            /**
             * Encodes the specified RenameFolderRequest message. Does not implicitly {@link kritor.file.RenameFolderRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {kritor.file.IRenameFolderRequest} message RenameFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameFolderRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.folder_id != null && Object.hasOwnProperty.call(message, "folder_id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.folder_id);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified RenameFolderRequest message, length delimited. Does not implicitly {@link kritor.file.RenameFolderRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {kritor.file.IRenameFolderRequest} message RenameFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameFolderRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RenameFolderRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.RenameFolderRequest} RenameFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameFolderRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.RenameFolderRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.folder_id = reader.string();
                            break;
                        }
                    case 3: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RenameFolderRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.RenameFolderRequest} RenameFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameFolderRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RenameFolderRequest message.
             * @function verify
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RenameFolderRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.folder_id != null && message.hasOwnProperty("folder_id"))
                    if (!$util.isString(message.folder_id))
                        return "folder_id: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a RenameFolderRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.RenameFolderRequest} RenameFolderRequest
             */
            RenameFolderRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.RenameFolderRequest)
                    return object;
                let message = new $root.kritor.file.RenameFolderRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.folder_id != null)
                    message.folder_id = String(object.folder_id);
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a RenameFolderRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {kritor.file.RenameFolderRequest} message RenameFolderRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RenameFolderRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.folder_id = "";
                    object.name = "";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.folder_id != null && message.hasOwnProperty("folder_id"))
                    object.folder_id = message.folder_id;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this RenameFolderRequest to JSON.
             * @function toJSON
             * @memberof kritor.file.RenameFolderRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RenameFolderRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RenameFolderRequest
             * @function getTypeUrl
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RenameFolderRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.RenameFolderRequest";
            };

            return RenameFolderRequest;
        })();

        file.RenameFolderResponse = (function() {

            /**
             * Properties of a RenameFolderResponse.
             * @memberof kritor.file
             * @interface IRenameFolderResponse
             */

            /**
             * Constructs a new RenameFolderResponse.
             * @memberof kritor.file
             * @classdesc Represents a RenameFolderResponse.
             * @implements IRenameFolderResponse
             * @constructor
             * @param {kritor.file.IRenameFolderResponse=} [properties] Properties to set
             */
            function RenameFolderResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new RenameFolderResponse instance using the specified properties.
             * @function create
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {kritor.file.IRenameFolderResponse=} [properties] Properties to set
             * @returns {kritor.file.RenameFolderResponse} RenameFolderResponse instance
             */
            RenameFolderResponse.create = function create(properties) {
                return new RenameFolderResponse(properties);
            };

            /**
             * Encodes the specified RenameFolderResponse message. Does not implicitly {@link kritor.file.RenameFolderResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {kritor.file.IRenameFolderResponse} message RenameFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameFolderResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified RenameFolderResponse message, length delimited. Does not implicitly {@link kritor.file.RenameFolderResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {kritor.file.IRenameFolderResponse} message RenameFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameFolderResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RenameFolderResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.RenameFolderResponse} RenameFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameFolderResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.RenameFolderResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RenameFolderResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.RenameFolderResponse} RenameFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameFolderResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RenameFolderResponse message.
             * @function verify
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RenameFolderResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a RenameFolderResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.RenameFolderResponse} RenameFolderResponse
             */
            RenameFolderResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.RenameFolderResponse)
                    return object;
                return new $root.kritor.file.RenameFolderResponse();
            };

            /**
             * Creates a plain object from a RenameFolderResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {kritor.file.RenameFolderResponse} message RenameFolderResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RenameFolderResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this RenameFolderResponse to JSON.
             * @function toJSON
             * @memberof kritor.file.RenameFolderResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RenameFolderResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RenameFolderResponse
             * @function getTypeUrl
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RenameFolderResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.RenameFolderResponse";
            };

            return RenameFolderResponse;
        })();

        file.DeleteFolderRequest = (function() {

            /**
             * Properties of a DeleteFolderRequest.
             * @memberof kritor.file
             * @interface IDeleteFolderRequest
             * @property {number|Long|null} [group_id] DeleteFolderRequest group_id
             * @property {string|null} [folder_id] DeleteFolderRequest folder_id
             */

            /**
             * Constructs a new DeleteFolderRequest.
             * @memberof kritor.file
             * @classdesc Represents a DeleteFolderRequest.
             * @implements IDeleteFolderRequest
             * @constructor
             * @param {kritor.file.IDeleteFolderRequest=} [properties] Properties to set
             */
            function DeleteFolderRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteFolderRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.file.DeleteFolderRequest
             * @instance
             */
            DeleteFolderRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * DeleteFolderRequest folder_id.
             * @member {string} folder_id
             * @memberof kritor.file.DeleteFolderRequest
             * @instance
             */
            DeleteFolderRequest.prototype.folder_id = "";

            /**
             * Creates a new DeleteFolderRequest instance using the specified properties.
             * @function create
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {kritor.file.IDeleteFolderRequest=} [properties] Properties to set
             * @returns {kritor.file.DeleteFolderRequest} DeleteFolderRequest instance
             */
            DeleteFolderRequest.create = function create(properties) {
                return new DeleteFolderRequest(properties);
            };

            /**
             * Encodes the specified DeleteFolderRequest message. Does not implicitly {@link kritor.file.DeleteFolderRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {kritor.file.IDeleteFolderRequest} message DeleteFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFolderRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.folder_id != null && Object.hasOwnProperty.call(message, "folder_id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.folder_id);
                return writer;
            };

            /**
             * Encodes the specified DeleteFolderRequest message, length delimited. Does not implicitly {@link kritor.file.DeleteFolderRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {kritor.file.IDeleteFolderRequest} message DeleteFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFolderRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFolderRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.DeleteFolderRequest} DeleteFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFolderRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.DeleteFolderRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.folder_id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteFolderRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.DeleteFolderRequest} DeleteFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFolderRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFolderRequest message.
             * @function verify
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFolderRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.folder_id != null && message.hasOwnProperty("folder_id"))
                    if (!$util.isString(message.folder_id))
                        return "folder_id: string expected";
                return null;
            };

            /**
             * Creates a DeleteFolderRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.DeleteFolderRequest} DeleteFolderRequest
             */
            DeleteFolderRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.DeleteFolderRequest)
                    return object;
                let message = new $root.kritor.file.DeleteFolderRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.folder_id != null)
                    message.folder_id = String(object.folder_id);
                return message;
            };

            /**
             * Creates a plain object from a DeleteFolderRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {kritor.file.DeleteFolderRequest} message DeleteFolderRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteFolderRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.folder_id = "";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.folder_id != null && message.hasOwnProperty("folder_id"))
                    object.folder_id = message.folder_id;
                return object;
            };

            /**
             * Converts this DeleteFolderRequest to JSON.
             * @function toJSON
             * @memberof kritor.file.DeleteFolderRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteFolderRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteFolderRequest
             * @function getTypeUrl
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteFolderRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.DeleteFolderRequest";
            };

            return DeleteFolderRequest;
        })();

        file.DeleteFolderResponse = (function() {

            /**
             * Properties of a DeleteFolderResponse.
             * @memberof kritor.file
             * @interface IDeleteFolderResponse
             */

            /**
             * Constructs a new DeleteFolderResponse.
             * @memberof kritor.file
             * @classdesc Represents a DeleteFolderResponse.
             * @implements IDeleteFolderResponse
             * @constructor
             * @param {kritor.file.IDeleteFolderResponse=} [properties] Properties to set
             */
            function DeleteFolderResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteFolderResponse instance using the specified properties.
             * @function create
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {kritor.file.IDeleteFolderResponse=} [properties] Properties to set
             * @returns {kritor.file.DeleteFolderResponse} DeleteFolderResponse instance
             */
            DeleteFolderResponse.create = function create(properties) {
                return new DeleteFolderResponse(properties);
            };

            /**
             * Encodes the specified DeleteFolderResponse message. Does not implicitly {@link kritor.file.DeleteFolderResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {kritor.file.IDeleteFolderResponse} message DeleteFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFolderResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteFolderResponse message, length delimited. Does not implicitly {@link kritor.file.DeleteFolderResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {kritor.file.IDeleteFolderResponse} message DeleteFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFolderResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFolderResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.DeleteFolderResponse} DeleteFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFolderResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.DeleteFolderResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteFolderResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.DeleteFolderResponse} DeleteFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFolderResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFolderResponse message.
             * @function verify
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFolderResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteFolderResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.DeleteFolderResponse} DeleteFolderResponse
             */
            DeleteFolderResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.DeleteFolderResponse)
                    return object;
                return new $root.kritor.file.DeleteFolderResponse();
            };

            /**
             * Creates a plain object from a DeleteFolderResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {kritor.file.DeleteFolderResponse} message DeleteFolderResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteFolderResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteFolderResponse to JSON.
             * @function toJSON
             * @memberof kritor.file.DeleteFolderResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteFolderResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteFolderResponse
             * @function getTypeUrl
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteFolderResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.DeleteFolderResponse";
            };

            return DeleteFolderResponse;
        })();

        file.UploadFileRequest = (function() {

            /**
             * Properties of an UploadFileRequest.
             * @memberof kritor.file
             * @interface IUploadFileRequest
             * @property {number|Long|null} [group_id] UploadFileRequest group_id
             * @property {Uint8Array|null} [file] UploadFileRequest file
             * @property {string|null} [file_name] UploadFileRequest file_name
             * @property {string|null} [file_path] UploadFileRequest file_path
             * @property {string|null} [file_url] UploadFileRequest file_url
             */

            /**
             * Constructs a new UploadFileRequest.
             * @memberof kritor.file
             * @classdesc Represents an UploadFileRequest.
             * @implements IUploadFileRequest
             * @constructor
             * @param {kritor.file.IUploadFileRequest=} [properties] Properties to set
             */
            function UploadFileRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UploadFileRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.file.UploadFileRequest
             * @instance
             */
            UploadFileRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UploadFileRequest file.
             * @member {Uint8Array|null|undefined} file
             * @memberof kritor.file.UploadFileRequest
             * @instance
             */
            UploadFileRequest.prototype.file = null;

            /**
             * UploadFileRequest file_name.
             * @member {string|null|undefined} file_name
             * @memberof kritor.file.UploadFileRequest
             * @instance
             */
            UploadFileRequest.prototype.file_name = null;

            /**
             * UploadFileRequest file_path.
             * @member {string|null|undefined} file_path
             * @memberof kritor.file.UploadFileRequest
             * @instance
             */
            UploadFileRequest.prototype.file_path = null;

            /**
             * UploadFileRequest file_url.
             * @member {string|null|undefined} file_url
             * @memberof kritor.file.UploadFileRequest
             * @instance
             */
            UploadFileRequest.prototype.file_url = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * UploadFileRequest data.
             * @member {"file"|"file_name"|"file_path"|"file_url"|undefined} data
             * @memberof kritor.file.UploadFileRequest
             * @instance
             */
            Object.defineProperty(UploadFileRequest.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["file", "file_name", "file_path", "file_url"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new UploadFileRequest instance using the specified properties.
             * @function create
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {kritor.file.IUploadFileRequest=} [properties] Properties to set
             * @returns {kritor.file.UploadFileRequest} UploadFileRequest instance
             */
            UploadFileRequest.create = function create(properties) {
                return new UploadFileRequest(properties);
            };

            /**
             * Encodes the specified UploadFileRequest message. Does not implicitly {@link kritor.file.UploadFileRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {kritor.file.IUploadFileRequest} message UploadFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadFileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.file);
                if (message.file_name != null && Object.hasOwnProperty.call(message, "file_name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.file_name);
                if (message.file_path != null && Object.hasOwnProperty.call(message, "file_path"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.file_path);
                if (message.file_url != null && Object.hasOwnProperty.call(message, "file_url"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.file_url);
                return writer;
            };

            /**
             * Encodes the specified UploadFileRequest message, length delimited. Does not implicitly {@link kritor.file.UploadFileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {kritor.file.IUploadFileRequest} message UploadFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UploadFileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.UploadFileRequest} UploadFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadFileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.UploadFileRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.file = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.file_name = reader.string();
                            break;
                        }
                    case 4: {
                            message.file_path = reader.string();
                            break;
                        }
                    case 5: {
                            message.file_url = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UploadFileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.UploadFileRequest} UploadFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadFileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UploadFileRequest message.
             * @function verify
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UploadFileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    properties.data = 1;
                    if (!(message.file && typeof message.file.length === "number" || $util.isString(message.file)))
                        return "file: buffer expected";
                }
                if (message.file_name != null && message.hasOwnProperty("file_name")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.file_name))
                        return "file_name: string expected";
                }
                if (message.file_path != null && message.hasOwnProperty("file_path")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.file_path))
                        return "file_path: string expected";
                }
                if (message.file_url != null && message.hasOwnProperty("file_url")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.file_url))
                        return "file_url: string expected";
                }
                return null;
            };

            /**
             * Creates an UploadFileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.UploadFileRequest} UploadFileRequest
             */
            UploadFileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.UploadFileRequest)
                    return object;
                let message = new $root.kritor.file.UploadFileRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.file != null)
                    if (typeof object.file === "string")
                        $util.base64.decode(object.file, message.file = $util.newBuffer($util.base64.length(object.file)), 0);
                    else if (object.file.length >= 0)
                        message.file = object.file;
                if (object.file_name != null)
                    message.file_name = String(object.file_name);
                if (object.file_path != null)
                    message.file_path = String(object.file_path);
                if (object.file_url != null)
                    message.file_url = String(object.file_url);
                return message;
            };

            /**
             * Creates a plain object from an UploadFileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {kritor.file.UploadFileRequest} message UploadFileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UploadFileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = options.bytes === String ? $util.base64.encode(message.file, 0, message.file.length) : options.bytes === Array ? Array.prototype.slice.call(message.file) : message.file;
                    if (options.oneofs)
                        object.data = "file";
                }
                if (message.file_name != null && message.hasOwnProperty("file_name")) {
                    object.file_name = message.file_name;
                    if (options.oneofs)
                        object.data = "file_name";
                }
                if (message.file_path != null && message.hasOwnProperty("file_path")) {
                    object.file_path = message.file_path;
                    if (options.oneofs)
                        object.data = "file_path";
                }
                if (message.file_url != null && message.hasOwnProperty("file_url")) {
                    object.file_url = message.file_url;
                    if (options.oneofs)
                        object.data = "file_url";
                }
                return object;
            };

            /**
             * Converts this UploadFileRequest to JSON.
             * @function toJSON
             * @memberof kritor.file.UploadFileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UploadFileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UploadFileRequest
             * @function getTypeUrl
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UploadFileRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.UploadFileRequest";
            };

            return UploadFileRequest;
        })();

        file.UploadFileResponse = (function() {

            /**
             * Properties of an UploadFileResponse.
             * @memberof kritor.file
             * @interface IUploadFileResponse
             */

            /**
             * Constructs a new UploadFileResponse.
             * @memberof kritor.file
             * @classdesc Represents an UploadFileResponse.
             * @implements IUploadFileResponse
             * @constructor
             * @param {kritor.file.IUploadFileResponse=} [properties] Properties to set
             */
            function UploadFileResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new UploadFileResponse instance using the specified properties.
             * @function create
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {kritor.file.IUploadFileResponse=} [properties] Properties to set
             * @returns {kritor.file.UploadFileResponse} UploadFileResponse instance
             */
            UploadFileResponse.create = function create(properties) {
                return new UploadFileResponse(properties);
            };

            /**
             * Encodes the specified UploadFileResponse message. Does not implicitly {@link kritor.file.UploadFileResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {kritor.file.IUploadFileResponse} message UploadFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadFileResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified UploadFileResponse message, length delimited. Does not implicitly {@link kritor.file.UploadFileResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {kritor.file.IUploadFileResponse} message UploadFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadFileResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UploadFileResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.UploadFileResponse} UploadFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadFileResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.UploadFileResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UploadFileResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.UploadFileResponse} UploadFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadFileResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UploadFileResponse message.
             * @function verify
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UploadFileResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an UploadFileResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.UploadFileResponse} UploadFileResponse
             */
            UploadFileResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.UploadFileResponse)
                    return object;
                return new $root.kritor.file.UploadFileResponse();
            };

            /**
             * Creates a plain object from an UploadFileResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {kritor.file.UploadFileResponse} message UploadFileResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UploadFileResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this UploadFileResponse to JSON.
             * @function toJSON
             * @memberof kritor.file.UploadFileResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UploadFileResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UploadFileResponse
             * @function getTypeUrl
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UploadFileResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.UploadFileResponse";
            };

            return UploadFileResponse;
        })();

        file.DeleteFileRequest = (function() {

            /**
             * Properties of a DeleteFileRequest.
             * @memberof kritor.file
             * @interface IDeleteFileRequest
             * @property {number|Long|null} [group_id] DeleteFileRequest group_id
             * @property {string|null} [file_id] DeleteFileRequest file_id
             * @property {number|null} [bus_id] DeleteFileRequest bus_id
             */

            /**
             * Constructs a new DeleteFileRequest.
             * @memberof kritor.file
             * @classdesc Represents a DeleteFileRequest.
             * @implements IDeleteFileRequest
             * @constructor
             * @param {kritor.file.IDeleteFileRequest=} [properties] Properties to set
             */
            function DeleteFileRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteFileRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.file.DeleteFileRequest
             * @instance
             */
            DeleteFileRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * DeleteFileRequest file_id.
             * @member {string} file_id
             * @memberof kritor.file.DeleteFileRequest
             * @instance
             */
            DeleteFileRequest.prototype.file_id = "";

            /**
             * DeleteFileRequest bus_id.
             * @member {number} bus_id
             * @memberof kritor.file.DeleteFileRequest
             * @instance
             */
            DeleteFileRequest.prototype.bus_id = 0;

            /**
             * Creates a new DeleteFileRequest instance using the specified properties.
             * @function create
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {kritor.file.IDeleteFileRequest=} [properties] Properties to set
             * @returns {kritor.file.DeleteFileRequest} DeleteFileRequest instance
             */
            DeleteFileRequest.create = function create(properties) {
                return new DeleteFileRequest(properties);
            };

            /**
             * Encodes the specified DeleteFileRequest message. Does not implicitly {@link kritor.file.DeleteFileRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {kritor.file.IDeleteFileRequest} message DeleteFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.file_id != null && Object.hasOwnProperty.call(message, "file_id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.file_id);
                if (message.bus_id != null && Object.hasOwnProperty.call(message, "bus_id"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.bus_id);
                return writer;
            };

            /**
             * Encodes the specified DeleteFileRequest message, length delimited. Does not implicitly {@link kritor.file.DeleteFileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {kritor.file.IDeleteFileRequest} message DeleteFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.DeleteFileRequest} DeleteFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.DeleteFileRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.file_id = reader.string();
                            break;
                        }
                    case 3: {
                            message.bus_id = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteFileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.DeleteFileRequest} DeleteFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFileRequest message.
             * @function verify
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.file_id != null && message.hasOwnProperty("file_id"))
                    if (!$util.isString(message.file_id))
                        return "file_id: string expected";
                if (message.bus_id != null && message.hasOwnProperty("bus_id"))
                    if (!$util.isInteger(message.bus_id))
                        return "bus_id: integer expected";
                return null;
            };

            /**
             * Creates a DeleteFileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.DeleteFileRequest} DeleteFileRequest
             */
            DeleteFileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.DeleteFileRequest)
                    return object;
                let message = new $root.kritor.file.DeleteFileRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.file_id != null)
                    message.file_id = String(object.file_id);
                if (object.bus_id != null)
                    message.bus_id = object.bus_id | 0;
                return message;
            };

            /**
             * Creates a plain object from a DeleteFileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {kritor.file.DeleteFileRequest} message DeleteFileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteFileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.file_id = "";
                    object.bus_id = 0;
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.file_id != null && message.hasOwnProperty("file_id"))
                    object.file_id = message.file_id;
                if (message.bus_id != null && message.hasOwnProperty("bus_id"))
                    object.bus_id = message.bus_id;
                return object;
            };

            /**
             * Converts this DeleteFileRequest to JSON.
             * @function toJSON
             * @memberof kritor.file.DeleteFileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteFileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteFileRequest
             * @function getTypeUrl
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteFileRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.DeleteFileRequest";
            };

            return DeleteFileRequest;
        })();

        file.DeleteFileResponse = (function() {

            /**
             * Properties of a DeleteFileResponse.
             * @memberof kritor.file
             * @interface IDeleteFileResponse
             */

            /**
             * Constructs a new DeleteFileResponse.
             * @memberof kritor.file
             * @classdesc Represents a DeleteFileResponse.
             * @implements IDeleteFileResponse
             * @constructor
             * @param {kritor.file.IDeleteFileResponse=} [properties] Properties to set
             */
            function DeleteFileResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteFileResponse instance using the specified properties.
             * @function create
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {kritor.file.IDeleteFileResponse=} [properties] Properties to set
             * @returns {kritor.file.DeleteFileResponse} DeleteFileResponse instance
             */
            DeleteFileResponse.create = function create(properties) {
                return new DeleteFileResponse(properties);
            };

            /**
             * Encodes the specified DeleteFileResponse message. Does not implicitly {@link kritor.file.DeleteFileResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {kritor.file.IDeleteFileResponse} message DeleteFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteFileResponse message, length delimited. Does not implicitly {@link kritor.file.DeleteFileResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {kritor.file.IDeleteFileResponse} message DeleteFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFileResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.DeleteFileResponse} DeleteFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.DeleteFileResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteFileResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.DeleteFileResponse} DeleteFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFileResponse message.
             * @function verify
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFileResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteFileResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.DeleteFileResponse} DeleteFileResponse
             */
            DeleteFileResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.DeleteFileResponse)
                    return object;
                return new $root.kritor.file.DeleteFileResponse();
            };

            /**
             * Creates a plain object from a DeleteFileResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {kritor.file.DeleteFileResponse} message DeleteFileResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteFileResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteFileResponse to JSON.
             * @function toJSON
             * @memberof kritor.file.DeleteFileResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteFileResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteFileResponse
             * @function getTypeUrl
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteFileResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.DeleteFileResponse";
            };

            return DeleteFileResponse;
        })();

        file.GetFileSystemInfoRequest = (function() {

            /**
             * Properties of a GetFileSystemInfoRequest.
             * @memberof kritor.file
             * @interface IGetFileSystemInfoRequest
             * @property {number|Long|null} [group_id] GetFileSystemInfoRequest group_id
             */

            /**
             * Constructs a new GetFileSystemInfoRequest.
             * @memberof kritor.file
             * @classdesc Represents a GetFileSystemInfoRequest.
             * @implements IGetFileSystemInfoRequest
             * @constructor
             * @param {kritor.file.IGetFileSystemInfoRequest=} [properties] Properties to set
             */
            function GetFileSystemInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFileSystemInfoRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @instance
             */
            GetFileSystemInfoRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetFileSystemInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {kritor.file.IGetFileSystemInfoRequest=} [properties] Properties to set
             * @returns {kritor.file.GetFileSystemInfoRequest} GetFileSystemInfoRequest instance
             */
            GetFileSystemInfoRequest.create = function create(properties) {
                return new GetFileSystemInfoRequest(properties);
            };

            /**
             * Encodes the specified GetFileSystemInfoRequest message. Does not implicitly {@link kritor.file.GetFileSystemInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {kritor.file.IGetFileSystemInfoRequest} message GetFileSystemInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileSystemInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                return writer;
            };

            /**
             * Encodes the specified GetFileSystemInfoRequest message, length delimited. Does not implicitly {@link kritor.file.GetFileSystemInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {kritor.file.IGetFileSystemInfoRequest} message GetFileSystemInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileSystemInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFileSystemInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.GetFileSystemInfoRequest} GetFileSystemInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileSystemInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.GetFileSystemInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFileSystemInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.GetFileSystemInfoRequest} GetFileSystemInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileSystemInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFileSystemInfoRequest message.
             * @function verify
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFileSystemInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetFileSystemInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.GetFileSystemInfoRequest} GetFileSystemInfoRequest
             */
            GetFileSystemInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.GetFileSystemInfoRequest)
                    return object;
                let message = new $root.kritor.file.GetFileSystemInfoRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetFileSystemInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {kritor.file.GetFileSystemInfoRequest} message GetFileSystemInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFileSystemInfoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                return object;
            };

            /**
             * Converts this GetFileSystemInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFileSystemInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFileSystemInfoRequest
             * @function getTypeUrl
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFileSystemInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.GetFileSystemInfoRequest";
            };

            return GetFileSystemInfoRequest;
        })();

        file.GetFileSystemInfoResponse = (function() {

            /**
             * Properties of a GetFileSystemInfoResponse.
             * @memberof kritor.file
             * @interface IGetFileSystemInfoResponse
             * @property {number|null} [file_count] GetFileSystemInfoResponse file_count
             * @property {number|null} [total_count] GetFileSystemInfoResponse total_count
             * @property {number|null} [used_space] GetFileSystemInfoResponse used_space
             * @property {number|null} [total_space] GetFileSystemInfoResponse total_space
             */

            /**
             * Constructs a new GetFileSystemInfoResponse.
             * @memberof kritor.file
             * @classdesc Represents a GetFileSystemInfoResponse.
             * @implements IGetFileSystemInfoResponse
             * @constructor
             * @param {kritor.file.IGetFileSystemInfoResponse=} [properties] Properties to set
             */
            function GetFileSystemInfoResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFileSystemInfoResponse file_count.
             * @member {number} file_count
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @instance
             */
            GetFileSystemInfoResponse.prototype.file_count = 0;

            /**
             * GetFileSystemInfoResponse total_count.
             * @member {number} total_count
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @instance
             */
            GetFileSystemInfoResponse.prototype.total_count = 0;

            /**
             * GetFileSystemInfoResponse used_space.
             * @member {number} used_space
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @instance
             */
            GetFileSystemInfoResponse.prototype.used_space = 0;

            /**
             * GetFileSystemInfoResponse total_space.
             * @member {number} total_space
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @instance
             */
            GetFileSystemInfoResponse.prototype.total_space = 0;

            /**
             * Creates a new GetFileSystemInfoResponse instance using the specified properties.
             * @function create
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {kritor.file.IGetFileSystemInfoResponse=} [properties] Properties to set
             * @returns {kritor.file.GetFileSystemInfoResponse} GetFileSystemInfoResponse instance
             */
            GetFileSystemInfoResponse.create = function create(properties) {
                return new GetFileSystemInfoResponse(properties);
            };

            /**
             * Encodes the specified GetFileSystemInfoResponse message. Does not implicitly {@link kritor.file.GetFileSystemInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {kritor.file.IGetFileSystemInfoResponse} message GetFileSystemInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileSystemInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file_count != null && Object.hasOwnProperty.call(message, "file_count"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.file_count);
                if (message.total_count != null && Object.hasOwnProperty.call(message, "total_count"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.total_count);
                if (message.used_space != null && Object.hasOwnProperty.call(message, "used_space"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.used_space);
                if (message.total_space != null && Object.hasOwnProperty.call(message, "total_space"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.total_space);
                return writer;
            };

            /**
             * Encodes the specified GetFileSystemInfoResponse message, length delimited. Does not implicitly {@link kritor.file.GetFileSystemInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {kritor.file.IGetFileSystemInfoResponse} message GetFileSystemInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileSystemInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFileSystemInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.GetFileSystemInfoResponse} GetFileSystemInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileSystemInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.GetFileSystemInfoResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file_count = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.total_count = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.used_space = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.total_space = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFileSystemInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.GetFileSystemInfoResponse} GetFileSystemInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileSystemInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFileSystemInfoResponse message.
             * @function verify
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFileSystemInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file_count != null && message.hasOwnProperty("file_count"))
                    if (!$util.isInteger(message.file_count))
                        return "file_count: integer expected";
                if (message.total_count != null && message.hasOwnProperty("total_count"))
                    if (!$util.isInteger(message.total_count))
                        return "total_count: integer expected";
                if (message.used_space != null && message.hasOwnProperty("used_space"))
                    if (!$util.isInteger(message.used_space))
                        return "used_space: integer expected";
                if (message.total_space != null && message.hasOwnProperty("total_space"))
                    if (!$util.isInteger(message.total_space))
                        return "total_space: integer expected";
                return null;
            };

            /**
             * Creates a GetFileSystemInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.GetFileSystemInfoResponse} GetFileSystemInfoResponse
             */
            GetFileSystemInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.GetFileSystemInfoResponse)
                    return object;
                let message = new $root.kritor.file.GetFileSystemInfoResponse();
                if (object.file_count != null)
                    message.file_count = object.file_count >>> 0;
                if (object.total_count != null)
                    message.total_count = object.total_count >>> 0;
                if (object.used_space != null)
                    message.used_space = object.used_space >>> 0;
                if (object.total_space != null)
                    message.total_space = object.total_space >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetFileSystemInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {kritor.file.GetFileSystemInfoResponse} message GetFileSystemInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFileSystemInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.file_count = 0;
                    object.total_count = 0;
                    object.used_space = 0;
                    object.total_space = 0;
                }
                if (message.file_count != null && message.hasOwnProperty("file_count"))
                    object.file_count = message.file_count;
                if (message.total_count != null && message.hasOwnProperty("total_count"))
                    object.total_count = message.total_count;
                if (message.used_space != null && message.hasOwnProperty("used_space"))
                    object.used_space = message.used_space;
                if (message.total_space != null && message.hasOwnProperty("total_space"))
                    object.total_space = message.total_space;
                return object;
            };

            /**
             * Converts this GetFileSystemInfoResponse to JSON.
             * @function toJSON
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFileSystemInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFileSystemInfoResponse
             * @function getTypeUrl
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFileSystemInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.GetFileSystemInfoResponse";
            };

            return GetFileSystemInfoResponse;
        })();

        file.GetFileListRequest = (function() {

            /**
             * Properties of a GetFileListRequest.
             * @memberof kritor.file
             * @interface IGetFileListRequest
             * @property {number|Long|null} [group_id] GetFileListRequest group_id
             * @property {string|null} [folder_id] GetFileListRequest folder_id
             */

            /**
             * Constructs a new GetFileListRequest.
             * @memberof kritor.file
             * @classdesc Represents a GetFileListRequest.
             * @implements IGetFileListRequest
             * @constructor
             * @param {kritor.file.IGetFileListRequest=} [properties] Properties to set
             */
            function GetFileListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFileListRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.file.GetFileListRequest
             * @instance
             */
            GetFileListRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetFileListRequest folder_id.
             * @member {string|null|undefined} folder_id
             * @memberof kritor.file.GetFileListRequest
             * @instance
             */
            GetFileListRequest.prototype.folder_id = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetFileListRequest _folder_id.
             * @member {"folder_id"|undefined} _folder_id
             * @memberof kritor.file.GetFileListRequest
             * @instance
             */
            Object.defineProperty(GetFileListRequest.prototype, "_folder_id", {
                get: $util.oneOfGetter($oneOfFields = ["folder_id"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetFileListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {kritor.file.IGetFileListRequest=} [properties] Properties to set
             * @returns {kritor.file.GetFileListRequest} GetFileListRequest instance
             */
            GetFileListRequest.create = function create(properties) {
                return new GetFileListRequest(properties);
            };

            /**
             * Encodes the specified GetFileListRequest message. Does not implicitly {@link kritor.file.GetFileListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {kritor.file.IGetFileListRequest} message GetFileListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.folder_id != null && Object.hasOwnProperty.call(message, "folder_id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.folder_id);
                return writer;
            };

            /**
             * Encodes the specified GetFileListRequest message, length delimited. Does not implicitly {@link kritor.file.GetFileListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {kritor.file.IGetFileListRequest} message GetFileListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFileListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.GetFileListRequest} GetFileListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.GetFileListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.folder_id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFileListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.GetFileListRequest} GetFileListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFileListRequest message.
             * @function verify
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFileListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.folder_id != null && message.hasOwnProperty("folder_id")) {
                    properties._folder_id = 1;
                    if (!$util.isString(message.folder_id))
                        return "folder_id: string expected";
                }
                return null;
            };

            /**
             * Creates a GetFileListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.GetFileListRequest} GetFileListRequest
             */
            GetFileListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.GetFileListRequest)
                    return object;
                let message = new $root.kritor.file.GetFileListRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.folder_id != null)
                    message.folder_id = String(object.folder_id);
                return message;
            };

            /**
             * Creates a plain object from a GetFileListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {kritor.file.GetFileListRequest} message GetFileListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFileListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.folder_id != null && message.hasOwnProperty("folder_id")) {
                    object.folder_id = message.folder_id;
                    if (options.oneofs)
                        object._folder_id = "folder_id";
                }
                return object;
            };

            /**
             * Converts this GetFileListRequest to JSON.
             * @function toJSON
             * @memberof kritor.file.GetFileListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFileListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFileListRequest
             * @function getTypeUrl
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFileListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.GetFileListRequest";
            };

            return GetFileListRequest;
        })();

        file.GetFileListResponse = (function() {

            /**
             * Properties of a GetFileListResponse.
             * @memberof kritor.file
             * @interface IGetFileListResponse
             * @property {Array.<kritor.file.IFile>|null} [files] GetFileListResponse files
             * @property {Array.<kritor.file.IFolder>|null} [folders] GetFileListResponse folders
             */

            /**
             * Constructs a new GetFileListResponse.
             * @memberof kritor.file
             * @classdesc Represents a GetFileListResponse.
             * @implements IGetFileListResponse
             * @constructor
             * @param {kritor.file.IGetFileListResponse=} [properties] Properties to set
             */
            function GetFileListResponse(properties) {
                this.files = [];
                this.folders = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFileListResponse files.
             * @member {Array.<kritor.file.IFile>} files
             * @memberof kritor.file.GetFileListResponse
             * @instance
             */
            GetFileListResponse.prototype.files = $util.emptyArray;

            /**
             * GetFileListResponse folders.
             * @member {Array.<kritor.file.IFolder>} folders
             * @memberof kritor.file.GetFileListResponse
             * @instance
             */
            GetFileListResponse.prototype.folders = $util.emptyArray;

            /**
             * Creates a new GetFileListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {kritor.file.IGetFileListResponse=} [properties] Properties to set
             * @returns {kritor.file.GetFileListResponse} GetFileListResponse instance
             */
            GetFileListResponse.create = function create(properties) {
                return new GetFileListResponse(properties);
            };

            /**
             * Encodes the specified GetFileListResponse message. Does not implicitly {@link kritor.file.GetFileListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {kritor.file.IGetFileListResponse} message GetFileListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.files != null && message.files.length)
                    for (let i = 0; i < message.files.length; ++i)
                        $root.kritor.file.File.encode(message.files[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.folders != null && message.folders.length)
                    for (let i = 0; i < message.folders.length; ++i)
                        $root.kritor.file.Folder.encode(message.folders[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetFileListResponse message, length delimited. Does not implicitly {@link kritor.file.GetFileListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {kritor.file.IGetFileListResponse} message GetFileListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFileListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.GetFileListResponse} GetFileListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.GetFileListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.files && message.files.length))
                                message.files = [];
                            message.files.push($root.kritor.file.File.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.folders && message.folders.length))
                                message.folders = [];
                            message.folders.push($root.kritor.file.Folder.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFileListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.GetFileListResponse} GetFileListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFileListResponse message.
             * @function verify
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFileListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.files != null && message.hasOwnProperty("files")) {
                    if (!Array.isArray(message.files))
                        return "files: array expected";
                    for (let i = 0; i < message.files.length; ++i) {
                        let error = $root.kritor.file.File.verify(message.files[i]);
                        if (error)
                            return "files." + error;
                    }
                }
                if (message.folders != null && message.hasOwnProperty("folders")) {
                    if (!Array.isArray(message.folders))
                        return "folders: array expected";
                    for (let i = 0; i < message.folders.length; ++i) {
                        let error = $root.kritor.file.Folder.verify(message.folders[i]);
                        if (error)
                            return "folders." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetFileListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.GetFileListResponse} GetFileListResponse
             */
            GetFileListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.GetFileListResponse)
                    return object;
                let message = new $root.kritor.file.GetFileListResponse();
                if (object.files) {
                    if (!Array.isArray(object.files))
                        throw TypeError(".kritor.file.GetFileListResponse.files: array expected");
                    message.files = [];
                    for (let i = 0; i < object.files.length; ++i) {
                        if (typeof object.files[i] !== "object")
                            throw TypeError(".kritor.file.GetFileListResponse.files: object expected");
                        message.files[i] = $root.kritor.file.File.fromObject(object.files[i]);
                    }
                }
                if (object.folders) {
                    if (!Array.isArray(object.folders))
                        throw TypeError(".kritor.file.GetFileListResponse.folders: array expected");
                    message.folders = [];
                    for (let i = 0; i < object.folders.length; ++i) {
                        if (typeof object.folders[i] !== "object")
                            throw TypeError(".kritor.file.GetFileListResponse.folders: object expected");
                        message.folders[i] = $root.kritor.file.Folder.fromObject(object.folders[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetFileListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {kritor.file.GetFileListResponse} message GetFileListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFileListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.files = [];
                    object.folders = [];
                }
                if (message.files && message.files.length) {
                    object.files = [];
                    for (let j = 0; j < message.files.length; ++j)
                        object.files[j] = $root.kritor.file.File.toObject(message.files[j], options);
                }
                if (message.folders && message.folders.length) {
                    object.folders = [];
                    for (let j = 0; j < message.folders.length; ++j)
                        object.folders[j] = $root.kritor.file.Folder.toObject(message.folders[j], options);
                }
                return object;
            };

            /**
             * Converts this GetFileListResponse to JSON.
             * @function toJSON
             * @memberof kritor.file.GetFileListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFileListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFileListResponse
             * @function getTypeUrl
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFileListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.GetFileListResponse";
            };

            return GetFileListResponse;
        })();

        return file;
    })();

    kritor.friend = (function() {

        /**
         * Namespace friend.
         * @memberof kritor
         * @namespace
         */
        const friend = {};

        friend.FriendInfo = (function() {

            /**
             * Properties of a FriendInfo.
             * @memberof kritor.friend
             * @interface IFriendInfo
             * @property {string|null} [uid] FriendInfo uid
             * @property {number|Long|null} [uin] FriendInfo uin
             * @property {string|null} [qid] FriendInfo qid
             * @property {string|null} [nick] FriendInfo nick
             * @property {string|null} [remark] FriendInfo remark
             * @property {number|null} [level] FriendInfo level
             * @property {number|null} [age] FriendInfo age
             * @property {number|null} [vote_cnt] FriendInfo vote_cnt
             * @property {number|null} [gender] FriendInfo gender
             * @property {number|null} [group_id] FriendInfo group_id
             * @property {kritor.friend.IExtInfo|null} [ext] FriendInfo ext
             */

            /**
             * Constructs a new FriendInfo.
             * @memberof kritor.friend
             * @classdesc Represents a FriendInfo.
             * @implements IFriendInfo
             * @constructor
             * @param {kritor.friend.IFriendInfo=} [properties] Properties to set
             */
            function FriendInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendInfo uid.
             * @member {string} uid
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.uid = "";

            /**
             * FriendInfo uin.
             * @member {number|Long} uin
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendInfo qid.
             * @member {string} qid
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.qid = "";

            /**
             * FriendInfo nick.
             * @member {string} nick
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.nick = "";

            /**
             * FriendInfo remark.
             * @member {string} remark
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.remark = "";

            /**
             * FriendInfo level.
             * @member {number} level
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.level = 0;

            /**
             * FriendInfo age.
             * @member {number} age
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.age = 0;

            /**
             * FriendInfo vote_cnt.
             * @member {number} vote_cnt
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.vote_cnt = 0;

            /**
             * FriendInfo gender.
             * @member {number} gender
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.gender = 0;

            /**
             * FriendInfo group_id.
             * @member {number} group_id
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.group_id = 0;

            /**
             * FriendInfo ext.
             * @member {kritor.friend.IExtInfo|null|undefined} ext
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.ext = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * FriendInfo _ext.
             * @member {"ext"|undefined} _ext
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            Object.defineProperty(FriendInfo.prototype, "_ext", {
                get: $util.oneOfGetter($oneOfFields = ["ext"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new FriendInfo instance using the specified properties.
             * @function create
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {kritor.friend.IFriendInfo=} [properties] Properties to set
             * @returns {kritor.friend.FriendInfo} FriendInfo instance
             */
            FriendInfo.create = function create(properties) {
                return new FriendInfo(properties);
            };

            /**
             * Encodes the specified FriendInfo message. Does not implicitly {@link kritor.friend.FriendInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {kritor.friend.IFriendInfo} message FriendInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.qid != null && Object.hasOwnProperty.call(message, "qid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.qid);
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.nick);
                if (message.remark != null && Object.hasOwnProperty.call(message, "remark"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.remark);
                if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.level);
                if (message.age != null && Object.hasOwnProperty.call(message, "age"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.age);
                if (message.vote_cnt != null && Object.hasOwnProperty.call(message, "vote_cnt"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.vote_cnt);
                if (message.gender != null && Object.hasOwnProperty.call(message, "gender"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.gender);
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.group_id);
                if (message.ext != null && Object.hasOwnProperty.call(message, "ext"))
                    $root.kritor.friend.ExtInfo.encode(message.ext, writer.uint32(/* id 99, wireType 2 =*/794).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FriendInfo message, length delimited. Does not implicitly {@link kritor.friend.FriendInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {kritor.friend.IFriendInfo} message FriendInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.FriendInfo} FriendInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.FriendInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.qid = reader.string();
                            break;
                        }
                    case 4: {
                            message.nick = reader.string();
                            break;
                        }
                    case 5: {
                            message.remark = reader.string();
                            break;
                        }
                    case 6: {
                            message.level = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.age = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.vote_cnt = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.gender = reader.int32();
                            break;
                        }
                    case 10: {
                            message.group_id = reader.int32();
                            break;
                        }
                    case 99: {
                            message.ext = $root.kritor.friend.ExtInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.FriendInfo} FriendInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendInfo message.
             * @function verify
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.qid != null && message.hasOwnProperty("qid"))
                    if (!$util.isString(message.qid))
                        return "qid: string expected";
                if (message.nick != null && message.hasOwnProperty("nick"))
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                if (message.remark != null && message.hasOwnProperty("remark"))
                    if (!$util.isString(message.remark))
                        return "remark: string expected";
                if (message.level != null && message.hasOwnProperty("level"))
                    if (!$util.isInteger(message.level))
                        return "level: integer expected";
                if (message.age != null && message.hasOwnProperty("age"))
                    if (!$util.isInteger(message.age))
                        return "age: integer expected";
                if (message.vote_cnt != null && message.hasOwnProperty("vote_cnt"))
                    if (!$util.isInteger(message.vote_cnt))
                        return "vote_cnt: integer expected";
                if (message.gender != null && message.hasOwnProperty("gender"))
                    if (!$util.isInteger(message.gender))
                        return "gender: integer expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id))
                        return "group_id: integer expected";
                if (message.ext != null && message.hasOwnProperty("ext")) {
                    properties._ext = 1;
                    {
                        let error = $root.kritor.friend.ExtInfo.verify(message.ext);
                        if (error)
                            return "ext." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FriendInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.FriendInfo} FriendInfo
             */
            FriendInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.FriendInfo)
                    return object;
                let message = new $root.kritor.friend.FriendInfo();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.qid != null)
                    message.qid = String(object.qid);
                if (object.nick != null)
                    message.nick = String(object.nick);
                if (object.remark != null)
                    message.remark = String(object.remark);
                if (object.level != null)
                    message.level = object.level >>> 0;
                if (object.age != null)
                    message.age = object.age >>> 0;
                if (object.vote_cnt != null)
                    message.vote_cnt = object.vote_cnt >>> 0;
                if (object.gender != null)
                    message.gender = object.gender | 0;
                if (object.group_id != null)
                    message.group_id = object.group_id | 0;
                if (object.ext != null) {
                    if (typeof object.ext !== "object")
                        throw TypeError(".kritor.friend.FriendInfo.ext: object expected");
                    message.ext = $root.kritor.friend.ExtInfo.fromObject(object.ext);
                }
                return message;
            };

            /**
             * Creates a plain object from a FriendInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {kritor.friend.FriendInfo} message FriendInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.qid = "";
                    object.nick = "";
                    object.remark = "";
                    object.level = 0;
                    object.age = 0;
                    object.vote_cnt = 0;
                    object.gender = 0;
                    object.group_id = 0;
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.qid != null && message.hasOwnProperty("qid"))
                    object.qid = message.qid;
                if (message.nick != null && message.hasOwnProperty("nick"))
                    object.nick = message.nick;
                if (message.remark != null && message.hasOwnProperty("remark"))
                    object.remark = message.remark;
                if (message.level != null && message.hasOwnProperty("level"))
                    object.level = message.level;
                if (message.age != null && message.hasOwnProperty("age"))
                    object.age = message.age;
                if (message.vote_cnt != null && message.hasOwnProperty("vote_cnt"))
                    object.vote_cnt = message.vote_cnt;
                if (message.gender != null && message.hasOwnProperty("gender"))
                    object.gender = message.gender;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    object.group_id = message.group_id;
                if (message.ext != null && message.hasOwnProperty("ext")) {
                    object.ext = $root.kritor.friend.ExtInfo.toObject(message.ext, options);
                    if (options.oneofs)
                        object._ext = "ext";
                }
                return object;
            };

            /**
             * Converts this FriendInfo to JSON.
             * @function toJSON
             * @memberof kritor.friend.FriendInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendInfo
             * @function getTypeUrl
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.FriendInfo";
            };

            return FriendInfo;
        })();

        friend.ProfileCard = (function() {

            /**
             * Properties of a ProfileCard.
             * @memberof kritor.friend
             * @interface IProfileCard
             * @property {string|null} [uid] ProfileCard uid
             * @property {number|Long|null} [uin] ProfileCard uin
             * @property {string|null} [qid] ProfileCard qid
             * @property {string|null} [nick] ProfileCard nick
             * @property {string|null} [remark] ProfileCard remark
             * @property {number|null} [level] ProfileCard level
             * @property {number|Long|null} [birthday] ProfileCard birthday
             * @property {number|null} [login_day] ProfileCard login_day
             * @property {number|null} [vote_cnt] ProfileCard vote_cnt
             * @property {boolean|null} [is_school_verified] ProfileCard is_school_verified
             * @property {kritor.friend.IExtInfo|null} [ext] ProfileCard ext
             */

            /**
             * Constructs a new ProfileCard.
             * @memberof kritor.friend
             * @classdesc Represents a ProfileCard.
             * @implements IProfileCard
             * @constructor
             * @param {kritor.friend.IProfileCard=} [properties] Properties to set
             */
            function ProfileCard(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProfileCard uid.
             * @member {string} uid
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.uid = "";

            /**
             * ProfileCard uin.
             * @member {number|Long} uin
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ProfileCard qid.
             * @member {string} qid
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.qid = "";

            /**
             * ProfileCard nick.
             * @member {string} nick
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.nick = "";

            /**
             * ProfileCard remark.
             * @member {string|null|undefined} remark
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.remark = null;

            /**
             * ProfileCard level.
             * @member {number} level
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.level = 0;

            /**
             * ProfileCard birthday.
             * @member {number|Long|null|undefined} birthday
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.birthday = null;

            /**
             * ProfileCard login_day.
             * @member {number} login_day
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.login_day = 0;

            /**
             * ProfileCard vote_cnt.
             * @member {number} vote_cnt
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.vote_cnt = 0;

            /**
             * ProfileCard is_school_verified.
             * @member {boolean|null|undefined} is_school_verified
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.is_school_verified = null;

            /**
             * ProfileCard ext.
             * @member {kritor.friend.IExtInfo|null|undefined} ext
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.ext = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ProfileCard _remark.
             * @member {"remark"|undefined} _remark
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            Object.defineProperty(ProfileCard.prototype, "_remark", {
                get: $util.oneOfGetter($oneOfFields = ["remark"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ProfileCard _birthday.
             * @member {"birthday"|undefined} _birthday
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            Object.defineProperty(ProfileCard.prototype, "_birthday", {
                get: $util.oneOfGetter($oneOfFields = ["birthday"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ProfileCard _is_school_verified.
             * @member {"is_school_verified"|undefined} _is_school_verified
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            Object.defineProperty(ProfileCard.prototype, "_is_school_verified", {
                get: $util.oneOfGetter($oneOfFields = ["is_school_verified"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ProfileCard _ext.
             * @member {"ext"|undefined} _ext
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            Object.defineProperty(ProfileCard.prototype, "_ext", {
                get: $util.oneOfGetter($oneOfFields = ["ext"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ProfileCard instance using the specified properties.
             * @function create
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {kritor.friend.IProfileCard=} [properties] Properties to set
             * @returns {kritor.friend.ProfileCard} ProfileCard instance
             */
            ProfileCard.create = function create(properties) {
                return new ProfileCard(properties);
            };

            /**
             * Encodes the specified ProfileCard message. Does not implicitly {@link kritor.friend.ProfileCard.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {kritor.friend.IProfileCard} message ProfileCard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProfileCard.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.qid != null && Object.hasOwnProperty.call(message, "qid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.qid);
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.nick);
                if (message.remark != null && Object.hasOwnProperty.call(message, "remark"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.remark);
                if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.level);
                if (message.birthday != null && Object.hasOwnProperty.call(message, "birthday"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.birthday);
                if (message.login_day != null && Object.hasOwnProperty.call(message, "login_day"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.login_day);
                if (message.vote_cnt != null && Object.hasOwnProperty.call(message, "vote_cnt"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.vote_cnt);
                if (message.is_school_verified != null && Object.hasOwnProperty.call(message, "is_school_verified"))
                    writer.uint32(/* id 51, wireType 0 =*/408).bool(message.is_school_verified);
                if (message.ext != null && Object.hasOwnProperty.call(message, "ext"))
                    $root.kritor.friend.ExtInfo.encode(message.ext, writer.uint32(/* id 99, wireType 2 =*/794).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ProfileCard message, length delimited. Does not implicitly {@link kritor.friend.ProfileCard.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {kritor.friend.IProfileCard} message ProfileCard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProfileCard.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProfileCard message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.ProfileCard} ProfileCard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProfileCard.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.ProfileCard();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.qid = reader.string();
                            break;
                        }
                    case 4: {
                            message.nick = reader.string();
                            break;
                        }
                    case 5: {
                            message.remark = reader.string();
                            break;
                        }
                    case 6: {
                            message.level = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.birthday = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.login_day = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.vote_cnt = reader.uint32();
                            break;
                        }
                    case 51: {
                            message.is_school_verified = reader.bool();
                            break;
                        }
                    case 99: {
                            message.ext = $root.kritor.friend.ExtInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProfileCard message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.ProfileCard} ProfileCard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProfileCard.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProfileCard message.
             * @function verify
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProfileCard.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.qid != null && message.hasOwnProperty("qid"))
                    if (!$util.isString(message.qid))
                        return "qid: string expected";
                if (message.nick != null && message.hasOwnProperty("nick"))
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                if (message.remark != null && message.hasOwnProperty("remark")) {
                    properties._remark = 1;
                    if (!$util.isString(message.remark))
                        return "remark: string expected";
                }
                if (message.level != null && message.hasOwnProperty("level"))
                    if (!$util.isInteger(message.level))
                        return "level: integer expected";
                if (message.birthday != null && message.hasOwnProperty("birthday")) {
                    properties._birthday = 1;
                    if (!$util.isInteger(message.birthday) && !(message.birthday && $util.isInteger(message.birthday.low) && $util.isInteger(message.birthday.high)))
                        return "birthday: integer|Long expected";
                }
                if (message.login_day != null && message.hasOwnProperty("login_day"))
                    if (!$util.isInteger(message.login_day))
                        return "login_day: integer expected";
                if (message.vote_cnt != null && message.hasOwnProperty("vote_cnt"))
                    if (!$util.isInteger(message.vote_cnt))
                        return "vote_cnt: integer expected";
                if (message.is_school_verified != null && message.hasOwnProperty("is_school_verified")) {
                    properties._is_school_verified = 1;
                    if (typeof message.is_school_verified !== "boolean")
                        return "is_school_verified: boolean expected";
                }
                if (message.ext != null && message.hasOwnProperty("ext")) {
                    properties._ext = 1;
                    {
                        let error = $root.kritor.friend.ExtInfo.verify(message.ext);
                        if (error)
                            return "ext." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ProfileCard message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.ProfileCard} ProfileCard
             */
            ProfileCard.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.ProfileCard)
                    return object;
                let message = new $root.kritor.friend.ProfileCard();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.qid != null)
                    message.qid = String(object.qid);
                if (object.nick != null)
                    message.nick = String(object.nick);
                if (object.remark != null)
                    message.remark = String(object.remark);
                if (object.level != null)
                    message.level = object.level >>> 0;
                if (object.birthday != null)
                    if ($util.Long)
                        (message.birthday = $util.Long.fromValue(object.birthday)).unsigned = true;
                    else if (typeof object.birthday === "string")
                        message.birthday = parseInt(object.birthday, 10);
                    else if (typeof object.birthday === "number")
                        message.birthday = object.birthday;
                    else if (typeof object.birthday === "object")
                        message.birthday = new $util.LongBits(object.birthday.low >>> 0, object.birthday.high >>> 0).toNumber(true);
                if (object.login_day != null)
                    message.login_day = object.login_day >>> 0;
                if (object.vote_cnt != null)
                    message.vote_cnt = object.vote_cnt >>> 0;
                if (object.is_school_verified != null)
                    message.is_school_verified = Boolean(object.is_school_verified);
                if (object.ext != null) {
                    if (typeof object.ext !== "object")
                        throw TypeError(".kritor.friend.ProfileCard.ext: object expected");
                    message.ext = $root.kritor.friend.ExtInfo.fromObject(object.ext);
                }
                return message;
            };

            /**
             * Creates a plain object from a ProfileCard message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {kritor.friend.ProfileCard} message ProfileCard
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProfileCard.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.qid = "";
                    object.nick = "";
                    object.level = 0;
                    object.login_day = 0;
                    object.vote_cnt = 0;
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.qid != null && message.hasOwnProperty("qid"))
                    object.qid = message.qid;
                if (message.nick != null && message.hasOwnProperty("nick"))
                    object.nick = message.nick;
                if (message.remark != null && message.hasOwnProperty("remark")) {
                    object.remark = message.remark;
                    if (options.oneofs)
                        object._remark = "remark";
                }
                if (message.level != null && message.hasOwnProperty("level"))
                    object.level = message.level;
                if (message.birthday != null && message.hasOwnProperty("birthday")) {
                    if (typeof message.birthday === "number")
                        object.birthday = options.longs === String ? String(message.birthday) : message.birthday;
                    else
                        object.birthday = options.longs === String ? $util.Long.prototype.toString.call(message.birthday) : options.longs === Number ? new $util.LongBits(message.birthday.low >>> 0, message.birthday.high >>> 0).toNumber(true) : message.birthday;
                    if (options.oneofs)
                        object._birthday = "birthday";
                }
                if (message.login_day != null && message.hasOwnProperty("login_day"))
                    object.login_day = message.login_day;
                if (message.vote_cnt != null && message.hasOwnProperty("vote_cnt"))
                    object.vote_cnt = message.vote_cnt;
                if (message.is_school_verified != null && message.hasOwnProperty("is_school_verified")) {
                    object.is_school_verified = message.is_school_verified;
                    if (options.oneofs)
                        object._is_school_verified = "is_school_verified";
                }
                if (message.ext != null && message.hasOwnProperty("ext")) {
                    object.ext = $root.kritor.friend.ExtInfo.toObject(message.ext, options);
                    if (options.oneofs)
                        object._ext = "ext";
                }
                return object;
            };

            /**
             * Converts this ProfileCard to JSON.
             * @function toJSON
             * @memberof kritor.friend.ProfileCard
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProfileCard.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ProfileCard
             * @function getTypeUrl
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ProfileCard.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.ProfileCard";
            };

            return ProfileCard;
        })();

        friend.ExtInfo = (function() {

            /**
             * Properties of an ExtInfo.
             * @memberof kritor.friend
             * @interface IExtInfo
             * @property {boolean|null} [big_vip] ExtInfo big_vip
             * @property {boolean|null} [hollywood_vip] ExtInfo hollywood_vip
             * @property {boolean|null} [qq_vip] ExtInfo qq_vip
             * @property {boolean|null} [super_vip] ExtInfo super_vip
             * @property {boolean|null} [voted] ExtInfo voted
             */

            /**
             * Constructs a new ExtInfo.
             * @memberof kritor.friend
             * @classdesc Represents an ExtInfo.
             * @implements IExtInfo
             * @constructor
             * @param {kritor.friend.IExtInfo=} [properties] Properties to set
             */
            function ExtInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExtInfo big_vip.
             * @member {boolean|null|undefined} big_vip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            ExtInfo.prototype.big_vip = null;

            /**
             * ExtInfo hollywood_vip.
             * @member {boolean|null|undefined} hollywood_vip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            ExtInfo.prototype.hollywood_vip = null;

            /**
             * ExtInfo qq_vip.
             * @member {boolean|null|undefined} qq_vip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            ExtInfo.prototype.qq_vip = null;

            /**
             * ExtInfo super_vip.
             * @member {boolean|null|undefined} super_vip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            ExtInfo.prototype.super_vip = null;

            /**
             * ExtInfo voted.
             * @member {boolean|null|undefined} voted
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            ExtInfo.prototype.voted = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ExtInfo _big_vip.
             * @member {"big_vip"|undefined} _big_vip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            Object.defineProperty(ExtInfo.prototype, "_big_vip", {
                get: $util.oneOfGetter($oneOfFields = ["big_vip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ExtInfo _hollywood_vip.
             * @member {"hollywood_vip"|undefined} _hollywood_vip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            Object.defineProperty(ExtInfo.prototype, "_hollywood_vip", {
                get: $util.oneOfGetter($oneOfFields = ["hollywood_vip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ExtInfo _qq_vip.
             * @member {"qq_vip"|undefined} _qq_vip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            Object.defineProperty(ExtInfo.prototype, "_qq_vip", {
                get: $util.oneOfGetter($oneOfFields = ["qq_vip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ExtInfo _super_vip.
             * @member {"super_vip"|undefined} _super_vip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            Object.defineProperty(ExtInfo.prototype, "_super_vip", {
                get: $util.oneOfGetter($oneOfFields = ["super_vip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ExtInfo _voted.
             * @member {"voted"|undefined} _voted
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            Object.defineProperty(ExtInfo.prototype, "_voted", {
                get: $util.oneOfGetter($oneOfFields = ["voted"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ExtInfo instance using the specified properties.
             * @function create
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {kritor.friend.IExtInfo=} [properties] Properties to set
             * @returns {kritor.friend.ExtInfo} ExtInfo instance
             */
            ExtInfo.create = function create(properties) {
                return new ExtInfo(properties);
            };

            /**
             * Encodes the specified ExtInfo message. Does not implicitly {@link kritor.friend.ExtInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {kritor.friend.IExtInfo} message ExtInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.big_vip != null && Object.hasOwnProperty.call(message, "big_vip"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.big_vip);
                if (message.hollywood_vip != null && Object.hasOwnProperty.call(message, "hollywood_vip"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hollywood_vip);
                if (message.qq_vip != null && Object.hasOwnProperty.call(message, "qq_vip"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.qq_vip);
                if (message.super_vip != null && Object.hasOwnProperty.call(message, "super_vip"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.super_vip);
                if (message.voted != null && Object.hasOwnProperty.call(message, "voted"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.voted);
                return writer;
            };

            /**
             * Encodes the specified ExtInfo message, length delimited. Does not implicitly {@link kritor.friend.ExtInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {kritor.friend.IExtInfo} message ExtInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExtInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.ExtInfo} ExtInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.ExtInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.big_vip = reader.bool();
                            break;
                        }
                    case 2: {
                            message.hollywood_vip = reader.bool();
                            break;
                        }
                    case 3: {
                            message.qq_vip = reader.bool();
                            break;
                        }
                    case 4: {
                            message.super_vip = reader.bool();
                            break;
                        }
                    case 5: {
                            message.voted = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExtInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.ExtInfo} ExtInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExtInfo message.
             * @function verify
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExtInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.big_vip != null && message.hasOwnProperty("big_vip")) {
                    properties._big_vip = 1;
                    if (typeof message.big_vip !== "boolean")
                        return "big_vip: boolean expected";
                }
                if (message.hollywood_vip != null && message.hasOwnProperty("hollywood_vip")) {
                    properties._hollywood_vip = 1;
                    if (typeof message.hollywood_vip !== "boolean")
                        return "hollywood_vip: boolean expected";
                }
                if (message.qq_vip != null && message.hasOwnProperty("qq_vip")) {
                    properties._qq_vip = 1;
                    if (typeof message.qq_vip !== "boolean")
                        return "qq_vip: boolean expected";
                }
                if (message.super_vip != null && message.hasOwnProperty("super_vip")) {
                    properties._super_vip = 1;
                    if (typeof message.super_vip !== "boolean")
                        return "super_vip: boolean expected";
                }
                if (message.voted != null && message.hasOwnProperty("voted")) {
                    properties._voted = 1;
                    if (typeof message.voted !== "boolean")
                        return "voted: boolean expected";
                }
                return null;
            };

            /**
             * Creates an ExtInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.ExtInfo} ExtInfo
             */
            ExtInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.ExtInfo)
                    return object;
                let message = new $root.kritor.friend.ExtInfo();
                if (object.big_vip != null)
                    message.big_vip = Boolean(object.big_vip);
                if (object.hollywood_vip != null)
                    message.hollywood_vip = Boolean(object.hollywood_vip);
                if (object.qq_vip != null)
                    message.qq_vip = Boolean(object.qq_vip);
                if (object.super_vip != null)
                    message.super_vip = Boolean(object.super_vip);
                if (object.voted != null)
                    message.voted = Boolean(object.voted);
                return message;
            };

            /**
             * Creates a plain object from an ExtInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {kritor.friend.ExtInfo} message ExtInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExtInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.big_vip != null && message.hasOwnProperty("big_vip")) {
                    object.big_vip = message.big_vip;
                    if (options.oneofs)
                        object._big_vip = "big_vip";
                }
                if (message.hollywood_vip != null && message.hasOwnProperty("hollywood_vip")) {
                    object.hollywood_vip = message.hollywood_vip;
                    if (options.oneofs)
                        object._hollywood_vip = "hollywood_vip";
                }
                if (message.qq_vip != null && message.hasOwnProperty("qq_vip")) {
                    object.qq_vip = message.qq_vip;
                    if (options.oneofs)
                        object._qq_vip = "qq_vip";
                }
                if (message.super_vip != null && message.hasOwnProperty("super_vip")) {
                    object.super_vip = message.super_vip;
                    if (options.oneofs)
                        object._super_vip = "super_vip";
                }
                if (message.voted != null && message.hasOwnProperty("voted")) {
                    object.voted = message.voted;
                    if (options.oneofs)
                        object._voted = "voted";
                }
                return object;
            };

            /**
             * Converts this ExtInfo to JSON.
             * @function toJSON
             * @memberof kritor.friend.ExtInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExtInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ExtInfo
             * @function getTypeUrl
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ExtInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.ExtInfo";
            };

            return ExtInfo;
        })();

        friend.FriendService = (function() {

            /**
             * Constructs a new FriendService service.
             * @memberof kritor.friend
             * @classdesc Represents a FriendService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function FriendService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (FriendService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FriendService;

            /**
             * Creates new FriendService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.friend.FriendService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {FriendService} RPC service. Useful where requests and/or responses are streamed.
             */
            FriendService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.friend.FriendService#getFriendList}.
             * @memberof kritor.friend.FriendService
             * @typedef GetFriendListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.GetFriendListResponse} [response] GetFriendListResponse
             */

            /**
             * Calls GetFriendList.
             * @function getFriendList
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetFriendListRequest} request GetFriendListRequest message or plain object
             * @param {kritor.friend.FriendService.GetFriendListCallback} callback Node-style callback called with the error, if any, and GetFriendListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.getFriendList = function getFriendList(request, callback) {
                return this.rpcCall(getFriendList, $root.kritor.friend.GetFriendListRequest, $root.kritor.friend.GetFriendListResponse, request, callback);
            }, "name", { value: "GetFriendList" });

            /**
             * Calls GetFriendList.
             * @function getFriendList
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetFriendListRequest} request GetFriendListRequest message or plain object
             * @returns {Promise<kritor.friend.GetFriendListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.friend.FriendService#getFriendProfileCard}.
             * @memberof kritor.friend.FriendService
             * @typedef GetFriendProfileCardCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.GetFriendProfileCardResponse} [response] GetFriendProfileCardResponse
             */

            /**
             * Calls GetFriendProfileCard.
             * @function getFriendProfileCard
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetFriendProfileCardRequest} request GetFriendProfileCardRequest message or plain object
             * @param {kritor.friend.FriendService.GetFriendProfileCardCallback} callback Node-style callback called with the error, if any, and GetFriendProfileCardResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.getFriendProfileCard = function getFriendProfileCard(request, callback) {
                return this.rpcCall(getFriendProfileCard, $root.kritor.friend.GetFriendProfileCardRequest, $root.kritor.friend.GetFriendProfileCardResponse, request, callback);
            }, "name", { value: "GetFriendProfileCard" });

            /**
             * Calls GetFriendProfileCard.
             * @function getFriendProfileCard
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetFriendProfileCardRequest} request GetFriendProfileCardRequest message or plain object
             * @returns {Promise<kritor.friend.GetFriendProfileCardResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.friend.FriendService#getStrangerProfileCard}.
             * @memberof kritor.friend.FriendService
             * @typedef GetStrangerProfileCardCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.GetStrangerProfileCardResponse} [response] GetStrangerProfileCardResponse
             */

            /**
             * Calls GetStrangerProfileCard.
             * @function getStrangerProfileCard
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetStrangerProfileCardRequest} request GetStrangerProfileCardRequest message or plain object
             * @param {kritor.friend.FriendService.GetStrangerProfileCardCallback} callback Node-style callback called with the error, if any, and GetStrangerProfileCardResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.getStrangerProfileCard = function getStrangerProfileCard(request, callback) {
                return this.rpcCall(getStrangerProfileCard, $root.kritor.friend.GetStrangerProfileCardRequest, $root.kritor.friend.GetStrangerProfileCardResponse, request, callback);
            }, "name", { value: "GetStrangerProfileCard" });

            /**
             * Calls GetStrangerProfileCard.
             * @function getStrangerProfileCard
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetStrangerProfileCardRequest} request GetStrangerProfileCardRequest message or plain object
             * @returns {Promise<kritor.friend.GetStrangerProfileCardResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.friend.FriendService#setProfileCard}.
             * @memberof kritor.friend.FriendService
             * @typedef SetProfileCardCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.SetProfileCardResponse} [response] SetProfileCardResponse
             */

            /**
             * Calls SetProfileCard.
             * @function setProfileCard
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.ISetProfileCardRequest} request SetProfileCardRequest message or plain object
             * @param {kritor.friend.FriendService.SetProfileCardCallback} callback Node-style callback called with the error, if any, and SetProfileCardResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.setProfileCard = function setProfileCard(request, callback) {
                return this.rpcCall(setProfileCard, $root.kritor.friend.SetProfileCardRequest, $root.kritor.friend.SetProfileCardResponse, request, callback);
            }, "name", { value: "SetProfileCard" });

            /**
             * Calls SetProfileCard.
             * @function setProfileCard
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.ISetProfileCardRequest} request SetProfileCardRequest message or plain object
             * @returns {Promise<kritor.friend.SetProfileCardResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.friend.FriendService#isBlackListUser}.
             * @memberof kritor.friend.FriendService
             * @typedef IsBlackListUserCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.IsBlackListUserResponse} [response] IsBlackListUserResponse
             */

            /**
             * Calls IsBlackListUser.
             * @function isBlackListUser
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IIsBlackListUserRequest} request IsBlackListUserRequest message or plain object
             * @param {kritor.friend.FriendService.IsBlackListUserCallback} callback Node-style callback called with the error, if any, and IsBlackListUserResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.isBlackListUser = function isBlackListUser(request, callback) {
                return this.rpcCall(isBlackListUser, $root.kritor.friend.IsBlackListUserRequest, $root.kritor.friend.IsBlackListUserResponse, request, callback);
            }, "name", { value: "IsBlackListUser" });

            /**
             * Calls IsBlackListUser.
             * @function isBlackListUser
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IIsBlackListUserRequest} request IsBlackListUserRequest message or plain object
             * @returns {Promise<kritor.friend.IsBlackListUserResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.friend.FriendService#voteUser}.
             * @memberof kritor.friend.FriendService
             * @typedef VoteUserCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.VoteUserResponse} [response] VoteUserResponse
             */

            /**
             * Calls VoteUser.
             * @function voteUser
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IVoteUserRequest} request VoteUserRequest message or plain object
             * @param {kritor.friend.FriendService.VoteUserCallback} callback Node-style callback called with the error, if any, and VoteUserResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.voteUser = function voteUser(request, callback) {
                return this.rpcCall(voteUser, $root.kritor.friend.VoteUserRequest, $root.kritor.friend.VoteUserResponse, request, callback);
            }, "name", { value: "VoteUser" });

            /**
             * Calls VoteUser.
             * @function voteUser
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IVoteUserRequest} request VoteUserRequest message or plain object
             * @returns {Promise<kritor.friend.VoteUserResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.friend.FriendService#getUidByUin}.
             * @memberof kritor.friend.FriendService
             * @typedef GetUidByUinCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.GetUidByUinResponse} [response] GetUidByUinResponse
             */

            /**
             * Calls GetUidByUin.
             * @function getUidByUin
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetUidByUinRequest} request GetUidByUinRequest message or plain object
             * @param {kritor.friend.FriendService.GetUidByUinCallback} callback Node-style callback called with the error, if any, and GetUidByUinResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.getUidByUin = function getUidByUin(request, callback) {
                return this.rpcCall(getUidByUin, $root.kritor.friend.GetUidByUinRequest, $root.kritor.friend.GetUidByUinResponse, request, callback);
            }, "name", { value: "GetUidByUin" });

            /**
             * Calls GetUidByUin.
             * @function getUidByUin
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetUidByUinRequest} request GetUidByUinRequest message or plain object
             * @returns {Promise<kritor.friend.GetUidByUinResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.friend.FriendService#getUinByUid}.
             * @memberof kritor.friend.FriendService
             * @typedef GetUinByUidCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.GetUinByUidResponse} [response] GetUinByUidResponse
             */

            /**
             * Calls GetUinByUid.
             * @function getUinByUid
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetUinByUidRequest} request GetUinByUidRequest message or plain object
             * @param {kritor.friend.FriendService.GetUinByUidCallback} callback Node-style callback called with the error, if any, and GetUinByUidResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.getUinByUid = function getUinByUid(request, callback) {
                return this.rpcCall(getUinByUid, $root.kritor.friend.GetUinByUidRequest, $root.kritor.friend.GetUinByUidResponse, request, callback);
            }, "name", { value: "GetUinByUid" });

            /**
             * Calls GetUinByUid.
             * @function getUinByUid
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetUinByUidRequest} request GetUinByUidRequest message or plain object
             * @returns {Promise<kritor.friend.GetUinByUidResponse>} Promise
             * @variation 2
             */

            return FriendService;
        })();

        friend.GetFriendListRequest = (function() {

            /**
             * Properties of a GetFriendListRequest.
             * @memberof kritor.friend
             * @interface IGetFriendListRequest
             * @property {boolean|null} [refresh] GetFriendListRequest refresh
             */

            /**
             * Constructs a new GetFriendListRequest.
             * @memberof kritor.friend
             * @classdesc Represents a GetFriendListRequest.
             * @implements IGetFriendListRequest
             * @constructor
             * @param {kritor.friend.IGetFriendListRequest=} [properties] Properties to set
             */
            function GetFriendListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFriendListRequest refresh.
             * @member {boolean|null|undefined} refresh
             * @memberof kritor.friend.GetFriendListRequest
             * @instance
             */
            GetFriendListRequest.prototype.refresh = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetFriendListRequest _refresh.
             * @member {"refresh"|undefined} _refresh
             * @memberof kritor.friend.GetFriendListRequest
             * @instance
             */
            Object.defineProperty(GetFriendListRequest.prototype, "_refresh", {
                get: $util.oneOfGetter($oneOfFields = ["refresh"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetFriendListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {kritor.friend.IGetFriendListRequest=} [properties] Properties to set
             * @returns {kritor.friend.GetFriendListRequest} GetFriendListRequest instance
             */
            GetFriendListRequest.create = function create(properties) {
                return new GetFriendListRequest(properties);
            };

            /**
             * Encodes the specified GetFriendListRequest message. Does not implicitly {@link kritor.friend.GetFriendListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {kritor.friend.IGetFriendListRequest} message GetFriendListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetFriendListRequest message, length delimited. Does not implicitly {@link kritor.friend.GetFriendListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {kritor.friend.IGetFriendListRequest} message GetFriendListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFriendListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetFriendListRequest} GetFriendListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetFriendListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFriendListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetFriendListRequest} GetFriendListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFriendListRequest message.
             * @function verify
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFriendListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    properties._refresh = 1;
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetFriendListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetFriendListRequest} GetFriendListRequest
             */
            GetFriendListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetFriendListRequest)
                    return object;
                let message = new $root.kritor.friend.GetFriendListRequest();
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetFriendListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {kritor.friend.GetFriendListRequest} message GetFriendListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFriendListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    object.refresh = message.refresh;
                    if (options.oneofs)
                        object._refresh = "refresh";
                }
                return object;
            };

            /**
             * Converts this GetFriendListRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetFriendListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFriendListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFriendListRequest
             * @function getTypeUrl
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFriendListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetFriendListRequest";
            };

            return GetFriendListRequest;
        })();

        friend.GetFriendListResponse = (function() {

            /**
             * Properties of a GetFriendListResponse.
             * @memberof kritor.friend
             * @interface IGetFriendListResponse
             * @property {Array.<kritor.friend.IFriendInfo>|null} [friends_info] GetFriendListResponse friends_info
             */

            /**
             * Constructs a new GetFriendListResponse.
             * @memberof kritor.friend
             * @classdesc Represents a GetFriendListResponse.
             * @implements IGetFriendListResponse
             * @constructor
             * @param {kritor.friend.IGetFriendListResponse=} [properties] Properties to set
             */
            function GetFriendListResponse(properties) {
                this.friends_info = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFriendListResponse friends_info.
             * @member {Array.<kritor.friend.IFriendInfo>} friends_info
             * @memberof kritor.friend.GetFriendListResponse
             * @instance
             */
            GetFriendListResponse.prototype.friends_info = $util.emptyArray;

            /**
             * Creates a new GetFriendListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {kritor.friend.IGetFriendListResponse=} [properties] Properties to set
             * @returns {kritor.friend.GetFriendListResponse} GetFriendListResponse instance
             */
            GetFriendListResponse.create = function create(properties) {
                return new GetFriendListResponse(properties);
            };

            /**
             * Encodes the specified GetFriendListResponse message. Does not implicitly {@link kritor.friend.GetFriendListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {kritor.friend.IGetFriendListResponse} message GetFriendListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.friends_info != null && message.friends_info.length)
                    for (let i = 0; i < message.friends_info.length; ++i)
                        $root.kritor.friend.FriendInfo.encode(message.friends_info[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetFriendListResponse message, length delimited. Does not implicitly {@link kritor.friend.GetFriendListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {kritor.friend.IGetFriendListResponse} message GetFriendListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFriendListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetFriendListResponse} GetFriendListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetFriendListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.friends_info && message.friends_info.length))
                                message.friends_info = [];
                            message.friends_info.push($root.kritor.friend.FriendInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFriendListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetFriendListResponse} GetFriendListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFriendListResponse message.
             * @function verify
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFriendListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.friends_info != null && message.hasOwnProperty("friends_info")) {
                    if (!Array.isArray(message.friends_info))
                        return "friends_info: array expected";
                    for (let i = 0; i < message.friends_info.length; ++i) {
                        let error = $root.kritor.friend.FriendInfo.verify(message.friends_info[i]);
                        if (error)
                            return "friends_info." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetFriendListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetFriendListResponse} GetFriendListResponse
             */
            GetFriendListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetFriendListResponse)
                    return object;
                let message = new $root.kritor.friend.GetFriendListResponse();
                if (object.friends_info) {
                    if (!Array.isArray(object.friends_info))
                        throw TypeError(".kritor.friend.GetFriendListResponse.friends_info: array expected");
                    message.friends_info = [];
                    for (let i = 0; i < object.friends_info.length; ++i) {
                        if (typeof object.friends_info[i] !== "object")
                            throw TypeError(".kritor.friend.GetFriendListResponse.friends_info: object expected");
                        message.friends_info[i] = $root.kritor.friend.FriendInfo.fromObject(object.friends_info[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetFriendListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {kritor.friend.GetFriendListResponse} message GetFriendListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFriendListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.friends_info = [];
                if (message.friends_info && message.friends_info.length) {
                    object.friends_info = [];
                    for (let j = 0; j < message.friends_info.length; ++j)
                        object.friends_info[j] = $root.kritor.friend.FriendInfo.toObject(message.friends_info[j], options);
                }
                return object;
            };

            /**
             * Converts this GetFriendListResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetFriendListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFriendListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFriendListResponse
             * @function getTypeUrl
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFriendListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetFriendListResponse";
            };

            return GetFriendListResponse;
        })();

        friend.GetFriendProfileCardRequest = (function() {

            /**
             * Properties of a GetFriendProfileCardRequest.
             * @memberof kritor.friend
             * @interface IGetFriendProfileCardRequest
             * @property {Array.<string>|null} [target_uids] GetFriendProfileCardRequest target_uids
             * @property {Array.<number|Long>|null} [target_uins] GetFriendProfileCardRequest target_uins
             */

            /**
             * Constructs a new GetFriendProfileCardRequest.
             * @memberof kritor.friend
             * @classdesc Represents a GetFriendProfileCardRequest.
             * @implements IGetFriendProfileCardRequest
             * @constructor
             * @param {kritor.friend.IGetFriendProfileCardRequest=} [properties] Properties to set
             */
            function GetFriendProfileCardRequest(properties) {
                this.target_uids = [];
                this.target_uins = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFriendProfileCardRequest target_uids.
             * @member {Array.<string>} target_uids
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @instance
             */
            GetFriendProfileCardRequest.prototype.target_uids = $util.emptyArray;

            /**
             * GetFriendProfileCardRequest target_uins.
             * @member {Array.<number|Long>} target_uins
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @instance
             */
            GetFriendProfileCardRequest.prototype.target_uins = $util.emptyArray;

            /**
             * Creates a new GetFriendProfileCardRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {kritor.friend.IGetFriendProfileCardRequest=} [properties] Properties to set
             * @returns {kritor.friend.GetFriendProfileCardRequest} GetFriendProfileCardRequest instance
             */
            GetFriendProfileCardRequest.create = function create(properties) {
                return new GetFriendProfileCardRequest(properties);
            };

            /**
             * Encodes the specified GetFriendProfileCardRequest message. Does not implicitly {@link kritor.friend.GetFriendProfileCardRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {kritor.friend.IGetFriendProfileCardRequest} message GetFriendProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendProfileCardRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target_uids != null && message.target_uids.length)
                    for (let i = 0; i < message.target_uids.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.target_uids[i]);
                if (message.target_uins != null && message.target_uins.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (let i = 0; i < message.target_uins.length; ++i)
                        writer.uint64(message.target_uins[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified GetFriendProfileCardRequest message, length delimited. Does not implicitly {@link kritor.friend.GetFriendProfileCardRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {kritor.friend.IGetFriendProfileCardRequest} message GetFriendProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendProfileCardRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFriendProfileCardRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetFriendProfileCardRequest} GetFriendProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendProfileCardRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetFriendProfileCardRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.target_uids && message.target_uids.length))
                                message.target_uids = [];
                            message.target_uids.push(reader.string());
                            break;
                        }
                    case 2: {
                            if (!(message.target_uins && message.target_uins.length))
                                message.target_uins = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.target_uins.push(reader.uint64());
                            } else
                                message.target_uins.push(reader.uint64());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFriendProfileCardRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetFriendProfileCardRequest} GetFriendProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendProfileCardRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFriendProfileCardRequest message.
             * @function verify
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFriendProfileCardRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.target_uids != null && message.hasOwnProperty("target_uids")) {
                    if (!Array.isArray(message.target_uids))
                        return "target_uids: array expected";
                    for (let i = 0; i < message.target_uids.length; ++i)
                        if (!$util.isString(message.target_uids[i]))
                            return "target_uids: string[] expected";
                }
                if (message.target_uins != null && message.hasOwnProperty("target_uins")) {
                    if (!Array.isArray(message.target_uins))
                        return "target_uins: array expected";
                    for (let i = 0; i < message.target_uins.length; ++i)
                        if (!$util.isInteger(message.target_uins[i]) && !(message.target_uins[i] && $util.isInteger(message.target_uins[i].low) && $util.isInteger(message.target_uins[i].high)))
                            return "target_uins: integer|Long[] expected";
                }
                return null;
            };

            /**
             * Creates a GetFriendProfileCardRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetFriendProfileCardRequest} GetFriendProfileCardRequest
             */
            GetFriendProfileCardRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetFriendProfileCardRequest)
                    return object;
                let message = new $root.kritor.friend.GetFriendProfileCardRequest();
                if (object.target_uids) {
                    if (!Array.isArray(object.target_uids))
                        throw TypeError(".kritor.friend.GetFriendProfileCardRequest.target_uids: array expected");
                    message.target_uids = [];
                    for (let i = 0; i < object.target_uids.length; ++i)
                        message.target_uids[i] = String(object.target_uids[i]);
                }
                if (object.target_uins) {
                    if (!Array.isArray(object.target_uins))
                        throw TypeError(".kritor.friend.GetFriendProfileCardRequest.target_uins: array expected");
                    message.target_uins = [];
                    for (let i = 0; i < object.target_uins.length; ++i)
                        if ($util.Long)
                            (message.target_uins[i] = $util.Long.fromValue(object.target_uins[i])).unsigned = true;
                        else if (typeof object.target_uins[i] === "string")
                            message.target_uins[i] = parseInt(object.target_uins[i], 10);
                        else if (typeof object.target_uins[i] === "number")
                            message.target_uins[i] = object.target_uins[i];
                        else if (typeof object.target_uins[i] === "object")
                            message.target_uins[i] = new $util.LongBits(object.target_uins[i].low >>> 0, object.target_uins[i].high >>> 0).toNumber(true);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetFriendProfileCardRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {kritor.friend.GetFriendProfileCardRequest} message GetFriendProfileCardRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFriendProfileCardRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.target_uids = [];
                    object.target_uins = [];
                }
                if (message.target_uids && message.target_uids.length) {
                    object.target_uids = [];
                    for (let j = 0; j < message.target_uids.length; ++j)
                        object.target_uids[j] = message.target_uids[j];
                }
                if (message.target_uins && message.target_uins.length) {
                    object.target_uins = [];
                    for (let j = 0; j < message.target_uins.length; ++j)
                        if (typeof message.target_uins[j] === "number")
                            object.target_uins[j] = options.longs === String ? String(message.target_uins[j]) : message.target_uins[j];
                        else
                            object.target_uins[j] = options.longs === String ? $util.Long.prototype.toString.call(message.target_uins[j]) : options.longs === Number ? new $util.LongBits(message.target_uins[j].low >>> 0, message.target_uins[j].high >>> 0).toNumber(true) : message.target_uins[j];
                }
                return object;
            };

            /**
             * Converts this GetFriendProfileCardRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFriendProfileCardRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFriendProfileCardRequest
             * @function getTypeUrl
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFriendProfileCardRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetFriendProfileCardRequest";
            };

            return GetFriendProfileCardRequest;
        })();

        friend.GetFriendProfileCardResponse = (function() {

            /**
             * Properties of a GetFriendProfileCardResponse.
             * @memberof kritor.friend
             * @interface IGetFriendProfileCardResponse
             * @property {Array.<kritor.friend.IProfileCard>|null} [friends_profile_card] GetFriendProfileCardResponse friends_profile_card
             */

            /**
             * Constructs a new GetFriendProfileCardResponse.
             * @memberof kritor.friend
             * @classdesc Represents a GetFriendProfileCardResponse.
             * @implements IGetFriendProfileCardResponse
             * @constructor
             * @param {kritor.friend.IGetFriendProfileCardResponse=} [properties] Properties to set
             */
            function GetFriendProfileCardResponse(properties) {
                this.friends_profile_card = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFriendProfileCardResponse friends_profile_card.
             * @member {Array.<kritor.friend.IProfileCard>} friends_profile_card
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @instance
             */
            GetFriendProfileCardResponse.prototype.friends_profile_card = $util.emptyArray;

            /**
             * Creates a new GetFriendProfileCardResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {kritor.friend.IGetFriendProfileCardResponse=} [properties] Properties to set
             * @returns {kritor.friend.GetFriendProfileCardResponse} GetFriendProfileCardResponse instance
             */
            GetFriendProfileCardResponse.create = function create(properties) {
                return new GetFriendProfileCardResponse(properties);
            };

            /**
             * Encodes the specified GetFriendProfileCardResponse message. Does not implicitly {@link kritor.friend.GetFriendProfileCardResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {kritor.friend.IGetFriendProfileCardResponse} message GetFriendProfileCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendProfileCardResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.friends_profile_card != null && message.friends_profile_card.length)
                    for (let i = 0; i < message.friends_profile_card.length; ++i)
                        $root.kritor.friend.ProfileCard.encode(message.friends_profile_card[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetFriendProfileCardResponse message, length delimited. Does not implicitly {@link kritor.friend.GetFriendProfileCardResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {kritor.friend.IGetFriendProfileCardResponse} message GetFriendProfileCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendProfileCardResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFriendProfileCardResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetFriendProfileCardResponse} GetFriendProfileCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendProfileCardResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetFriendProfileCardResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.friends_profile_card && message.friends_profile_card.length))
                                message.friends_profile_card = [];
                            message.friends_profile_card.push($root.kritor.friend.ProfileCard.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFriendProfileCardResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetFriendProfileCardResponse} GetFriendProfileCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendProfileCardResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFriendProfileCardResponse message.
             * @function verify
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFriendProfileCardResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.friends_profile_card != null && message.hasOwnProperty("friends_profile_card")) {
                    if (!Array.isArray(message.friends_profile_card))
                        return "friends_profile_card: array expected";
                    for (let i = 0; i < message.friends_profile_card.length; ++i) {
                        let error = $root.kritor.friend.ProfileCard.verify(message.friends_profile_card[i]);
                        if (error)
                            return "friends_profile_card." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetFriendProfileCardResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetFriendProfileCardResponse} GetFriendProfileCardResponse
             */
            GetFriendProfileCardResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetFriendProfileCardResponse)
                    return object;
                let message = new $root.kritor.friend.GetFriendProfileCardResponse();
                if (object.friends_profile_card) {
                    if (!Array.isArray(object.friends_profile_card))
                        throw TypeError(".kritor.friend.GetFriendProfileCardResponse.friends_profile_card: array expected");
                    message.friends_profile_card = [];
                    for (let i = 0; i < object.friends_profile_card.length; ++i) {
                        if (typeof object.friends_profile_card[i] !== "object")
                            throw TypeError(".kritor.friend.GetFriendProfileCardResponse.friends_profile_card: object expected");
                        message.friends_profile_card[i] = $root.kritor.friend.ProfileCard.fromObject(object.friends_profile_card[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetFriendProfileCardResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {kritor.friend.GetFriendProfileCardResponse} message GetFriendProfileCardResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFriendProfileCardResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.friends_profile_card = [];
                if (message.friends_profile_card && message.friends_profile_card.length) {
                    object.friends_profile_card = [];
                    for (let j = 0; j < message.friends_profile_card.length; ++j)
                        object.friends_profile_card[j] = $root.kritor.friend.ProfileCard.toObject(message.friends_profile_card[j], options);
                }
                return object;
            };

            /**
             * Converts this GetFriendProfileCardResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFriendProfileCardResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFriendProfileCardResponse
             * @function getTypeUrl
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFriendProfileCardResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetFriendProfileCardResponse";
            };

            return GetFriendProfileCardResponse;
        })();

        friend.GetStrangerProfileCardRequest = (function() {

            /**
             * Properties of a GetStrangerProfileCardRequest.
             * @memberof kritor.friend
             * @interface IGetStrangerProfileCardRequest
             * @property {Array.<string>|null} [target_uids] GetStrangerProfileCardRequest target_uids
             * @property {Array.<number|Long>|null} [target_uins] GetStrangerProfileCardRequest target_uins
             */

            /**
             * Constructs a new GetStrangerProfileCardRequest.
             * @memberof kritor.friend
             * @classdesc Represents a GetStrangerProfileCardRequest.
             * @implements IGetStrangerProfileCardRequest
             * @constructor
             * @param {kritor.friend.IGetStrangerProfileCardRequest=} [properties] Properties to set
             */
            function GetStrangerProfileCardRequest(properties) {
                this.target_uids = [];
                this.target_uins = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetStrangerProfileCardRequest target_uids.
             * @member {Array.<string>} target_uids
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @instance
             */
            GetStrangerProfileCardRequest.prototype.target_uids = $util.emptyArray;

            /**
             * GetStrangerProfileCardRequest target_uins.
             * @member {Array.<number|Long>} target_uins
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @instance
             */
            GetStrangerProfileCardRequest.prototype.target_uins = $util.emptyArray;

            /**
             * Creates a new GetStrangerProfileCardRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {kritor.friend.IGetStrangerProfileCardRequest=} [properties] Properties to set
             * @returns {kritor.friend.GetStrangerProfileCardRequest} GetStrangerProfileCardRequest instance
             */
            GetStrangerProfileCardRequest.create = function create(properties) {
                return new GetStrangerProfileCardRequest(properties);
            };

            /**
             * Encodes the specified GetStrangerProfileCardRequest message. Does not implicitly {@link kritor.friend.GetStrangerProfileCardRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {kritor.friend.IGetStrangerProfileCardRequest} message GetStrangerProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStrangerProfileCardRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target_uids != null && message.target_uids.length)
                    for (let i = 0; i < message.target_uids.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.target_uids[i]);
                if (message.target_uins != null && message.target_uins.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (let i = 0; i < message.target_uins.length; ++i)
                        writer.uint64(message.target_uins[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified GetStrangerProfileCardRequest message, length delimited. Does not implicitly {@link kritor.friend.GetStrangerProfileCardRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {kritor.friend.IGetStrangerProfileCardRequest} message GetStrangerProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStrangerProfileCardRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetStrangerProfileCardRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetStrangerProfileCardRequest} GetStrangerProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStrangerProfileCardRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetStrangerProfileCardRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.target_uids && message.target_uids.length))
                                message.target_uids = [];
                            message.target_uids.push(reader.string());
                            break;
                        }
                    case 2: {
                            if (!(message.target_uins && message.target_uins.length))
                                message.target_uins = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.target_uins.push(reader.uint64());
                            } else
                                message.target_uins.push(reader.uint64());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetStrangerProfileCardRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetStrangerProfileCardRequest} GetStrangerProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStrangerProfileCardRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetStrangerProfileCardRequest message.
             * @function verify
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetStrangerProfileCardRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.target_uids != null && message.hasOwnProperty("target_uids")) {
                    if (!Array.isArray(message.target_uids))
                        return "target_uids: array expected";
                    for (let i = 0; i < message.target_uids.length; ++i)
                        if (!$util.isString(message.target_uids[i]))
                            return "target_uids: string[] expected";
                }
                if (message.target_uins != null && message.hasOwnProperty("target_uins")) {
                    if (!Array.isArray(message.target_uins))
                        return "target_uins: array expected";
                    for (let i = 0; i < message.target_uins.length; ++i)
                        if (!$util.isInteger(message.target_uins[i]) && !(message.target_uins[i] && $util.isInteger(message.target_uins[i].low) && $util.isInteger(message.target_uins[i].high)))
                            return "target_uins: integer|Long[] expected";
                }
                return null;
            };

            /**
             * Creates a GetStrangerProfileCardRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetStrangerProfileCardRequest} GetStrangerProfileCardRequest
             */
            GetStrangerProfileCardRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetStrangerProfileCardRequest)
                    return object;
                let message = new $root.kritor.friend.GetStrangerProfileCardRequest();
                if (object.target_uids) {
                    if (!Array.isArray(object.target_uids))
                        throw TypeError(".kritor.friend.GetStrangerProfileCardRequest.target_uids: array expected");
                    message.target_uids = [];
                    for (let i = 0; i < object.target_uids.length; ++i)
                        message.target_uids[i] = String(object.target_uids[i]);
                }
                if (object.target_uins) {
                    if (!Array.isArray(object.target_uins))
                        throw TypeError(".kritor.friend.GetStrangerProfileCardRequest.target_uins: array expected");
                    message.target_uins = [];
                    for (let i = 0; i < object.target_uins.length; ++i)
                        if ($util.Long)
                            (message.target_uins[i] = $util.Long.fromValue(object.target_uins[i])).unsigned = true;
                        else if (typeof object.target_uins[i] === "string")
                            message.target_uins[i] = parseInt(object.target_uins[i], 10);
                        else if (typeof object.target_uins[i] === "number")
                            message.target_uins[i] = object.target_uins[i];
                        else if (typeof object.target_uins[i] === "object")
                            message.target_uins[i] = new $util.LongBits(object.target_uins[i].low >>> 0, object.target_uins[i].high >>> 0).toNumber(true);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetStrangerProfileCardRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {kritor.friend.GetStrangerProfileCardRequest} message GetStrangerProfileCardRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetStrangerProfileCardRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.target_uids = [];
                    object.target_uins = [];
                }
                if (message.target_uids && message.target_uids.length) {
                    object.target_uids = [];
                    for (let j = 0; j < message.target_uids.length; ++j)
                        object.target_uids[j] = message.target_uids[j];
                }
                if (message.target_uins && message.target_uins.length) {
                    object.target_uins = [];
                    for (let j = 0; j < message.target_uins.length; ++j)
                        if (typeof message.target_uins[j] === "number")
                            object.target_uins[j] = options.longs === String ? String(message.target_uins[j]) : message.target_uins[j];
                        else
                            object.target_uins[j] = options.longs === String ? $util.Long.prototype.toString.call(message.target_uins[j]) : options.longs === Number ? new $util.LongBits(message.target_uins[j].low >>> 0, message.target_uins[j].high >>> 0).toNumber(true) : message.target_uins[j];
                }
                return object;
            };

            /**
             * Converts this GetStrangerProfileCardRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetStrangerProfileCardRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetStrangerProfileCardRequest
             * @function getTypeUrl
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetStrangerProfileCardRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetStrangerProfileCardRequest";
            };

            return GetStrangerProfileCardRequest;
        })();

        friend.GetStrangerProfileCardResponse = (function() {

            /**
             * Properties of a GetStrangerProfileCardResponse.
             * @memberof kritor.friend
             * @interface IGetStrangerProfileCardResponse
             * @property {Array.<kritor.friend.IProfileCard>|null} [strangers_profile_card] GetStrangerProfileCardResponse strangers_profile_card
             */

            /**
             * Constructs a new GetStrangerProfileCardResponse.
             * @memberof kritor.friend
             * @classdesc Represents a GetStrangerProfileCardResponse.
             * @implements IGetStrangerProfileCardResponse
             * @constructor
             * @param {kritor.friend.IGetStrangerProfileCardResponse=} [properties] Properties to set
             */
            function GetStrangerProfileCardResponse(properties) {
                this.strangers_profile_card = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetStrangerProfileCardResponse strangers_profile_card.
             * @member {Array.<kritor.friend.IProfileCard>} strangers_profile_card
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @instance
             */
            GetStrangerProfileCardResponse.prototype.strangers_profile_card = $util.emptyArray;

            /**
             * Creates a new GetStrangerProfileCardResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {kritor.friend.IGetStrangerProfileCardResponse=} [properties] Properties to set
             * @returns {kritor.friend.GetStrangerProfileCardResponse} GetStrangerProfileCardResponse instance
             */
            GetStrangerProfileCardResponse.create = function create(properties) {
                return new GetStrangerProfileCardResponse(properties);
            };

            /**
             * Encodes the specified GetStrangerProfileCardResponse message. Does not implicitly {@link kritor.friend.GetStrangerProfileCardResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {kritor.friend.IGetStrangerProfileCardResponse} message GetStrangerProfileCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStrangerProfileCardResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.strangers_profile_card != null && message.strangers_profile_card.length)
                    for (let i = 0; i < message.strangers_profile_card.length; ++i)
                        $root.kritor.friend.ProfileCard.encode(message.strangers_profile_card[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetStrangerProfileCardResponse message, length delimited. Does not implicitly {@link kritor.friend.GetStrangerProfileCardResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {kritor.friend.IGetStrangerProfileCardResponse} message GetStrangerProfileCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStrangerProfileCardResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetStrangerProfileCardResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetStrangerProfileCardResponse} GetStrangerProfileCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStrangerProfileCardResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetStrangerProfileCardResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.strangers_profile_card && message.strangers_profile_card.length))
                                message.strangers_profile_card = [];
                            message.strangers_profile_card.push($root.kritor.friend.ProfileCard.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetStrangerProfileCardResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetStrangerProfileCardResponse} GetStrangerProfileCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStrangerProfileCardResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetStrangerProfileCardResponse message.
             * @function verify
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetStrangerProfileCardResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.strangers_profile_card != null && message.hasOwnProperty("strangers_profile_card")) {
                    if (!Array.isArray(message.strangers_profile_card))
                        return "strangers_profile_card: array expected";
                    for (let i = 0; i < message.strangers_profile_card.length; ++i) {
                        let error = $root.kritor.friend.ProfileCard.verify(message.strangers_profile_card[i]);
                        if (error)
                            return "strangers_profile_card." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetStrangerProfileCardResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetStrangerProfileCardResponse} GetStrangerProfileCardResponse
             */
            GetStrangerProfileCardResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetStrangerProfileCardResponse)
                    return object;
                let message = new $root.kritor.friend.GetStrangerProfileCardResponse();
                if (object.strangers_profile_card) {
                    if (!Array.isArray(object.strangers_profile_card))
                        throw TypeError(".kritor.friend.GetStrangerProfileCardResponse.strangers_profile_card: array expected");
                    message.strangers_profile_card = [];
                    for (let i = 0; i < object.strangers_profile_card.length; ++i) {
                        if (typeof object.strangers_profile_card[i] !== "object")
                            throw TypeError(".kritor.friend.GetStrangerProfileCardResponse.strangers_profile_card: object expected");
                        message.strangers_profile_card[i] = $root.kritor.friend.ProfileCard.fromObject(object.strangers_profile_card[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetStrangerProfileCardResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {kritor.friend.GetStrangerProfileCardResponse} message GetStrangerProfileCardResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetStrangerProfileCardResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.strangers_profile_card = [];
                if (message.strangers_profile_card && message.strangers_profile_card.length) {
                    object.strangers_profile_card = [];
                    for (let j = 0; j < message.strangers_profile_card.length; ++j)
                        object.strangers_profile_card[j] = $root.kritor.friend.ProfileCard.toObject(message.strangers_profile_card[j], options);
                }
                return object;
            };

            /**
             * Converts this GetStrangerProfileCardResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetStrangerProfileCardResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetStrangerProfileCardResponse
             * @function getTypeUrl
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetStrangerProfileCardResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetStrangerProfileCardResponse";
            };

            return GetStrangerProfileCardResponse;
        })();

        friend.SetProfileCardRequest = (function() {

            /**
             * Properties of a SetProfileCardRequest.
             * @memberof kritor.friend
             * @interface ISetProfileCardRequest
             * @property {string|null} [nick_name] SetProfileCardRequest nick_name
             * @property {string|null} [company] SetProfileCardRequest company
             * @property {string|null} [email] SetProfileCardRequest email
             * @property {string|null} [college] SetProfileCardRequest college
             * @property {string|null} [personal_note] SetProfileCardRequest personal_note
             * @property {number|null} [birthday] SetProfileCardRequest birthday
             * @property {number|null} [age] SetProfileCardRequest age
             */

            /**
             * Constructs a new SetProfileCardRequest.
             * @memberof kritor.friend
             * @classdesc Represents a SetProfileCardRequest.
             * @implements ISetProfileCardRequest
             * @constructor
             * @param {kritor.friend.ISetProfileCardRequest=} [properties] Properties to set
             */
            function SetProfileCardRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetProfileCardRequest nick_name.
             * @member {string|null|undefined} nick_name
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.nick_name = null;

            /**
             * SetProfileCardRequest company.
             * @member {string|null|undefined} company
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.company = null;

            /**
             * SetProfileCardRequest email.
             * @member {string|null|undefined} email
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.email = null;

            /**
             * SetProfileCardRequest college.
             * @member {string|null|undefined} college
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.college = null;

            /**
             * SetProfileCardRequest personal_note.
             * @member {string|null|undefined} personal_note
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.personal_note = null;

            /**
             * SetProfileCardRequest birthday.
             * @member {number|null|undefined} birthday
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.birthday = null;

            /**
             * SetProfileCardRequest age.
             * @member {number|null|undefined} age
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.age = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SetProfileCardRequest _nick_name.
             * @member {"nick_name"|undefined} _nick_name
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_nick_name", {
                get: $util.oneOfGetter($oneOfFields = ["nick_name"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _company.
             * @member {"company"|undefined} _company
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_company", {
                get: $util.oneOfGetter($oneOfFields = ["company"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _email.
             * @member {"email"|undefined} _email
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_email", {
                get: $util.oneOfGetter($oneOfFields = ["email"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _college.
             * @member {"college"|undefined} _college
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_college", {
                get: $util.oneOfGetter($oneOfFields = ["college"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _personal_note.
             * @member {"personal_note"|undefined} _personal_note
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_personal_note", {
                get: $util.oneOfGetter($oneOfFields = ["personal_note"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _birthday.
             * @member {"birthday"|undefined} _birthday
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_birthday", {
                get: $util.oneOfGetter($oneOfFields = ["birthday"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _age.
             * @member {"age"|undefined} _age
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_age", {
                get: $util.oneOfGetter($oneOfFields = ["age"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SetProfileCardRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {kritor.friend.ISetProfileCardRequest=} [properties] Properties to set
             * @returns {kritor.friend.SetProfileCardRequest} SetProfileCardRequest instance
             */
            SetProfileCardRequest.create = function create(properties) {
                return new SetProfileCardRequest(properties);
            };

            /**
             * Encodes the specified SetProfileCardRequest message. Does not implicitly {@link kritor.friend.SetProfileCardRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {kritor.friend.ISetProfileCardRequest} message SetProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetProfileCardRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nick_name);
                if (message.company != null && Object.hasOwnProperty.call(message, "company"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.company);
                if (message.email != null && Object.hasOwnProperty.call(message, "email"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.email);
                if (message.college != null && Object.hasOwnProperty.call(message, "college"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.college);
                if (message.personal_note != null && Object.hasOwnProperty.call(message, "personal_note"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.personal_note);
                if (message.birthday != null && Object.hasOwnProperty.call(message, "birthday"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.birthday);
                if (message.age != null && Object.hasOwnProperty.call(message, "age"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.age);
                return writer;
            };

            /**
             * Encodes the specified SetProfileCardRequest message, length delimited. Does not implicitly {@link kritor.friend.SetProfileCardRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {kritor.friend.ISetProfileCardRequest} message SetProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetProfileCardRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetProfileCardRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.SetProfileCardRequest} SetProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetProfileCardRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.SetProfileCardRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.nick_name = reader.string();
                            break;
                        }
                    case 2: {
                            message.company = reader.string();
                            break;
                        }
                    case 3: {
                            message.email = reader.string();
                            break;
                        }
                    case 4: {
                            message.college = reader.string();
                            break;
                        }
                    case 5: {
                            message.personal_note = reader.string();
                            break;
                        }
                    case 6: {
                            message.birthday = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.age = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetProfileCardRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.SetProfileCardRequest} SetProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetProfileCardRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetProfileCardRequest message.
             * @function verify
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetProfileCardRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.nick_name != null && message.hasOwnProperty("nick_name")) {
                    properties._nick_name = 1;
                    if (!$util.isString(message.nick_name))
                        return "nick_name: string expected";
                }
                if (message.company != null && message.hasOwnProperty("company")) {
                    properties._company = 1;
                    if (!$util.isString(message.company))
                        return "company: string expected";
                }
                if (message.email != null && message.hasOwnProperty("email")) {
                    properties._email = 1;
                    if (!$util.isString(message.email))
                        return "email: string expected";
                }
                if (message.college != null && message.hasOwnProperty("college")) {
                    properties._college = 1;
                    if (!$util.isString(message.college))
                        return "college: string expected";
                }
                if (message.personal_note != null && message.hasOwnProperty("personal_note")) {
                    properties._personal_note = 1;
                    if (!$util.isString(message.personal_note))
                        return "personal_note: string expected";
                }
                if (message.birthday != null && message.hasOwnProperty("birthday")) {
                    properties._birthday = 1;
                    if (!$util.isInteger(message.birthday))
                        return "birthday: integer expected";
                }
                if (message.age != null && message.hasOwnProperty("age")) {
                    properties._age = 1;
                    if (!$util.isInteger(message.age))
                        return "age: integer expected";
                }
                return null;
            };

            /**
             * Creates a SetProfileCardRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.SetProfileCardRequest} SetProfileCardRequest
             */
            SetProfileCardRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.SetProfileCardRequest)
                    return object;
                let message = new $root.kritor.friend.SetProfileCardRequest();
                if (object.nick_name != null)
                    message.nick_name = String(object.nick_name);
                if (object.company != null)
                    message.company = String(object.company);
                if (object.email != null)
                    message.email = String(object.email);
                if (object.college != null)
                    message.college = String(object.college);
                if (object.personal_note != null)
                    message.personal_note = String(object.personal_note);
                if (object.birthday != null)
                    message.birthday = object.birthday >>> 0;
                if (object.age != null)
                    message.age = object.age >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SetProfileCardRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {kritor.friend.SetProfileCardRequest} message SetProfileCardRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetProfileCardRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.nick_name != null && message.hasOwnProperty("nick_name")) {
                    object.nick_name = message.nick_name;
                    if (options.oneofs)
                        object._nick_name = "nick_name";
                }
                if (message.company != null && message.hasOwnProperty("company")) {
                    object.company = message.company;
                    if (options.oneofs)
                        object._company = "company";
                }
                if (message.email != null && message.hasOwnProperty("email")) {
                    object.email = message.email;
                    if (options.oneofs)
                        object._email = "email";
                }
                if (message.college != null && message.hasOwnProperty("college")) {
                    object.college = message.college;
                    if (options.oneofs)
                        object._college = "college";
                }
                if (message.personal_note != null && message.hasOwnProperty("personal_note")) {
                    object.personal_note = message.personal_note;
                    if (options.oneofs)
                        object._personal_note = "personal_note";
                }
                if (message.birthday != null && message.hasOwnProperty("birthday")) {
                    object.birthday = message.birthday;
                    if (options.oneofs)
                        object._birthday = "birthday";
                }
                if (message.age != null && message.hasOwnProperty("age")) {
                    object.age = message.age;
                    if (options.oneofs)
                        object._age = "age";
                }
                return object;
            };

            /**
             * Converts this SetProfileCardRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetProfileCardRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetProfileCardRequest
             * @function getTypeUrl
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetProfileCardRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.SetProfileCardRequest";
            };

            return SetProfileCardRequest;
        })();

        friend.SetProfileCardResponse = (function() {

            /**
             * Properties of a SetProfileCardResponse.
             * @memberof kritor.friend
             * @interface ISetProfileCardResponse
             */

            /**
             * Constructs a new SetProfileCardResponse.
             * @memberof kritor.friend
             * @classdesc Represents a SetProfileCardResponse.
             * @implements ISetProfileCardResponse
             * @constructor
             * @param {kritor.friend.ISetProfileCardResponse=} [properties] Properties to set
             */
            function SetProfileCardResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetProfileCardResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {kritor.friend.ISetProfileCardResponse=} [properties] Properties to set
             * @returns {kritor.friend.SetProfileCardResponse} SetProfileCardResponse instance
             */
            SetProfileCardResponse.create = function create(properties) {
                return new SetProfileCardResponse(properties);
            };

            /**
             * Encodes the specified SetProfileCardResponse message. Does not implicitly {@link kritor.friend.SetProfileCardResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {kritor.friend.ISetProfileCardResponse} message SetProfileCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetProfileCardResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetProfileCardResponse message, length delimited. Does not implicitly {@link kritor.friend.SetProfileCardResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {kritor.friend.ISetProfileCardResponse} message SetProfileCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetProfileCardResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetProfileCardResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.SetProfileCardResponse} SetProfileCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetProfileCardResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.SetProfileCardResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetProfileCardResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.SetProfileCardResponse} SetProfileCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetProfileCardResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetProfileCardResponse message.
             * @function verify
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetProfileCardResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetProfileCardResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.SetProfileCardResponse} SetProfileCardResponse
             */
            SetProfileCardResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.SetProfileCardResponse)
                    return object;
                return new $root.kritor.friend.SetProfileCardResponse();
            };

            /**
             * Creates a plain object from a SetProfileCardResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {kritor.friend.SetProfileCardResponse} message SetProfileCardResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetProfileCardResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetProfileCardResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.SetProfileCardResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetProfileCardResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetProfileCardResponse
             * @function getTypeUrl
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetProfileCardResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.SetProfileCardResponse";
            };

            return SetProfileCardResponse;
        })();

        friend.IsBlackListUserRequest = (function() {

            /**
             * Properties of an IsBlackListUserRequest.
             * @memberof kritor.friend
             * @interface IIsBlackListUserRequest
             * @property {string|null} [target_uid] IsBlackListUserRequest target_uid
             * @property {number|Long|null} [target_uin] IsBlackListUserRequest target_uin
             */

            /**
             * Constructs a new IsBlackListUserRequest.
             * @memberof kritor.friend
             * @classdesc Represents an IsBlackListUserRequest.
             * @implements IIsBlackListUserRequest
             * @constructor
             * @param {kritor.friend.IIsBlackListUserRequest=} [properties] Properties to set
             */
            function IsBlackListUserRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IsBlackListUserRequest target_uid.
             * @member {string|null|undefined} target_uid
             * @memberof kritor.friend.IsBlackListUserRequest
             * @instance
             */
            IsBlackListUserRequest.prototype.target_uid = null;

            /**
             * IsBlackListUserRequest target_uin.
             * @member {number|Long|null|undefined} target_uin
             * @memberof kritor.friend.IsBlackListUserRequest
             * @instance
             */
            IsBlackListUserRequest.prototype.target_uin = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * IsBlackListUserRequest target.
             * @member {"target_uid"|"target_uin"|undefined} target
             * @memberof kritor.friend.IsBlackListUserRequest
             * @instance
             */
            Object.defineProperty(IsBlackListUserRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["target_uid", "target_uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new IsBlackListUserRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {kritor.friend.IIsBlackListUserRequest=} [properties] Properties to set
             * @returns {kritor.friend.IsBlackListUserRequest} IsBlackListUserRequest instance
             */
            IsBlackListUserRequest.create = function create(properties) {
                return new IsBlackListUserRequest(properties);
            };

            /**
             * Encodes the specified IsBlackListUserRequest message. Does not implicitly {@link kritor.friend.IsBlackListUserRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {kritor.friend.IIsBlackListUserRequest} message IsBlackListUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IsBlackListUserRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.target_uin);
                return writer;
            };

            /**
             * Encodes the specified IsBlackListUserRequest message, length delimited. Does not implicitly {@link kritor.friend.IsBlackListUserRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {kritor.friend.IIsBlackListUserRequest} message IsBlackListUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IsBlackListUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IsBlackListUserRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.IsBlackListUserRequest} IsBlackListUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IsBlackListUserRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.IsBlackListUserRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IsBlackListUserRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.IsBlackListUserRequest} IsBlackListUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IsBlackListUserRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IsBlackListUserRequest message.
             * @function verify
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IsBlackListUserRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    properties.target = 1;
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                }
                return null;
            };

            /**
             * Creates an IsBlackListUserRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.IsBlackListUserRequest} IsBlackListUserRequest
             */
            IsBlackListUserRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.IsBlackListUserRequest)
                    return object;
                let message = new $root.kritor.friend.IsBlackListUserRequest();
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an IsBlackListUserRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {kritor.friend.IsBlackListUserRequest} message IsBlackListUserRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IsBlackListUserRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    object.target_uid = message.target_uid;
                    if (options.oneofs)
                        object.target = "target_uid";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                    if (options.oneofs)
                        object.target = "target_uin";
                }
                return object;
            };

            /**
             * Converts this IsBlackListUserRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.IsBlackListUserRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IsBlackListUserRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for IsBlackListUserRequest
             * @function getTypeUrl
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            IsBlackListUserRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.IsBlackListUserRequest";
            };

            return IsBlackListUserRequest;
        })();

        friend.IsBlackListUserResponse = (function() {

            /**
             * Properties of an IsBlackListUserResponse.
             * @memberof kritor.friend
             * @interface IIsBlackListUserResponse
             * @property {boolean|null} [is_black_list_user] IsBlackListUserResponse is_black_list_user
             */

            /**
             * Constructs a new IsBlackListUserResponse.
             * @memberof kritor.friend
             * @classdesc Represents an IsBlackListUserResponse.
             * @implements IIsBlackListUserResponse
             * @constructor
             * @param {kritor.friend.IIsBlackListUserResponse=} [properties] Properties to set
             */
            function IsBlackListUserResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IsBlackListUserResponse is_black_list_user.
             * @member {boolean} is_black_list_user
             * @memberof kritor.friend.IsBlackListUserResponse
             * @instance
             */
            IsBlackListUserResponse.prototype.is_black_list_user = false;

            /**
             * Creates a new IsBlackListUserResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {kritor.friend.IIsBlackListUserResponse=} [properties] Properties to set
             * @returns {kritor.friend.IsBlackListUserResponse} IsBlackListUserResponse instance
             */
            IsBlackListUserResponse.create = function create(properties) {
                return new IsBlackListUserResponse(properties);
            };

            /**
             * Encodes the specified IsBlackListUserResponse message. Does not implicitly {@link kritor.friend.IsBlackListUserResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {kritor.friend.IIsBlackListUserResponse} message IsBlackListUserResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IsBlackListUserResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.is_black_list_user != null && Object.hasOwnProperty.call(message, "is_black_list_user"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.is_black_list_user);
                return writer;
            };

            /**
             * Encodes the specified IsBlackListUserResponse message, length delimited. Does not implicitly {@link kritor.friend.IsBlackListUserResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {kritor.friend.IIsBlackListUserResponse} message IsBlackListUserResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IsBlackListUserResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IsBlackListUserResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.IsBlackListUserResponse} IsBlackListUserResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IsBlackListUserResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.IsBlackListUserResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.is_black_list_user = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IsBlackListUserResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.IsBlackListUserResponse} IsBlackListUserResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IsBlackListUserResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IsBlackListUserResponse message.
             * @function verify
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IsBlackListUserResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.is_black_list_user != null && message.hasOwnProperty("is_black_list_user"))
                    if (typeof message.is_black_list_user !== "boolean")
                        return "is_black_list_user: boolean expected";
                return null;
            };

            /**
             * Creates an IsBlackListUserResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.IsBlackListUserResponse} IsBlackListUserResponse
             */
            IsBlackListUserResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.IsBlackListUserResponse)
                    return object;
                let message = new $root.kritor.friend.IsBlackListUserResponse();
                if (object.is_black_list_user != null)
                    message.is_black_list_user = Boolean(object.is_black_list_user);
                return message;
            };

            /**
             * Creates a plain object from an IsBlackListUserResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {kritor.friend.IsBlackListUserResponse} message IsBlackListUserResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IsBlackListUserResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.is_black_list_user = false;
                if (message.is_black_list_user != null && message.hasOwnProperty("is_black_list_user"))
                    object.is_black_list_user = message.is_black_list_user;
                return object;
            };

            /**
             * Converts this IsBlackListUserResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.IsBlackListUserResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IsBlackListUserResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for IsBlackListUserResponse
             * @function getTypeUrl
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            IsBlackListUserResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.IsBlackListUserResponse";
            };

            return IsBlackListUserResponse;
        })();

        friend.VoteUserRequest = (function() {

            /**
             * Properties of a VoteUserRequest.
             * @memberof kritor.friend
             * @interface IVoteUserRequest
             * @property {string|null} [target_uid] VoteUserRequest target_uid
             * @property {number|Long|null} [target_uin] VoteUserRequest target_uin
             * @property {number|null} [vote_count] VoteUserRequest vote_count
             */

            /**
             * Constructs a new VoteUserRequest.
             * @memberof kritor.friend
             * @classdesc Represents a VoteUserRequest.
             * @implements IVoteUserRequest
             * @constructor
             * @param {kritor.friend.IVoteUserRequest=} [properties] Properties to set
             */
            function VoteUserRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VoteUserRequest target_uid.
             * @member {string|null|undefined} target_uid
             * @memberof kritor.friend.VoteUserRequest
             * @instance
             */
            VoteUserRequest.prototype.target_uid = null;

            /**
             * VoteUserRequest target_uin.
             * @member {number|Long|null|undefined} target_uin
             * @memberof kritor.friend.VoteUserRequest
             * @instance
             */
            VoteUserRequest.prototype.target_uin = null;

            /**
             * VoteUserRequest vote_count.
             * @member {number} vote_count
             * @memberof kritor.friend.VoteUserRequest
             * @instance
             */
            VoteUserRequest.prototype.vote_count = 0;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * VoteUserRequest target.
             * @member {"target_uid"|"target_uin"|undefined} target
             * @memberof kritor.friend.VoteUserRequest
             * @instance
             */
            Object.defineProperty(VoteUserRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["target_uid", "target_uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new VoteUserRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {kritor.friend.IVoteUserRequest=} [properties] Properties to set
             * @returns {kritor.friend.VoteUserRequest} VoteUserRequest instance
             */
            VoteUserRequest.create = function create(properties) {
                return new VoteUserRequest(properties);
            };

            /**
             * Encodes the specified VoteUserRequest message. Does not implicitly {@link kritor.friend.VoteUserRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {kritor.friend.IVoteUserRequest} message VoteUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoteUserRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.target_uin);
                if (message.vote_count != null && Object.hasOwnProperty.call(message, "vote_count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.vote_count);
                return writer;
            };

            /**
             * Encodes the specified VoteUserRequest message, length delimited. Does not implicitly {@link kritor.friend.VoteUserRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {kritor.friend.IVoteUserRequest} message VoteUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoteUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VoteUserRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.VoteUserRequest} VoteUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoteUserRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.VoteUserRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.vote_count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VoteUserRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.VoteUserRequest} VoteUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoteUserRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VoteUserRequest message.
             * @function verify
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VoteUserRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    properties.target = 1;
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                }
                if (message.vote_count != null && message.hasOwnProperty("vote_count"))
                    if (!$util.isInteger(message.vote_count))
                        return "vote_count: integer expected";
                return null;
            };

            /**
             * Creates a VoteUserRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.VoteUserRequest} VoteUserRequest
             */
            VoteUserRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.VoteUserRequest)
                    return object;
                let message = new $root.kritor.friend.VoteUserRequest();
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                if (object.vote_count != null)
                    message.vote_count = object.vote_count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a VoteUserRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {kritor.friend.VoteUserRequest} message VoteUserRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VoteUserRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.vote_count = 0;
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    object.target_uid = message.target_uid;
                    if (options.oneofs)
                        object.target = "target_uid";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                    if (options.oneofs)
                        object.target = "target_uin";
                }
                if (message.vote_count != null && message.hasOwnProperty("vote_count"))
                    object.vote_count = message.vote_count;
                return object;
            };

            /**
             * Converts this VoteUserRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.VoteUserRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VoteUserRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VoteUserRequest
             * @function getTypeUrl
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VoteUserRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.VoteUserRequest";
            };

            return VoteUserRequest;
        })();

        friend.VoteUserResponse = (function() {

            /**
             * Properties of a VoteUserResponse.
             * @memberof kritor.friend
             * @interface IVoteUserResponse
             */

            /**
             * Constructs a new VoteUserResponse.
             * @memberof kritor.friend
             * @classdesc Represents a VoteUserResponse.
             * @implements IVoteUserResponse
             * @constructor
             * @param {kritor.friend.IVoteUserResponse=} [properties] Properties to set
             */
            function VoteUserResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new VoteUserResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {kritor.friend.IVoteUserResponse=} [properties] Properties to set
             * @returns {kritor.friend.VoteUserResponse} VoteUserResponse instance
             */
            VoteUserResponse.create = function create(properties) {
                return new VoteUserResponse(properties);
            };

            /**
             * Encodes the specified VoteUserResponse message. Does not implicitly {@link kritor.friend.VoteUserResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {kritor.friend.IVoteUserResponse} message VoteUserResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoteUserResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified VoteUserResponse message, length delimited. Does not implicitly {@link kritor.friend.VoteUserResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {kritor.friend.IVoteUserResponse} message VoteUserResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoteUserResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VoteUserResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.VoteUserResponse} VoteUserResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoteUserResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.VoteUserResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VoteUserResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.VoteUserResponse} VoteUserResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoteUserResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VoteUserResponse message.
             * @function verify
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VoteUserResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a VoteUserResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.VoteUserResponse} VoteUserResponse
             */
            VoteUserResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.VoteUserResponse)
                    return object;
                return new $root.kritor.friend.VoteUserResponse();
            };

            /**
             * Creates a plain object from a VoteUserResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {kritor.friend.VoteUserResponse} message VoteUserResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VoteUserResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this VoteUserResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.VoteUserResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VoteUserResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VoteUserResponse
             * @function getTypeUrl
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VoteUserResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.VoteUserResponse";
            };

            return VoteUserResponse;
        })();

        friend.GetUidByUinRequest = (function() {

            /**
             * Properties of a GetUidByUinRequest.
             * @memberof kritor.friend
             * @interface IGetUidByUinRequest
             * @property {Array.<number|Long>|null} [target_uins] GetUidByUinRequest target_uins
             */

            /**
             * Constructs a new GetUidByUinRequest.
             * @memberof kritor.friend
             * @classdesc Represents a GetUidByUinRequest.
             * @implements IGetUidByUinRequest
             * @constructor
             * @param {kritor.friend.IGetUidByUinRequest=} [properties] Properties to set
             */
            function GetUidByUinRequest(properties) {
                this.target_uins = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUidByUinRequest target_uins.
             * @member {Array.<number|Long>} target_uins
             * @memberof kritor.friend.GetUidByUinRequest
             * @instance
             */
            GetUidByUinRequest.prototype.target_uins = $util.emptyArray;

            /**
             * Creates a new GetUidByUinRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {kritor.friend.IGetUidByUinRequest=} [properties] Properties to set
             * @returns {kritor.friend.GetUidByUinRequest} GetUidByUinRequest instance
             */
            GetUidByUinRequest.create = function create(properties) {
                return new GetUidByUinRequest(properties);
            };

            /**
             * Encodes the specified GetUidByUinRequest message. Does not implicitly {@link kritor.friend.GetUidByUinRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {kritor.friend.IGetUidByUinRequest} message GetUidByUinRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUidByUinRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target_uins != null && message.target_uins.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (let i = 0; i < message.target_uins.length; ++i)
                        writer.uint64(message.target_uins[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified GetUidByUinRequest message, length delimited. Does not implicitly {@link kritor.friend.GetUidByUinRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {kritor.friend.IGetUidByUinRequest} message GetUidByUinRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUidByUinRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUidByUinRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetUidByUinRequest} GetUidByUinRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUidByUinRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetUidByUinRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.target_uins && message.target_uins.length))
                                message.target_uins = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.target_uins.push(reader.uint64());
                            } else
                                message.target_uins.push(reader.uint64());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUidByUinRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetUidByUinRequest} GetUidByUinRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUidByUinRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUidByUinRequest message.
             * @function verify
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUidByUinRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.target_uins != null && message.hasOwnProperty("target_uins")) {
                    if (!Array.isArray(message.target_uins))
                        return "target_uins: array expected";
                    for (let i = 0; i < message.target_uins.length; ++i)
                        if (!$util.isInteger(message.target_uins[i]) && !(message.target_uins[i] && $util.isInteger(message.target_uins[i].low) && $util.isInteger(message.target_uins[i].high)))
                            return "target_uins: integer|Long[] expected";
                }
                return null;
            };

            /**
             * Creates a GetUidByUinRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetUidByUinRequest} GetUidByUinRequest
             */
            GetUidByUinRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetUidByUinRequest)
                    return object;
                let message = new $root.kritor.friend.GetUidByUinRequest();
                if (object.target_uins) {
                    if (!Array.isArray(object.target_uins))
                        throw TypeError(".kritor.friend.GetUidByUinRequest.target_uins: array expected");
                    message.target_uins = [];
                    for (let i = 0; i < object.target_uins.length; ++i)
                        if ($util.Long)
                            (message.target_uins[i] = $util.Long.fromValue(object.target_uins[i])).unsigned = true;
                        else if (typeof object.target_uins[i] === "string")
                            message.target_uins[i] = parseInt(object.target_uins[i], 10);
                        else if (typeof object.target_uins[i] === "number")
                            message.target_uins[i] = object.target_uins[i];
                        else if (typeof object.target_uins[i] === "object")
                            message.target_uins[i] = new $util.LongBits(object.target_uins[i].low >>> 0, object.target_uins[i].high >>> 0).toNumber(true);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetUidByUinRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {kritor.friend.GetUidByUinRequest} message GetUidByUinRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUidByUinRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.target_uins = [];
                if (message.target_uins && message.target_uins.length) {
                    object.target_uins = [];
                    for (let j = 0; j < message.target_uins.length; ++j)
                        if (typeof message.target_uins[j] === "number")
                            object.target_uins[j] = options.longs === String ? String(message.target_uins[j]) : message.target_uins[j];
                        else
                            object.target_uins[j] = options.longs === String ? $util.Long.prototype.toString.call(message.target_uins[j]) : options.longs === Number ? new $util.LongBits(message.target_uins[j].low >>> 0, message.target_uins[j].high >>> 0).toNumber(true) : message.target_uins[j];
                }
                return object;
            };

            /**
             * Converts this GetUidByUinRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetUidByUinRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUidByUinRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUidByUinRequest
             * @function getTypeUrl
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUidByUinRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetUidByUinRequest";
            };

            return GetUidByUinRequest;
        })();

        friend.GetUidByUinResponse = (function() {

            /**
             * Properties of a GetUidByUinResponse.
             * @memberof kritor.friend
             * @interface IGetUidByUinResponse
             * @property {Object.<string,string>|null} [uid_map] GetUidByUinResponse uid_map
             */

            /**
             * Constructs a new GetUidByUinResponse.
             * @memberof kritor.friend
             * @classdesc Represents a GetUidByUinResponse.
             * @implements IGetUidByUinResponse
             * @constructor
             * @param {kritor.friend.IGetUidByUinResponse=} [properties] Properties to set
             */
            function GetUidByUinResponse(properties) {
                this.uid_map = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUidByUinResponse uid_map.
             * @member {Object.<string,string>} uid_map
             * @memberof kritor.friend.GetUidByUinResponse
             * @instance
             */
            GetUidByUinResponse.prototype.uid_map = $util.emptyObject;

            /**
             * Creates a new GetUidByUinResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {kritor.friend.IGetUidByUinResponse=} [properties] Properties to set
             * @returns {kritor.friend.GetUidByUinResponse} GetUidByUinResponse instance
             */
            GetUidByUinResponse.create = function create(properties) {
                return new GetUidByUinResponse(properties);
            };

            /**
             * Encodes the specified GetUidByUinResponse message. Does not implicitly {@link kritor.friend.GetUidByUinResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {kritor.friend.IGetUidByUinResponse} message GetUidByUinResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUidByUinResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid_map != null && Object.hasOwnProperty.call(message, "uid_map"))
                    for (let keys = Object.keys(message.uid_map), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.uid_map[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetUidByUinResponse message, length delimited. Does not implicitly {@link kritor.friend.GetUidByUinResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {kritor.friend.IGetUidByUinResponse} message GetUidByUinResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUidByUinResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUidByUinResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetUidByUinResponse} GetUidByUinResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUidByUinResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetUidByUinResponse(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (message.uid_map === $util.emptyObject)
                                message.uid_map = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.uint64();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.uid_map[typeof key === "object" ? $util.longToHash(key) : key] = value;
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUidByUinResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetUidByUinResponse} GetUidByUinResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUidByUinResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUidByUinResponse message.
             * @function verify
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUidByUinResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uid_map != null && message.hasOwnProperty("uid_map")) {
                    if (!$util.isObject(message.uid_map))
                        return "uid_map: object expected";
                    let key = Object.keys(message.uid_map);
                    for (let i = 0; i < key.length; ++i) {
                        if (!$util.key64Re.test(key[i]))
                            return "uid_map: integer|Long key{k:uint64} expected";
                        if (!$util.isString(message.uid_map[key[i]]))
                            return "uid_map: string{k:uint64} expected";
                    }
                }
                return null;
            };

            /**
             * Creates a GetUidByUinResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetUidByUinResponse} GetUidByUinResponse
             */
            GetUidByUinResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetUidByUinResponse)
                    return object;
                let message = new $root.kritor.friend.GetUidByUinResponse();
                if (object.uid_map) {
                    if (typeof object.uid_map !== "object")
                        throw TypeError(".kritor.friend.GetUidByUinResponse.uid_map: object expected");
                    message.uid_map = {};
                    for (let keys = Object.keys(object.uid_map), i = 0; i < keys.length; ++i)
                        message.uid_map[keys[i]] = String(object.uid_map[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetUidByUinResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {kritor.friend.GetUidByUinResponse} message GetUidByUinResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUidByUinResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.uid_map = {};
                let keys2;
                if (message.uid_map && (keys2 = Object.keys(message.uid_map)).length) {
                    object.uid_map = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.uid_map[keys2[j]] = message.uid_map[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this GetUidByUinResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetUidByUinResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUidByUinResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUidByUinResponse
             * @function getTypeUrl
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUidByUinResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetUidByUinResponse";
            };

            return GetUidByUinResponse;
        })();

        friend.GetUinByUidRequest = (function() {

            /**
             * Properties of a GetUinByUidRequest.
             * @memberof kritor.friend
             * @interface IGetUinByUidRequest
             * @property {Array.<string>|null} [target_uids] GetUinByUidRequest target_uids
             */

            /**
             * Constructs a new GetUinByUidRequest.
             * @memberof kritor.friend
             * @classdesc Represents a GetUinByUidRequest.
             * @implements IGetUinByUidRequest
             * @constructor
             * @param {kritor.friend.IGetUinByUidRequest=} [properties] Properties to set
             */
            function GetUinByUidRequest(properties) {
                this.target_uids = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUinByUidRequest target_uids.
             * @member {Array.<string>} target_uids
             * @memberof kritor.friend.GetUinByUidRequest
             * @instance
             */
            GetUinByUidRequest.prototype.target_uids = $util.emptyArray;

            /**
             * Creates a new GetUinByUidRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {kritor.friend.IGetUinByUidRequest=} [properties] Properties to set
             * @returns {kritor.friend.GetUinByUidRequest} GetUinByUidRequest instance
             */
            GetUinByUidRequest.create = function create(properties) {
                return new GetUinByUidRequest(properties);
            };

            /**
             * Encodes the specified GetUinByUidRequest message. Does not implicitly {@link kritor.friend.GetUinByUidRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {kritor.friend.IGetUinByUidRequest} message GetUinByUidRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUinByUidRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target_uids != null && message.target_uids.length)
                    for (let i = 0; i < message.target_uids.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.target_uids[i]);
                return writer;
            };

            /**
             * Encodes the specified GetUinByUidRequest message, length delimited. Does not implicitly {@link kritor.friend.GetUinByUidRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {kritor.friend.IGetUinByUidRequest} message GetUinByUidRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUinByUidRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUinByUidRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetUinByUidRequest} GetUinByUidRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUinByUidRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetUinByUidRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.target_uids && message.target_uids.length))
                                message.target_uids = [];
                            message.target_uids.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUinByUidRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetUinByUidRequest} GetUinByUidRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUinByUidRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUinByUidRequest message.
             * @function verify
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUinByUidRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.target_uids != null && message.hasOwnProperty("target_uids")) {
                    if (!Array.isArray(message.target_uids))
                        return "target_uids: array expected";
                    for (let i = 0; i < message.target_uids.length; ++i)
                        if (!$util.isString(message.target_uids[i]))
                            return "target_uids: string[] expected";
                }
                return null;
            };

            /**
             * Creates a GetUinByUidRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetUinByUidRequest} GetUinByUidRequest
             */
            GetUinByUidRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetUinByUidRequest)
                    return object;
                let message = new $root.kritor.friend.GetUinByUidRequest();
                if (object.target_uids) {
                    if (!Array.isArray(object.target_uids))
                        throw TypeError(".kritor.friend.GetUinByUidRequest.target_uids: array expected");
                    message.target_uids = [];
                    for (let i = 0; i < object.target_uids.length; ++i)
                        message.target_uids[i] = String(object.target_uids[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetUinByUidRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {kritor.friend.GetUinByUidRequest} message GetUinByUidRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUinByUidRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.target_uids = [];
                if (message.target_uids && message.target_uids.length) {
                    object.target_uids = [];
                    for (let j = 0; j < message.target_uids.length; ++j)
                        object.target_uids[j] = message.target_uids[j];
                }
                return object;
            };

            /**
             * Converts this GetUinByUidRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetUinByUidRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUinByUidRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUinByUidRequest
             * @function getTypeUrl
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUinByUidRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetUinByUidRequest";
            };

            return GetUinByUidRequest;
        })();

        friend.GetUinByUidResponse = (function() {

            /**
             * Properties of a GetUinByUidResponse.
             * @memberof kritor.friend
             * @interface IGetUinByUidResponse
             * @property {Object.<string,number|Long>|null} [uin_map] GetUinByUidResponse uin_map
             */

            /**
             * Constructs a new GetUinByUidResponse.
             * @memberof kritor.friend
             * @classdesc Represents a GetUinByUidResponse.
             * @implements IGetUinByUidResponse
             * @constructor
             * @param {kritor.friend.IGetUinByUidResponse=} [properties] Properties to set
             */
            function GetUinByUidResponse(properties) {
                this.uin_map = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUinByUidResponse uin_map.
             * @member {Object.<string,number|Long>} uin_map
             * @memberof kritor.friend.GetUinByUidResponse
             * @instance
             */
            GetUinByUidResponse.prototype.uin_map = $util.emptyObject;

            /**
             * Creates a new GetUinByUidResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {kritor.friend.IGetUinByUidResponse=} [properties] Properties to set
             * @returns {kritor.friend.GetUinByUidResponse} GetUinByUidResponse instance
             */
            GetUinByUidResponse.create = function create(properties) {
                return new GetUinByUidResponse(properties);
            };

            /**
             * Encodes the specified GetUinByUidResponse message. Does not implicitly {@link kritor.friend.GetUinByUidResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {kritor.friend.IGetUinByUidResponse} message GetUinByUidResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUinByUidResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uin_map != null && Object.hasOwnProperty.call(message, "uin_map"))
                    for (let keys = Object.keys(message.uin_map), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint64(message.uin_map[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetUinByUidResponse message, length delimited. Does not implicitly {@link kritor.friend.GetUinByUidResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {kritor.friend.IGetUinByUidResponse} message GetUinByUidResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUinByUidResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUinByUidResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetUinByUidResponse} GetUinByUidResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUinByUidResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetUinByUidResponse(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (message.uin_map === $util.emptyObject)
                                message.uin_map = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = 0;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.uint64();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.uin_map[key] = value;
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUinByUidResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetUinByUidResponse} GetUinByUidResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUinByUidResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUinByUidResponse message.
             * @function verify
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUinByUidResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uin_map != null && message.hasOwnProperty("uin_map")) {
                    if (!$util.isObject(message.uin_map))
                        return "uin_map: object expected";
                    let key = Object.keys(message.uin_map);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isInteger(message.uin_map[key[i]]) && !(message.uin_map[key[i]] && $util.isInteger(message.uin_map[key[i]].low) && $util.isInteger(message.uin_map[key[i]].high)))
                            return "uin_map: integer|Long{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a GetUinByUidResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetUinByUidResponse} GetUinByUidResponse
             */
            GetUinByUidResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetUinByUidResponse)
                    return object;
                let message = new $root.kritor.friend.GetUinByUidResponse();
                if (object.uin_map) {
                    if (typeof object.uin_map !== "object")
                        throw TypeError(".kritor.friend.GetUinByUidResponse.uin_map: object expected");
                    message.uin_map = {};
                    for (let keys = Object.keys(object.uin_map), i = 0; i < keys.length; ++i)
                        if ($util.Long)
                            (message.uin_map[keys[i]] = $util.Long.fromValue(object.uin_map[keys[i]])).unsigned = true;
                        else if (typeof object.uin_map[keys[i]] === "string")
                            message.uin_map[keys[i]] = parseInt(object.uin_map[keys[i]], 10);
                        else if (typeof object.uin_map[keys[i]] === "number")
                            message.uin_map[keys[i]] = object.uin_map[keys[i]];
                        else if (typeof object.uin_map[keys[i]] === "object")
                            message.uin_map[keys[i]] = new $util.LongBits(object.uin_map[keys[i]].low >>> 0, object.uin_map[keys[i]].high >>> 0).toNumber(true);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetUinByUidResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {kritor.friend.GetUinByUidResponse} message GetUinByUidResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUinByUidResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.uin_map = {};
                let keys2;
                if (message.uin_map && (keys2 = Object.keys(message.uin_map)).length) {
                    object.uin_map = {};
                    for (let j = 0; j < keys2.length; ++j)
                        if (typeof message.uin_map[keys2[j]] === "number")
                            object.uin_map[keys2[j]] = options.longs === String ? String(message.uin_map[keys2[j]]) : message.uin_map[keys2[j]];
                        else
                            object.uin_map[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.uin_map[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.uin_map[keys2[j]].low >>> 0, message.uin_map[keys2[j]].high >>> 0).toNumber(true) : message.uin_map[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this GetUinByUidResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetUinByUidResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUinByUidResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUinByUidResponse
             * @function getTypeUrl
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUinByUidResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetUinByUidResponse";
            };

            return GetUinByUidResponse;
        })();

        return friend;
    })();

    kritor.group = (function() {

        /**
         * Namespace group.
         * @memberof kritor
         * @namespace
         */
        const group = {};

        group.GroupService = (function() {

            /**
             * Constructs a new GroupService service.
             * @memberof kritor.group
             * @classdesc Represents a GroupService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function GroupService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (GroupService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = GroupService;

            /**
             * Creates new GroupService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.group.GroupService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {GroupService} RPC service. Useful where requests and/or responses are streamed.
             */
            GroupService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.group.GroupService#banMember}.
             * @memberof kritor.group.GroupService
             * @typedef BanMemberCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.BanMemberResponse} [response] BanMemberResponse
             */

            /**
             * Calls BanMember.
             * @function banMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IBanMemberRequest} request BanMemberRequest message or plain object
             * @param {kritor.group.GroupService.BanMemberCallback} callback Node-style callback called with the error, if any, and BanMemberResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.banMember = function banMember(request, callback) {
                return this.rpcCall(banMember, $root.kritor.group.BanMemberRequest, $root.kritor.group.BanMemberResponse, request, callback);
            }, "name", { value: "BanMember" });

            /**
             * Calls BanMember.
             * @function banMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IBanMemberRequest} request BanMemberRequest message or plain object
             * @returns {Promise<kritor.group.BanMemberResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#pokeMember}.
             * @memberof kritor.group.GroupService
             * @typedef PokeMemberCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.PokeMemberResponse} [response] PokeMemberResponse
             */

            /**
             * Calls PokeMember.
             * @function pokeMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IPokeMemberRequest} request PokeMemberRequest message or plain object
             * @param {kritor.group.GroupService.PokeMemberCallback} callback Node-style callback called with the error, if any, and PokeMemberResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.pokeMember = function pokeMember(request, callback) {
                return this.rpcCall(pokeMember, $root.kritor.group.PokeMemberRequest, $root.kritor.group.PokeMemberResponse, request, callback);
            }, "name", { value: "PokeMember" });

            /**
             * Calls PokeMember.
             * @function pokeMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IPokeMemberRequest} request PokeMemberRequest message or plain object
             * @returns {Promise<kritor.group.PokeMemberResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#kickMember}.
             * @memberof kritor.group.GroupService
             * @typedef KickMemberCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.KickMemberResponse} [response] KickMemberResponse
             */

            /**
             * Calls KickMember.
             * @function kickMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IKickMemberRequest} request KickMemberRequest message or plain object
             * @param {kritor.group.GroupService.KickMemberCallback} callback Node-style callback called with the error, if any, and KickMemberResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.kickMember = function kickMember(request, callback) {
                return this.rpcCall(kickMember, $root.kritor.group.KickMemberRequest, $root.kritor.group.KickMemberResponse, request, callback);
            }, "name", { value: "KickMember" });

            /**
             * Calls KickMember.
             * @function kickMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IKickMemberRequest} request KickMemberRequest message or plain object
             * @returns {Promise<kritor.group.KickMemberResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#leaveGroup}.
             * @memberof kritor.group.GroupService
             * @typedef LeaveGroupCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.LeaveGroupResponse} [response] LeaveGroupResponse
             */

            /**
             * Calls LeaveGroup.
             * @function leaveGroup
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ILeaveGroupRequest} request LeaveGroupRequest message or plain object
             * @param {kritor.group.GroupService.LeaveGroupCallback} callback Node-style callback called with the error, if any, and LeaveGroupResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.leaveGroup = function leaveGroup(request, callback) {
                return this.rpcCall(leaveGroup, $root.kritor.group.LeaveGroupRequest, $root.kritor.group.LeaveGroupResponse, request, callback);
            }, "name", { value: "LeaveGroup" });

            /**
             * Calls LeaveGroup.
             * @function leaveGroup
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ILeaveGroupRequest} request LeaveGroupRequest message or plain object
             * @returns {Promise<kritor.group.LeaveGroupResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#modifyMemberCard}.
             * @memberof kritor.group.GroupService
             * @typedef ModifyMemberCardCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.ModifyMemberCardResponse} [response] ModifyMemberCardResponse
             */

            /**
             * Calls ModifyMemberCard.
             * @function modifyMemberCard
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyMemberCardRequest} request ModifyMemberCardRequest message or plain object
             * @param {kritor.group.GroupService.ModifyMemberCardCallback} callback Node-style callback called with the error, if any, and ModifyMemberCardResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.modifyMemberCard = function modifyMemberCard(request, callback) {
                return this.rpcCall(modifyMemberCard, $root.kritor.group.ModifyMemberCardRequest, $root.kritor.group.ModifyMemberCardResponse, request, callback);
            }, "name", { value: "ModifyMemberCard" });

            /**
             * Calls ModifyMemberCard.
             * @function modifyMemberCard
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyMemberCardRequest} request ModifyMemberCardRequest message or plain object
             * @returns {Promise<kritor.group.ModifyMemberCardResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#modifyGroupName}.
             * @memberof kritor.group.GroupService
             * @typedef ModifyGroupNameCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.ModifyGroupNameResponse} [response] ModifyGroupNameResponse
             */

            /**
             * Calls ModifyGroupName.
             * @function modifyGroupName
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyGroupNameRequest} request ModifyGroupNameRequest message or plain object
             * @param {kritor.group.GroupService.ModifyGroupNameCallback} callback Node-style callback called with the error, if any, and ModifyGroupNameResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.modifyGroupName = function modifyGroupName(request, callback) {
                return this.rpcCall(modifyGroupName, $root.kritor.group.ModifyGroupNameRequest, $root.kritor.group.ModifyGroupNameResponse, request, callback);
            }, "name", { value: "ModifyGroupName" });

            /**
             * Calls ModifyGroupName.
             * @function modifyGroupName
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyGroupNameRequest} request ModifyGroupNameRequest message or plain object
             * @returns {Promise<kritor.group.ModifyGroupNameResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#modifyGroupRemark}.
             * @memberof kritor.group.GroupService
             * @typedef ModifyGroupRemarkCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.ModifyGroupRemarkResponse} [response] ModifyGroupRemarkResponse
             */

            /**
             * Calls ModifyGroupRemark.
             * @function modifyGroupRemark
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyGroupRemarkRequest} request ModifyGroupRemarkRequest message or plain object
             * @param {kritor.group.GroupService.ModifyGroupRemarkCallback} callback Node-style callback called with the error, if any, and ModifyGroupRemarkResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.modifyGroupRemark = function modifyGroupRemark(request, callback) {
                return this.rpcCall(modifyGroupRemark, $root.kritor.group.ModifyGroupRemarkRequest, $root.kritor.group.ModifyGroupRemarkResponse, request, callback);
            }, "name", { value: "ModifyGroupRemark" });

            /**
             * Calls ModifyGroupRemark.
             * @function modifyGroupRemark
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyGroupRemarkRequest} request ModifyGroupRemarkRequest message or plain object
             * @returns {Promise<kritor.group.ModifyGroupRemarkResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#setGroupAdmin}.
             * @memberof kritor.group.GroupService
             * @typedef SetGroupAdminCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.SetGroupAdminResponse} [response] SetGroupAdminResponse
             */

            /**
             * Calls SetGroupAdmin.
             * @function setGroupAdmin
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupAdminRequest} request SetGroupAdminRequest message or plain object
             * @param {kritor.group.GroupService.SetGroupAdminCallback} callback Node-style callback called with the error, if any, and SetGroupAdminResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.setGroupAdmin = function setGroupAdmin(request, callback) {
                return this.rpcCall(setGroupAdmin, $root.kritor.group.SetGroupAdminRequest, $root.kritor.group.SetGroupAdminResponse, request, callback);
            }, "name", { value: "SetGroupAdmin" });

            /**
             * Calls SetGroupAdmin.
             * @function setGroupAdmin
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupAdminRequest} request SetGroupAdminRequest message or plain object
             * @returns {Promise<kritor.group.SetGroupAdminResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#setGroupUniqueTitle}.
             * @memberof kritor.group.GroupService
             * @typedef SetGroupUniqueTitleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.SetGroupUniqueTitleResponse} [response] SetGroupUniqueTitleResponse
             */

            /**
             * Calls SetGroupUniqueTitle.
             * @function setGroupUniqueTitle
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupUniqueTitleRequest} request SetGroupUniqueTitleRequest message or plain object
             * @param {kritor.group.GroupService.SetGroupUniqueTitleCallback} callback Node-style callback called with the error, if any, and SetGroupUniqueTitleResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.setGroupUniqueTitle = function setGroupUniqueTitle(request, callback) {
                return this.rpcCall(setGroupUniqueTitle, $root.kritor.group.SetGroupUniqueTitleRequest, $root.kritor.group.SetGroupUniqueTitleResponse, request, callback);
            }, "name", { value: "SetGroupUniqueTitle" });

            /**
             * Calls SetGroupUniqueTitle.
             * @function setGroupUniqueTitle
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupUniqueTitleRequest} request SetGroupUniqueTitleRequest message or plain object
             * @returns {Promise<kritor.group.SetGroupUniqueTitleResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#setGroupWholeBan}.
             * @memberof kritor.group.GroupService
             * @typedef SetGroupWholeBanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.SetGroupWholeBanResponse} [response] SetGroupWholeBanResponse
             */

            /**
             * Calls SetGroupWholeBan.
             * @function setGroupWholeBan
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupWholeBanRequest} request SetGroupWholeBanRequest message or plain object
             * @param {kritor.group.GroupService.SetGroupWholeBanCallback} callback Node-style callback called with the error, if any, and SetGroupWholeBanResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.setGroupWholeBan = function setGroupWholeBan(request, callback) {
                return this.rpcCall(setGroupWholeBan, $root.kritor.group.SetGroupWholeBanRequest, $root.kritor.group.SetGroupWholeBanResponse, request, callback);
            }, "name", { value: "SetGroupWholeBan" });

            /**
             * Calls SetGroupWholeBan.
             * @function setGroupWholeBan
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupWholeBanRequest} request SetGroupWholeBanRequest message or plain object
             * @returns {Promise<kritor.group.SetGroupWholeBanResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getGroupInfo}.
             * @memberof kritor.group.GroupService
             * @typedef GetGroupInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetGroupInfoResponse} [response] GetGroupInfoResponse
             */

            /**
             * Calls GetGroupInfo.
             * @function getGroupInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupInfoRequest} request GetGroupInfoRequest message or plain object
             * @param {kritor.group.GroupService.GetGroupInfoCallback} callback Node-style callback called with the error, if any, and GetGroupInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getGroupInfo = function getGroupInfo(request, callback) {
                return this.rpcCall(getGroupInfo, $root.kritor.group.GetGroupInfoRequest, $root.kritor.group.GetGroupInfoResponse, request, callback);
            }, "name", { value: "GetGroupInfo" });

            /**
             * Calls GetGroupInfo.
             * @function getGroupInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupInfoRequest} request GetGroupInfoRequest message or plain object
             * @returns {Promise<kritor.group.GetGroupInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getGroupList}.
             * @memberof kritor.group.GroupService
             * @typedef GetGroupListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetGroupListResponse} [response] GetGroupListResponse
             */

            /**
             * Calls GetGroupList.
             * @function getGroupList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupListRequest} request GetGroupListRequest message or plain object
             * @param {kritor.group.GroupService.GetGroupListCallback} callback Node-style callback called with the error, if any, and GetGroupListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getGroupList = function getGroupList(request, callback) {
                return this.rpcCall(getGroupList, $root.kritor.group.GetGroupListRequest, $root.kritor.group.GetGroupListResponse, request, callback);
            }, "name", { value: "GetGroupList" });

            /**
             * Calls GetGroupList.
             * @function getGroupList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupListRequest} request GetGroupListRequest message or plain object
             * @returns {Promise<kritor.group.GetGroupListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getGroupMemberInfo}.
             * @memberof kritor.group.GroupService
             * @typedef GetGroupMemberInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetGroupMemberInfoResponse} [response] GetGroupMemberInfoResponse
             */

            /**
             * Calls GetGroupMemberInfo.
             * @function getGroupMemberInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupMemberInfoRequest} request GetGroupMemberInfoRequest message or plain object
             * @param {kritor.group.GroupService.GetGroupMemberInfoCallback} callback Node-style callback called with the error, if any, and GetGroupMemberInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getGroupMemberInfo = function getGroupMemberInfo(request, callback) {
                return this.rpcCall(getGroupMemberInfo, $root.kritor.group.GetGroupMemberInfoRequest, $root.kritor.group.GetGroupMemberInfoResponse, request, callback);
            }, "name", { value: "GetGroupMemberInfo" });

            /**
             * Calls GetGroupMemberInfo.
             * @function getGroupMemberInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupMemberInfoRequest} request GetGroupMemberInfoRequest message or plain object
             * @returns {Promise<kritor.group.GetGroupMemberInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getGroupMemberList}.
             * @memberof kritor.group.GroupService
             * @typedef GetGroupMemberListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetGroupMemberListResponse} [response] GetGroupMemberListResponse
             */

            /**
             * Calls GetGroupMemberList.
             * @function getGroupMemberList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupMemberListRequest} request GetGroupMemberListRequest message or plain object
             * @param {kritor.group.GroupService.GetGroupMemberListCallback} callback Node-style callback called with the error, if any, and GetGroupMemberListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getGroupMemberList = function getGroupMemberList(request, callback) {
                return this.rpcCall(getGroupMemberList, $root.kritor.group.GetGroupMemberListRequest, $root.kritor.group.GetGroupMemberListResponse, request, callback);
            }, "name", { value: "GetGroupMemberList" });

            /**
             * Calls GetGroupMemberList.
             * @function getGroupMemberList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupMemberListRequest} request GetGroupMemberListRequest message or plain object
             * @returns {Promise<kritor.group.GetGroupMemberListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getProhibitedUserList}.
             * @memberof kritor.group.GroupService
             * @typedef GetProhibitedUserListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetProhibitedUserListResponse} [response] GetProhibitedUserListResponse
             */

            /**
             * Calls GetProhibitedUserList.
             * @function getProhibitedUserList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetProhibitedUserListRequest} request GetProhibitedUserListRequest message or plain object
             * @param {kritor.group.GroupService.GetProhibitedUserListCallback} callback Node-style callback called with the error, if any, and GetProhibitedUserListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getProhibitedUserList = function getProhibitedUserList(request, callback) {
                return this.rpcCall(getProhibitedUserList, $root.kritor.group.GetProhibitedUserListRequest, $root.kritor.group.GetProhibitedUserListResponse, request, callback);
            }, "name", { value: "GetProhibitedUserList" });

            /**
             * Calls GetProhibitedUserList.
             * @function getProhibitedUserList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetProhibitedUserListRequest} request GetProhibitedUserListRequest message or plain object
             * @returns {Promise<kritor.group.GetProhibitedUserListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getRemainCountAtAll}.
             * @memberof kritor.group.GroupService
             * @typedef GetRemainCountAtAllCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetRemainCountAtAllResponse} [response] GetRemainCountAtAllResponse
             */

            /**
             * Calls GetRemainCountAtAll.
             * @function getRemainCountAtAll
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetRemainCountAtAllRequest} request GetRemainCountAtAllRequest message or plain object
             * @param {kritor.group.GroupService.GetRemainCountAtAllCallback} callback Node-style callback called with the error, if any, and GetRemainCountAtAllResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getRemainCountAtAll = function getRemainCountAtAll(request, callback) {
                return this.rpcCall(getRemainCountAtAll, $root.kritor.group.GetRemainCountAtAllRequest, $root.kritor.group.GetRemainCountAtAllResponse, request, callback);
            }, "name", { value: "GetRemainCountAtAll" });

            /**
             * Calls GetRemainCountAtAll.
             * @function getRemainCountAtAll
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetRemainCountAtAllRequest} request GetRemainCountAtAllRequest message or plain object
             * @returns {Promise<kritor.group.GetRemainCountAtAllResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getNotJoinedGroupInfo}.
             * @memberof kritor.group.GroupService
             * @typedef GetNotJoinedGroupInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetNotJoinedGroupInfoResponse} [response] GetNotJoinedGroupInfoResponse
             */

            /**
             * Calls GetNotJoinedGroupInfo.
             * @function getNotJoinedGroupInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest} request GetNotJoinedGroupInfoRequest message or plain object
             * @param {kritor.group.GroupService.GetNotJoinedGroupInfoCallback} callback Node-style callback called with the error, if any, and GetNotJoinedGroupInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getNotJoinedGroupInfo = function getNotJoinedGroupInfo(request, callback) {
                return this.rpcCall(getNotJoinedGroupInfo, $root.kritor.group.GetNotJoinedGroupInfoRequest, $root.kritor.group.GetNotJoinedGroupInfoResponse, request, callback);
            }, "name", { value: "GetNotJoinedGroupInfo" });

            /**
             * Calls GetNotJoinedGroupInfo.
             * @function getNotJoinedGroupInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest} request GetNotJoinedGroupInfoRequest message or plain object
             * @returns {Promise<kritor.group.GetNotJoinedGroupInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getGroupHonor}.
             * @memberof kritor.group.GroupService
             * @typedef GetGroupHonorCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetGroupHonorResponse} [response] GetGroupHonorResponse
             */

            /**
             * Calls GetGroupHonor.
             * @function getGroupHonor
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupHonorRequest} request GetGroupHonorRequest message or plain object
             * @param {kritor.group.GroupService.GetGroupHonorCallback} callback Node-style callback called with the error, if any, and GetGroupHonorResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getGroupHonor = function getGroupHonor(request, callback) {
                return this.rpcCall(getGroupHonor, $root.kritor.group.GetGroupHonorRequest, $root.kritor.group.GetGroupHonorResponse, request, callback);
            }, "name", { value: "GetGroupHonor" });

            /**
             * Calls GetGroupHonor.
             * @function getGroupHonor
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupHonorRequest} request GetGroupHonorRequest message or plain object
             * @returns {Promise<kritor.group.GetGroupHonorResponse>} Promise
             * @variation 2
             */

            return GroupService;
        })();

        group.BanMemberRequest = (function() {

            /**
             * Properties of a BanMemberRequest.
             * @memberof kritor.group
             * @interface IBanMemberRequest
             * @property {number|Long|null} [group_id] BanMemberRequest group_id
             * @property {string|null} [target_uid] BanMemberRequest target_uid
             * @property {number|Long|null} [target_uin] BanMemberRequest target_uin
             * @property {number|null} [duration] BanMemberRequest duration
             */

            /**
             * Constructs a new BanMemberRequest.
             * @memberof kritor.group
             * @classdesc Represents a BanMemberRequest.
             * @implements IBanMemberRequest
             * @constructor
             * @param {kritor.group.IBanMemberRequest=} [properties] Properties to set
             */
            function BanMemberRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BanMemberRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.BanMemberRequest
             * @instance
             */
            BanMemberRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * BanMemberRequest target_uid.
             * @member {string|null|undefined} target_uid
             * @memberof kritor.group.BanMemberRequest
             * @instance
             */
            BanMemberRequest.prototype.target_uid = null;

            /**
             * BanMemberRequest target_uin.
             * @member {number|Long|null|undefined} target_uin
             * @memberof kritor.group.BanMemberRequest
             * @instance
             */
            BanMemberRequest.prototype.target_uin = null;

            /**
             * BanMemberRequest duration.
             * @member {number} duration
             * @memberof kritor.group.BanMemberRequest
             * @instance
             */
            BanMemberRequest.prototype.duration = 0;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * BanMemberRequest target.
             * @member {"target_uid"|"target_uin"|undefined} target
             * @memberof kritor.group.BanMemberRequest
             * @instance
             */
            Object.defineProperty(BanMemberRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["target_uid", "target_uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new BanMemberRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {kritor.group.IBanMemberRequest=} [properties] Properties to set
             * @returns {kritor.group.BanMemberRequest} BanMemberRequest instance
             */
            BanMemberRequest.create = function create(properties) {
                return new BanMemberRequest(properties);
            };

            /**
             * Encodes the specified BanMemberRequest message. Does not implicitly {@link kritor.group.BanMemberRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {kritor.group.IBanMemberRequest} message BanMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BanMemberRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.target_uin);
                if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.duration);
                return writer;
            };

            /**
             * Encodes the specified BanMemberRequest message, length delimited. Does not implicitly {@link kritor.group.BanMemberRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {kritor.group.IBanMemberRequest} message BanMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BanMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BanMemberRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.BanMemberRequest} BanMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BanMemberRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.BanMemberRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.duration = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BanMemberRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.BanMemberRequest} BanMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BanMemberRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BanMemberRequest message.
             * @function verify
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BanMemberRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    properties.target = 1;
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                }
                if (message.duration != null && message.hasOwnProperty("duration"))
                    if (!$util.isInteger(message.duration))
                        return "duration: integer expected";
                return null;
            };

            /**
             * Creates a BanMemberRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.BanMemberRequest} BanMemberRequest
             */
            BanMemberRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.BanMemberRequest)
                    return object;
                let message = new $root.kritor.group.BanMemberRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                if (object.duration != null)
                    message.duration = object.duration >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a BanMemberRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {kritor.group.BanMemberRequest} message BanMemberRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BanMemberRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.duration = 0;
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    object.target_uid = message.target_uid;
                    if (options.oneofs)
                        object.target = "target_uid";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                    if (options.oneofs)
                        object.target = "target_uin";
                }
                if (message.duration != null && message.hasOwnProperty("duration"))
                    object.duration = message.duration;
                return object;
            };

            /**
             * Converts this BanMemberRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.BanMemberRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BanMemberRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BanMemberRequest
             * @function getTypeUrl
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BanMemberRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.BanMemberRequest";
            };

            return BanMemberRequest;
        })();

        group.BanMemberResponse = (function() {

            /**
             * Properties of a BanMemberResponse.
             * @memberof kritor.group
             * @interface IBanMemberResponse
             * @property {number|Long|null} [group_id] BanMemberResponse group_id
             */

            /**
             * Constructs a new BanMemberResponse.
             * @memberof kritor.group
             * @classdesc Represents a BanMemberResponse.
             * @implements IBanMemberResponse
             * @constructor
             * @param {kritor.group.IBanMemberResponse=} [properties] Properties to set
             */
            function BanMemberResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BanMemberResponse group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.BanMemberResponse
             * @instance
             */
            BanMemberResponse.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new BanMemberResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {kritor.group.IBanMemberResponse=} [properties] Properties to set
             * @returns {kritor.group.BanMemberResponse} BanMemberResponse instance
             */
            BanMemberResponse.create = function create(properties) {
                return new BanMemberResponse(properties);
            };

            /**
             * Encodes the specified BanMemberResponse message. Does not implicitly {@link kritor.group.BanMemberResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {kritor.group.IBanMemberResponse} message BanMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BanMemberResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                return writer;
            };

            /**
             * Encodes the specified BanMemberResponse message, length delimited. Does not implicitly {@link kritor.group.BanMemberResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {kritor.group.IBanMemberResponse} message BanMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BanMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BanMemberResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.BanMemberResponse} BanMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BanMemberResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.BanMemberResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BanMemberResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.BanMemberResponse} BanMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BanMemberResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BanMemberResponse message.
             * @function verify
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BanMemberResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                return null;
            };

            /**
             * Creates a BanMemberResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.BanMemberResponse} BanMemberResponse
             */
            BanMemberResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.BanMemberResponse)
                    return object;
                let message = new $root.kritor.group.BanMemberResponse();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a BanMemberResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {kritor.group.BanMemberResponse} message BanMemberResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BanMemberResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                return object;
            };

            /**
             * Converts this BanMemberResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.BanMemberResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BanMemberResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BanMemberResponse
             * @function getTypeUrl
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BanMemberResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.BanMemberResponse";
            };

            return BanMemberResponse;
        })();

        group.PokeMemberRequest = (function() {

            /**
             * Properties of a PokeMemberRequest.
             * @memberof kritor.group
             * @interface IPokeMemberRequest
             * @property {number|Long|null} [group_id] PokeMemberRequest group_id
             * @property {string|null} [target_uid] PokeMemberRequest target_uid
             * @property {number|Long|null} [target_uin] PokeMemberRequest target_uin
             */

            /**
             * Constructs a new PokeMemberRequest.
             * @memberof kritor.group
             * @classdesc Represents a PokeMemberRequest.
             * @implements IPokeMemberRequest
             * @constructor
             * @param {kritor.group.IPokeMemberRequest=} [properties] Properties to set
             */
            function PokeMemberRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PokeMemberRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.PokeMemberRequest
             * @instance
             */
            PokeMemberRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * PokeMemberRequest target_uid.
             * @member {string|null|undefined} target_uid
             * @memberof kritor.group.PokeMemberRequest
             * @instance
             */
            PokeMemberRequest.prototype.target_uid = null;

            /**
             * PokeMemberRequest target_uin.
             * @member {number|Long|null|undefined} target_uin
             * @memberof kritor.group.PokeMemberRequest
             * @instance
             */
            PokeMemberRequest.prototype.target_uin = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * PokeMemberRequest target.
             * @member {"target_uid"|"target_uin"|undefined} target
             * @memberof kritor.group.PokeMemberRequest
             * @instance
             */
            Object.defineProperty(PokeMemberRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["target_uid", "target_uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new PokeMemberRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {kritor.group.IPokeMemberRequest=} [properties] Properties to set
             * @returns {kritor.group.PokeMemberRequest} PokeMemberRequest instance
             */
            PokeMemberRequest.create = function create(properties) {
                return new PokeMemberRequest(properties);
            };

            /**
             * Encodes the specified PokeMemberRequest message. Does not implicitly {@link kritor.group.PokeMemberRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {kritor.group.IPokeMemberRequest} message PokeMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeMemberRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.target_uin);
                return writer;
            };

            /**
             * Encodes the specified PokeMemberRequest message, length delimited. Does not implicitly {@link kritor.group.PokeMemberRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {kritor.group.IPokeMemberRequest} message PokeMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PokeMemberRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.PokeMemberRequest} PokeMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeMemberRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.PokeMemberRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PokeMemberRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.PokeMemberRequest} PokeMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeMemberRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PokeMemberRequest message.
             * @function verify
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PokeMemberRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    properties.target = 1;
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                }
                return null;
            };

            /**
             * Creates a PokeMemberRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.PokeMemberRequest} PokeMemberRequest
             */
            PokeMemberRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.PokeMemberRequest)
                    return object;
                let message = new $root.kritor.group.PokeMemberRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a PokeMemberRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {kritor.group.PokeMemberRequest} message PokeMemberRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PokeMemberRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    object.target_uid = message.target_uid;
                    if (options.oneofs)
                        object.target = "target_uid";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                    if (options.oneofs)
                        object.target = "target_uin";
                }
                return object;
            };

            /**
             * Converts this PokeMemberRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.PokeMemberRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PokeMemberRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PokeMemberRequest
             * @function getTypeUrl
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PokeMemberRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.PokeMemberRequest";
            };

            return PokeMemberRequest;
        })();

        group.PokeMemberResponse = (function() {

            /**
             * Properties of a PokeMemberResponse.
             * @memberof kritor.group
             * @interface IPokeMemberResponse
             */

            /**
             * Constructs a new PokeMemberResponse.
             * @memberof kritor.group
             * @classdesc Represents a PokeMemberResponse.
             * @implements IPokeMemberResponse
             * @constructor
             * @param {kritor.group.IPokeMemberResponse=} [properties] Properties to set
             */
            function PokeMemberResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new PokeMemberResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {kritor.group.IPokeMemberResponse=} [properties] Properties to set
             * @returns {kritor.group.PokeMemberResponse} PokeMemberResponse instance
             */
            PokeMemberResponse.create = function create(properties) {
                return new PokeMemberResponse(properties);
            };

            /**
             * Encodes the specified PokeMemberResponse message. Does not implicitly {@link kritor.group.PokeMemberResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {kritor.group.IPokeMemberResponse} message PokeMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeMemberResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified PokeMemberResponse message, length delimited. Does not implicitly {@link kritor.group.PokeMemberResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {kritor.group.IPokeMemberResponse} message PokeMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PokeMemberResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.PokeMemberResponse} PokeMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeMemberResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.PokeMemberResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PokeMemberResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.PokeMemberResponse} PokeMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeMemberResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PokeMemberResponse message.
             * @function verify
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PokeMemberResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a PokeMemberResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.PokeMemberResponse} PokeMemberResponse
             */
            PokeMemberResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.PokeMemberResponse)
                    return object;
                return new $root.kritor.group.PokeMemberResponse();
            };

            /**
             * Creates a plain object from a PokeMemberResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {kritor.group.PokeMemberResponse} message PokeMemberResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PokeMemberResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this PokeMemberResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.PokeMemberResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PokeMemberResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PokeMemberResponse
             * @function getTypeUrl
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PokeMemberResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.PokeMemberResponse";
            };

            return PokeMemberResponse;
        })();

        group.KickMemberRequest = (function() {

            /**
             * Properties of a KickMemberRequest.
             * @memberof kritor.group
             * @interface IKickMemberRequest
             * @property {number|Long|null} [group_id] KickMemberRequest group_id
             * @property {string|null} [target_uid] KickMemberRequest target_uid
             * @property {number|Long|null} [target_uin] KickMemberRequest target_uin
             * @property {boolean|null} [reject_add_request] KickMemberRequest reject_add_request
             * @property {string|null} [kick_reason] KickMemberRequest kick_reason
             */

            /**
             * Constructs a new KickMemberRequest.
             * @memberof kritor.group
             * @classdesc Represents a KickMemberRequest.
             * @implements IKickMemberRequest
             * @constructor
             * @param {kritor.group.IKickMemberRequest=} [properties] Properties to set
             */
            function KickMemberRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KickMemberRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            KickMemberRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * KickMemberRequest target_uid.
             * @member {string|null|undefined} target_uid
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            KickMemberRequest.prototype.target_uid = null;

            /**
             * KickMemberRequest target_uin.
             * @member {number|Long|null|undefined} target_uin
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            KickMemberRequest.prototype.target_uin = null;

            /**
             * KickMemberRequest reject_add_request.
             * @member {boolean|null|undefined} reject_add_request
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            KickMemberRequest.prototype.reject_add_request = null;

            /**
             * KickMemberRequest kick_reason.
             * @member {string|null|undefined} kick_reason
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            KickMemberRequest.prototype.kick_reason = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * KickMemberRequest target.
             * @member {"target_uid"|"target_uin"|undefined} target
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            Object.defineProperty(KickMemberRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["target_uid", "target_uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * KickMemberRequest _reject_add_request.
             * @member {"reject_add_request"|undefined} _reject_add_request
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            Object.defineProperty(KickMemberRequest.prototype, "_reject_add_request", {
                get: $util.oneOfGetter($oneOfFields = ["reject_add_request"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * KickMemberRequest _kick_reason.
             * @member {"kick_reason"|undefined} _kick_reason
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            Object.defineProperty(KickMemberRequest.prototype, "_kick_reason", {
                get: $util.oneOfGetter($oneOfFields = ["kick_reason"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new KickMemberRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {kritor.group.IKickMemberRequest=} [properties] Properties to set
             * @returns {kritor.group.KickMemberRequest} KickMemberRequest instance
             */
            KickMemberRequest.create = function create(properties) {
                return new KickMemberRequest(properties);
            };

            /**
             * Encodes the specified KickMemberRequest message. Does not implicitly {@link kritor.group.KickMemberRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {kritor.group.IKickMemberRequest} message KickMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickMemberRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.target_uin);
                if (message.kick_reason != null && Object.hasOwnProperty.call(message, "kick_reason"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.kick_reason);
                if (message.reject_add_request != null && Object.hasOwnProperty.call(message, "reject_add_request"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.reject_add_request);
                return writer;
            };

            /**
             * Encodes the specified KickMemberRequest message, length delimited. Does not implicitly {@link kritor.group.KickMemberRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {kritor.group.IKickMemberRequest} message KickMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KickMemberRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.KickMemberRequest} KickMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickMemberRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.KickMemberRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.reject_add_request = reader.bool();
                            break;
                        }
                    case 5: {
                            message.kick_reason = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KickMemberRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.KickMemberRequest} KickMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickMemberRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KickMemberRequest message.
             * @function verify
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KickMemberRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    properties.target = 1;
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                }
                if (message.reject_add_request != null && message.hasOwnProperty("reject_add_request")) {
                    properties._reject_add_request = 1;
                    if (typeof message.reject_add_request !== "boolean")
                        return "reject_add_request: boolean expected";
                }
                if (message.kick_reason != null && message.hasOwnProperty("kick_reason")) {
                    properties._kick_reason = 1;
                    if (!$util.isString(message.kick_reason))
                        return "kick_reason: string expected";
                }
                return null;
            };

            /**
             * Creates a KickMemberRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.KickMemberRequest} KickMemberRequest
             */
            KickMemberRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.KickMemberRequest)
                    return object;
                let message = new $root.kritor.group.KickMemberRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                if (object.reject_add_request != null)
                    message.reject_add_request = Boolean(object.reject_add_request);
                if (object.kick_reason != null)
                    message.kick_reason = String(object.kick_reason);
                return message;
            };

            /**
             * Creates a plain object from a KickMemberRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {kritor.group.KickMemberRequest} message KickMemberRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickMemberRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    object.target_uid = message.target_uid;
                    if (options.oneofs)
                        object.target = "target_uid";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                    if (options.oneofs)
                        object.target = "target_uin";
                }
                if (message.kick_reason != null && message.hasOwnProperty("kick_reason")) {
                    object.kick_reason = message.kick_reason;
                    if (options.oneofs)
                        object._kick_reason = "kick_reason";
                }
                if (message.reject_add_request != null && message.hasOwnProperty("reject_add_request")) {
                    object.reject_add_request = message.reject_add_request;
                    if (options.oneofs)
                        object._reject_add_request = "reject_add_request";
                }
                return object;
            };

            /**
             * Converts this KickMemberRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.KickMemberRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KickMemberRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KickMemberRequest
             * @function getTypeUrl
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KickMemberRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.KickMemberRequest";
            };

            return KickMemberRequest;
        })();

        group.KickMemberResponse = (function() {

            /**
             * Properties of a KickMemberResponse.
             * @memberof kritor.group
             * @interface IKickMemberResponse
             */

            /**
             * Constructs a new KickMemberResponse.
             * @memberof kritor.group
             * @classdesc Represents a KickMemberResponse.
             * @implements IKickMemberResponse
             * @constructor
             * @param {kritor.group.IKickMemberResponse=} [properties] Properties to set
             */
            function KickMemberResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new KickMemberResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {kritor.group.IKickMemberResponse=} [properties] Properties to set
             * @returns {kritor.group.KickMemberResponse} KickMemberResponse instance
             */
            KickMemberResponse.create = function create(properties) {
                return new KickMemberResponse(properties);
            };

            /**
             * Encodes the specified KickMemberResponse message. Does not implicitly {@link kritor.group.KickMemberResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {kritor.group.IKickMemberResponse} message KickMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickMemberResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified KickMemberResponse message, length delimited. Does not implicitly {@link kritor.group.KickMemberResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {kritor.group.IKickMemberResponse} message KickMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KickMemberResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.KickMemberResponse} KickMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickMemberResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.KickMemberResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KickMemberResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.KickMemberResponse} KickMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickMemberResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KickMemberResponse message.
             * @function verify
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KickMemberResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a KickMemberResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.KickMemberResponse} KickMemberResponse
             */
            KickMemberResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.KickMemberResponse)
                    return object;
                return new $root.kritor.group.KickMemberResponse();
            };

            /**
             * Creates a plain object from a KickMemberResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {kritor.group.KickMemberResponse} message KickMemberResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickMemberResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this KickMemberResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.KickMemberResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KickMemberResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KickMemberResponse
             * @function getTypeUrl
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KickMemberResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.KickMemberResponse";
            };

            return KickMemberResponse;
        })();

        group.LeaveGroupRequest = (function() {

            /**
             * Properties of a LeaveGroupRequest.
             * @memberof kritor.group
             * @interface ILeaveGroupRequest
             * @property {number|Long|null} [group_id] LeaveGroupRequest group_id
             */

            /**
             * Constructs a new LeaveGroupRequest.
             * @memberof kritor.group
             * @classdesc Represents a LeaveGroupRequest.
             * @implements ILeaveGroupRequest
             * @constructor
             * @param {kritor.group.ILeaveGroupRequest=} [properties] Properties to set
             */
            function LeaveGroupRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LeaveGroupRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.LeaveGroupRequest
             * @instance
             */
            LeaveGroupRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new LeaveGroupRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {kritor.group.ILeaveGroupRequest=} [properties] Properties to set
             * @returns {kritor.group.LeaveGroupRequest} LeaveGroupRequest instance
             */
            LeaveGroupRequest.create = function create(properties) {
                return new LeaveGroupRequest(properties);
            };

            /**
             * Encodes the specified LeaveGroupRequest message. Does not implicitly {@link kritor.group.LeaveGroupRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {kritor.group.ILeaveGroupRequest} message LeaveGroupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeaveGroupRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                return writer;
            };

            /**
             * Encodes the specified LeaveGroupRequest message, length delimited. Does not implicitly {@link kritor.group.LeaveGroupRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {kritor.group.ILeaveGroupRequest} message LeaveGroupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeaveGroupRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LeaveGroupRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.LeaveGroupRequest} LeaveGroupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeaveGroupRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.LeaveGroupRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LeaveGroupRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.LeaveGroupRequest} LeaveGroupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeaveGroupRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LeaveGroupRequest message.
             * @function verify
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LeaveGroupRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                return null;
            };

            /**
             * Creates a LeaveGroupRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.LeaveGroupRequest} LeaveGroupRequest
             */
            LeaveGroupRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.LeaveGroupRequest)
                    return object;
                let message = new $root.kritor.group.LeaveGroupRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a LeaveGroupRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {kritor.group.LeaveGroupRequest} message LeaveGroupRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LeaveGroupRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                return object;
            };

            /**
             * Converts this LeaveGroupRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.LeaveGroupRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LeaveGroupRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LeaveGroupRequest
             * @function getTypeUrl
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LeaveGroupRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.LeaveGroupRequest";
            };

            return LeaveGroupRequest;
        })();

        group.LeaveGroupResponse = (function() {

            /**
             * Properties of a LeaveGroupResponse.
             * @memberof kritor.group
             * @interface ILeaveGroupResponse
             */

            /**
             * Constructs a new LeaveGroupResponse.
             * @memberof kritor.group
             * @classdesc Represents a LeaveGroupResponse.
             * @implements ILeaveGroupResponse
             * @constructor
             * @param {kritor.group.ILeaveGroupResponse=} [properties] Properties to set
             */
            function LeaveGroupResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new LeaveGroupResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {kritor.group.ILeaveGroupResponse=} [properties] Properties to set
             * @returns {kritor.group.LeaveGroupResponse} LeaveGroupResponse instance
             */
            LeaveGroupResponse.create = function create(properties) {
                return new LeaveGroupResponse(properties);
            };

            /**
             * Encodes the specified LeaveGroupResponse message. Does not implicitly {@link kritor.group.LeaveGroupResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {kritor.group.ILeaveGroupResponse} message LeaveGroupResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeaveGroupResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified LeaveGroupResponse message, length delimited. Does not implicitly {@link kritor.group.LeaveGroupResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {kritor.group.ILeaveGroupResponse} message LeaveGroupResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeaveGroupResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LeaveGroupResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.LeaveGroupResponse} LeaveGroupResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeaveGroupResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.LeaveGroupResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LeaveGroupResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.LeaveGroupResponse} LeaveGroupResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeaveGroupResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LeaveGroupResponse message.
             * @function verify
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LeaveGroupResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a LeaveGroupResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.LeaveGroupResponse} LeaveGroupResponse
             */
            LeaveGroupResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.LeaveGroupResponse)
                    return object;
                return new $root.kritor.group.LeaveGroupResponse();
            };

            /**
             * Creates a plain object from a LeaveGroupResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {kritor.group.LeaveGroupResponse} message LeaveGroupResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LeaveGroupResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this LeaveGroupResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.LeaveGroupResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LeaveGroupResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LeaveGroupResponse
             * @function getTypeUrl
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LeaveGroupResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.LeaveGroupResponse";
            };

            return LeaveGroupResponse;
        })();

        group.ModifyMemberCardRequest = (function() {

            /**
             * Properties of a ModifyMemberCardRequest.
             * @memberof kritor.group
             * @interface IModifyMemberCardRequest
             * @property {number|Long|null} [group_id] ModifyMemberCardRequest group_id
             * @property {string|null} [target_uid] ModifyMemberCardRequest target_uid
             * @property {number|Long|null} [target_uin] ModifyMemberCardRequest target_uin
             * @property {string|null} [card] ModifyMemberCardRequest card
             */

            /**
             * Constructs a new ModifyMemberCardRequest.
             * @memberof kritor.group
             * @classdesc Represents a ModifyMemberCardRequest.
             * @implements IModifyMemberCardRequest
             * @constructor
             * @param {kritor.group.IModifyMemberCardRequest=} [properties] Properties to set
             */
            function ModifyMemberCardRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModifyMemberCardRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             */
            ModifyMemberCardRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ModifyMemberCardRequest target_uid.
             * @member {string|null|undefined} target_uid
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             */
            ModifyMemberCardRequest.prototype.target_uid = null;

            /**
             * ModifyMemberCardRequest target_uin.
             * @member {number|Long|null|undefined} target_uin
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             */
            ModifyMemberCardRequest.prototype.target_uin = null;

            /**
             * ModifyMemberCardRequest card.
             * @member {string} card
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             */
            ModifyMemberCardRequest.prototype.card = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ModifyMemberCardRequest target.
             * @member {"target_uid"|"target_uin"|undefined} target
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             */
            Object.defineProperty(ModifyMemberCardRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["target_uid", "target_uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ModifyMemberCardRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {kritor.group.IModifyMemberCardRequest=} [properties] Properties to set
             * @returns {kritor.group.ModifyMemberCardRequest} ModifyMemberCardRequest instance
             */
            ModifyMemberCardRequest.create = function create(properties) {
                return new ModifyMemberCardRequest(properties);
            };

            /**
             * Encodes the specified ModifyMemberCardRequest message. Does not implicitly {@link kritor.group.ModifyMemberCardRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {kritor.group.IModifyMemberCardRequest} message ModifyMemberCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyMemberCardRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.target_uin);
                if (message.card != null && Object.hasOwnProperty.call(message, "card"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.card);
                return writer;
            };

            /**
             * Encodes the specified ModifyMemberCardRequest message, length delimited. Does not implicitly {@link kritor.group.ModifyMemberCardRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {kritor.group.IModifyMemberCardRequest} message ModifyMemberCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyMemberCardRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyMemberCardRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyMemberCardRequest} ModifyMemberCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyMemberCardRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyMemberCardRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.card = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyMemberCardRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyMemberCardRequest} ModifyMemberCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyMemberCardRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyMemberCardRequest message.
             * @function verify
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyMemberCardRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    properties.target = 1;
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                }
                if (message.card != null && message.hasOwnProperty("card"))
                    if (!$util.isString(message.card))
                        return "card: string expected";
                return null;
            };

            /**
             * Creates a ModifyMemberCardRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyMemberCardRequest} ModifyMemberCardRequest
             */
            ModifyMemberCardRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyMemberCardRequest)
                    return object;
                let message = new $root.kritor.group.ModifyMemberCardRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                if (object.card != null)
                    message.card = String(object.card);
                return message;
            };

            /**
             * Creates a plain object from a ModifyMemberCardRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {kritor.group.ModifyMemberCardRequest} message ModifyMemberCardRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyMemberCardRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.card = "";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    object.target_uid = message.target_uid;
                    if (options.oneofs)
                        object.target = "target_uid";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                    if (options.oneofs)
                        object.target = "target_uin";
                }
                if (message.card != null && message.hasOwnProperty("card"))
                    object.card = message.card;
                return object;
            };

            /**
             * Converts this ModifyMemberCardRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyMemberCardRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyMemberCardRequest
             * @function getTypeUrl
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyMemberCardRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyMemberCardRequest";
            };

            return ModifyMemberCardRequest;
        })();

        group.ModifyMemberCardResponse = (function() {

            /**
             * Properties of a ModifyMemberCardResponse.
             * @memberof kritor.group
             * @interface IModifyMemberCardResponse
             */

            /**
             * Constructs a new ModifyMemberCardResponse.
             * @memberof kritor.group
             * @classdesc Represents a ModifyMemberCardResponse.
             * @implements IModifyMemberCardResponse
             * @constructor
             * @param {kritor.group.IModifyMemberCardResponse=} [properties] Properties to set
             */
            function ModifyMemberCardResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ModifyMemberCardResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {kritor.group.IModifyMemberCardResponse=} [properties] Properties to set
             * @returns {kritor.group.ModifyMemberCardResponse} ModifyMemberCardResponse instance
             */
            ModifyMemberCardResponse.create = function create(properties) {
                return new ModifyMemberCardResponse(properties);
            };

            /**
             * Encodes the specified ModifyMemberCardResponse message. Does not implicitly {@link kritor.group.ModifyMemberCardResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {kritor.group.IModifyMemberCardResponse} message ModifyMemberCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyMemberCardResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ModifyMemberCardResponse message, length delimited. Does not implicitly {@link kritor.group.ModifyMemberCardResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {kritor.group.IModifyMemberCardResponse} message ModifyMemberCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyMemberCardResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyMemberCardResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyMemberCardResponse} ModifyMemberCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyMemberCardResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyMemberCardResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyMemberCardResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyMemberCardResponse} ModifyMemberCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyMemberCardResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyMemberCardResponse message.
             * @function verify
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyMemberCardResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ModifyMemberCardResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyMemberCardResponse} ModifyMemberCardResponse
             */
            ModifyMemberCardResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyMemberCardResponse)
                    return object;
                return new $root.kritor.group.ModifyMemberCardResponse();
            };

            /**
             * Creates a plain object from a ModifyMemberCardResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {kritor.group.ModifyMemberCardResponse} message ModifyMemberCardResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyMemberCardResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ModifyMemberCardResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyMemberCardResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyMemberCardResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyMemberCardResponse
             * @function getTypeUrl
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyMemberCardResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyMemberCardResponse";
            };

            return ModifyMemberCardResponse;
        })();

        group.ModifyGroupNameRequest = (function() {

            /**
             * Properties of a ModifyGroupNameRequest.
             * @memberof kritor.group
             * @interface IModifyGroupNameRequest
             * @property {number|Long|null} [group_id] ModifyGroupNameRequest group_id
             * @property {string|null} [group_name] ModifyGroupNameRequest group_name
             */

            /**
             * Constructs a new ModifyGroupNameRequest.
             * @memberof kritor.group
             * @classdesc Represents a ModifyGroupNameRequest.
             * @implements IModifyGroupNameRequest
             * @constructor
             * @param {kritor.group.IModifyGroupNameRequest=} [properties] Properties to set
             */
            function ModifyGroupNameRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModifyGroupNameRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.ModifyGroupNameRequest
             * @instance
             */
            ModifyGroupNameRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ModifyGroupNameRequest group_name.
             * @member {string} group_name
             * @memberof kritor.group.ModifyGroupNameRequest
             * @instance
             */
            ModifyGroupNameRequest.prototype.group_name = "";

            /**
             * Creates a new ModifyGroupNameRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {kritor.group.IModifyGroupNameRequest=} [properties] Properties to set
             * @returns {kritor.group.ModifyGroupNameRequest} ModifyGroupNameRequest instance
             */
            ModifyGroupNameRequest.create = function create(properties) {
                return new ModifyGroupNameRequest(properties);
            };

            /**
             * Encodes the specified ModifyGroupNameRequest message. Does not implicitly {@link kritor.group.ModifyGroupNameRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {kritor.group.IModifyGroupNameRequest} message ModifyGroupNameRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupNameRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.group_name != null && Object.hasOwnProperty.call(message, "group_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.group_name);
                return writer;
            };

            /**
             * Encodes the specified ModifyGroupNameRequest message, length delimited. Does not implicitly {@link kritor.group.ModifyGroupNameRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {kritor.group.IModifyGroupNameRequest} message ModifyGroupNameRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupNameRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyGroupNameRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyGroupNameRequest} ModifyGroupNameRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupNameRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyGroupNameRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.group_name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyGroupNameRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyGroupNameRequest} ModifyGroupNameRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupNameRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyGroupNameRequest message.
             * @function verify
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyGroupNameRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.group_name != null && message.hasOwnProperty("group_name"))
                    if (!$util.isString(message.group_name))
                        return "group_name: string expected";
                return null;
            };

            /**
             * Creates a ModifyGroupNameRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyGroupNameRequest} ModifyGroupNameRequest
             */
            ModifyGroupNameRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyGroupNameRequest)
                    return object;
                let message = new $root.kritor.group.ModifyGroupNameRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.group_name != null)
                    message.group_name = String(object.group_name);
                return message;
            };

            /**
             * Creates a plain object from a ModifyGroupNameRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {kritor.group.ModifyGroupNameRequest} message ModifyGroupNameRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyGroupNameRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.group_name = "";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.group_name != null && message.hasOwnProperty("group_name"))
                    object.group_name = message.group_name;
                return object;
            };

            /**
             * Converts this ModifyGroupNameRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyGroupNameRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyGroupNameRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyGroupNameRequest
             * @function getTypeUrl
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyGroupNameRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyGroupNameRequest";
            };

            return ModifyGroupNameRequest;
        })();

        group.ModifyGroupNameResponse = (function() {

            /**
             * Properties of a ModifyGroupNameResponse.
             * @memberof kritor.group
             * @interface IModifyGroupNameResponse
             */

            /**
             * Constructs a new ModifyGroupNameResponse.
             * @memberof kritor.group
             * @classdesc Represents a ModifyGroupNameResponse.
             * @implements IModifyGroupNameResponse
             * @constructor
             * @param {kritor.group.IModifyGroupNameResponse=} [properties] Properties to set
             */
            function ModifyGroupNameResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ModifyGroupNameResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {kritor.group.IModifyGroupNameResponse=} [properties] Properties to set
             * @returns {kritor.group.ModifyGroupNameResponse} ModifyGroupNameResponse instance
             */
            ModifyGroupNameResponse.create = function create(properties) {
                return new ModifyGroupNameResponse(properties);
            };

            /**
             * Encodes the specified ModifyGroupNameResponse message. Does not implicitly {@link kritor.group.ModifyGroupNameResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {kritor.group.IModifyGroupNameResponse} message ModifyGroupNameResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupNameResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ModifyGroupNameResponse message, length delimited. Does not implicitly {@link kritor.group.ModifyGroupNameResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {kritor.group.IModifyGroupNameResponse} message ModifyGroupNameResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupNameResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyGroupNameResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyGroupNameResponse} ModifyGroupNameResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupNameResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyGroupNameResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyGroupNameResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyGroupNameResponse} ModifyGroupNameResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupNameResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyGroupNameResponse message.
             * @function verify
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyGroupNameResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ModifyGroupNameResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyGroupNameResponse} ModifyGroupNameResponse
             */
            ModifyGroupNameResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyGroupNameResponse)
                    return object;
                return new $root.kritor.group.ModifyGroupNameResponse();
            };

            /**
             * Creates a plain object from a ModifyGroupNameResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {kritor.group.ModifyGroupNameResponse} message ModifyGroupNameResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyGroupNameResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ModifyGroupNameResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyGroupNameResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyGroupNameResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyGroupNameResponse
             * @function getTypeUrl
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyGroupNameResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyGroupNameResponse";
            };

            return ModifyGroupNameResponse;
        })();

        group.ModifyGroupRemarkRequest = (function() {

            /**
             * Properties of a ModifyGroupRemarkRequest.
             * @memberof kritor.group
             * @interface IModifyGroupRemarkRequest
             * @property {number|Long|null} [group_id] ModifyGroupRemarkRequest group_id
             * @property {string|null} [remark] ModifyGroupRemarkRequest remark
             */

            /**
             * Constructs a new ModifyGroupRemarkRequest.
             * @memberof kritor.group
             * @classdesc Represents a ModifyGroupRemarkRequest.
             * @implements IModifyGroupRemarkRequest
             * @constructor
             * @param {kritor.group.IModifyGroupRemarkRequest=} [properties] Properties to set
             */
            function ModifyGroupRemarkRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModifyGroupRemarkRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @instance
             */
            ModifyGroupRemarkRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ModifyGroupRemarkRequest remark.
             * @member {string} remark
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @instance
             */
            ModifyGroupRemarkRequest.prototype.remark = "";

            /**
             * Creates a new ModifyGroupRemarkRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {kritor.group.IModifyGroupRemarkRequest=} [properties] Properties to set
             * @returns {kritor.group.ModifyGroupRemarkRequest} ModifyGroupRemarkRequest instance
             */
            ModifyGroupRemarkRequest.create = function create(properties) {
                return new ModifyGroupRemarkRequest(properties);
            };

            /**
             * Encodes the specified ModifyGroupRemarkRequest message. Does not implicitly {@link kritor.group.ModifyGroupRemarkRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {kritor.group.IModifyGroupRemarkRequest} message ModifyGroupRemarkRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupRemarkRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.remark != null && Object.hasOwnProperty.call(message, "remark"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remark);
                return writer;
            };

            /**
             * Encodes the specified ModifyGroupRemarkRequest message, length delimited. Does not implicitly {@link kritor.group.ModifyGroupRemarkRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {kritor.group.IModifyGroupRemarkRequest} message ModifyGroupRemarkRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupRemarkRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyGroupRemarkRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyGroupRemarkRequest} ModifyGroupRemarkRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupRemarkRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyGroupRemarkRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.remark = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyGroupRemarkRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyGroupRemarkRequest} ModifyGroupRemarkRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupRemarkRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyGroupRemarkRequest message.
             * @function verify
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyGroupRemarkRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.remark != null && message.hasOwnProperty("remark"))
                    if (!$util.isString(message.remark))
                        return "remark: string expected";
                return null;
            };

            /**
             * Creates a ModifyGroupRemarkRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyGroupRemarkRequest} ModifyGroupRemarkRequest
             */
            ModifyGroupRemarkRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyGroupRemarkRequest)
                    return object;
                let message = new $root.kritor.group.ModifyGroupRemarkRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.remark != null)
                    message.remark = String(object.remark);
                return message;
            };

            /**
             * Creates a plain object from a ModifyGroupRemarkRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {kritor.group.ModifyGroupRemarkRequest} message ModifyGroupRemarkRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyGroupRemarkRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.remark = "";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.remark != null && message.hasOwnProperty("remark"))
                    object.remark = message.remark;
                return object;
            };

            /**
             * Converts this ModifyGroupRemarkRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyGroupRemarkRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyGroupRemarkRequest
             * @function getTypeUrl
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyGroupRemarkRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyGroupRemarkRequest";
            };

            return ModifyGroupRemarkRequest;
        })();

        group.ModifyGroupRemarkResponse = (function() {

            /**
             * Properties of a ModifyGroupRemarkResponse.
             * @memberof kritor.group
             * @interface IModifyGroupRemarkResponse
             */

            /**
             * Constructs a new ModifyGroupRemarkResponse.
             * @memberof kritor.group
             * @classdesc Represents a ModifyGroupRemarkResponse.
             * @implements IModifyGroupRemarkResponse
             * @constructor
             * @param {kritor.group.IModifyGroupRemarkResponse=} [properties] Properties to set
             */
            function ModifyGroupRemarkResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ModifyGroupRemarkResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {kritor.group.IModifyGroupRemarkResponse=} [properties] Properties to set
             * @returns {kritor.group.ModifyGroupRemarkResponse} ModifyGroupRemarkResponse instance
             */
            ModifyGroupRemarkResponse.create = function create(properties) {
                return new ModifyGroupRemarkResponse(properties);
            };

            /**
             * Encodes the specified ModifyGroupRemarkResponse message. Does not implicitly {@link kritor.group.ModifyGroupRemarkResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {kritor.group.IModifyGroupRemarkResponse} message ModifyGroupRemarkResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupRemarkResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ModifyGroupRemarkResponse message, length delimited. Does not implicitly {@link kritor.group.ModifyGroupRemarkResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {kritor.group.IModifyGroupRemarkResponse} message ModifyGroupRemarkResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupRemarkResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyGroupRemarkResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyGroupRemarkResponse} ModifyGroupRemarkResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupRemarkResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyGroupRemarkResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyGroupRemarkResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyGroupRemarkResponse} ModifyGroupRemarkResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupRemarkResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyGroupRemarkResponse message.
             * @function verify
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyGroupRemarkResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ModifyGroupRemarkResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyGroupRemarkResponse} ModifyGroupRemarkResponse
             */
            ModifyGroupRemarkResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyGroupRemarkResponse)
                    return object;
                return new $root.kritor.group.ModifyGroupRemarkResponse();
            };

            /**
             * Creates a plain object from a ModifyGroupRemarkResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {kritor.group.ModifyGroupRemarkResponse} message ModifyGroupRemarkResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyGroupRemarkResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ModifyGroupRemarkResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyGroupRemarkResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyGroupRemarkResponse
             * @function getTypeUrl
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyGroupRemarkResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyGroupRemarkResponse";
            };

            return ModifyGroupRemarkResponse;
        })();

        group.SetGroupAdminRequest = (function() {

            /**
             * Properties of a SetGroupAdminRequest.
             * @memberof kritor.group
             * @interface ISetGroupAdminRequest
             * @property {number|Long|null} [group_id] SetGroupAdminRequest group_id
             * @property {string|null} [target_uid] SetGroupAdminRequest target_uid
             * @property {number|Long|null} [target_uin] SetGroupAdminRequest target_uin
             * @property {boolean|null} [is_admin] SetGroupAdminRequest is_admin
             */

            /**
             * Constructs a new SetGroupAdminRequest.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupAdminRequest.
             * @implements ISetGroupAdminRequest
             * @constructor
             * @param {kritor.group.ISetGroupAdminRequest=} [properties] Properties to set
             */
            function SetGroupAdminRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetGroupAdminRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             */
            SetGroupAdminRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetGroupAdminRequest target_uid.
             * @member {string|null|undefined} target_uid
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             */
            SetGroupAdminRequest.prototype.target_uid = null;

            /**
             * SetGroupAdminRequest target_uin.
             * @member {number|Long|null|undefined} target_uin
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             */
            SetGroupAdminRequest.prototype.target_uin = null;

            /**
             * SetGroupAdminRequest is_admin.
             * @member {boolean} is_admin
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             */
            SetGroupAdminRequest.prototype.is_admin = false;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SetGroupAdminRequest target.
             * @member {"target_uid"|"target_uin"|undefined} target
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             */
            Object.defineProperty(SetGroupAdminRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["target_uid", "target_uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SetGroupAdminRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {kritor.group.ISetGroupAdminRequest=} [properties] Properties to set
             * @returns {kritor.group.SetGroupAdminRequest} SetGroupAdminRequest instance
             */
            SetGroupAdminRequest.create = function create(properties) {
                return new SetGroupAdminRequest(properties);
            };

            /**
             * Encodes the specified SetGroupAdminRequest message. Does not implicitly {@link kritor.group.SetGroupAdminRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {kritor.group.ISetGroupAdminRequest} message SetGroupAdminRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupAdminRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.target_uin);
                if (message.is_admin != null && Object.hasOwnProperty.call(message, "is_admin"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_admin);
                return writer;
            };

            /**
             * Encodes the specified SetGroupAdminRequest message, length delimited. Does not implicitly {@link kritor.group.SetGroupAdminRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {kritor.group.ISetGroupAdminRequest} message SetGroupAdminRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupAdminRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupAdminRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupAdminRequest} SetGroupAdminRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupAdminRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupAdminRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.is_admin = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupAdminRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupAdminRequest} SetGroupAdminRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupAdminRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupAdminRequest message.
             * @function verify
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupAdminRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    properties.target = 1;
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                }
                if (message.is_admin != null && message.hasOwnProperty("is_admin"))
                    if (typeof message.is_admin !== "boolean")
                        return "is_admin: boolean expected";
                return null;
            };

            /**
             * Creates a SetGroupAdminRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupAdminRequest} SetGroupAdminRequest
             */
            SetGroupAdminRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupAdminRequest)
                    return object;
                let message = new $root.kritor.group.SetGroupAdminRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                if (object.is_admin != null)
                    message.is_admin = Boolean(object.is_admin);
                return message;
            };

            /**
             * Creates a plain object from a SetGroupAdminRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {kritor.group.SetGroupAdminRequest} message SetGroupAdminRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupAdminRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.is_admin = false;
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    object.target_uid = message.target_uid;
                    if (options.oneofs)
                        object.target = "target_uid";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                    if (options.oneofs)
                        object.target = "target_uin";
                }
                if (message.is_admin != null && message.hasOwnProperty("is_admin"))
                    object.is_admin = message.is_admin;
                return object;
            };

            /**
             * Converts this SetGroupAdminRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupAdminRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupAdminRequest
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupAdminRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupAdminRequest";
            };

            return SetGroupAdminRequest;
        })();

        group.SetGroupAdminResponse = (function() {

            /**
             * Properties of a SetGroupAdminResponse.
             * @memberof kritor.group
             * @interface ISetGroupAdminResponse
             */

            /**
             * Constructs a new SetGroupAdminResponse.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupAdminResponse.
             * @implements ISetGroupAdminResponse
             * @constructor
             * @param {kritor.group.ISetGroupAdminResponse=} [properties] Properties to set
             */
            function SetGroupAdminResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetGroupAdminResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {kritor.group.ISetGroupAdminResponse=} [properties] Properties to set
             * @returns {kritor.group.SetGroupAdminResponse} SetGroupAdminResponse instance
             */
            SetGroupAdminResponse.create = function create(properties) {
                return new SetGroupAdminResponse(properties);
            };

            /**
             * Encodes the specified SetGroupAdminResponse message. Does not implicitly {@link kritor.group.SetGroupAdminResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {kritor.group.ISetGroupAdminResponse} message SetGroupAdminResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupAdminResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetGroupAdminResponse message, length delimited. Does not implicitly {@link kritor.group.SetGroupAdminResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {kritor.group.ISetGroupAdminResponse} message SetGroupAdminResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupAdminResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupAdminResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupAdminResponse} SetGroupAdminResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupAdminResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupAdminResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupAdminResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupAdminResponse} SetGroupAdminResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupAdminResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupAdminResponse message.
             * @function verify
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupAdminResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetGroupAdminResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupAdminResponse} SetGroupAdminResponse
             */
            SetGroupAdminResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupAdminResponse)
                    return object;
                return new $root.kritor.group.SetGroupAdminResponse();
            };

            /**
             * Creates a plain object from a SetGroupAdminResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {kritor.group.SetGroupAdminResponse} message SetGroupAdminResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupAdminResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetGroupAdminResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupAdminResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupAdminResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupAdminResponse
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupAdminResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupAdminResponse";
            };

            return SetGroupAdminResponse;
        })();

        group.SetGroupUniqueTitleRequest = (function() {

            /**
             * Properties of a SetGroupUniqueTitleRequest.
             * @memberof kritor.group
             * @interface ISetGroupUniqueTitleRequest
             * @property {number|Long|null} [group_id] SetGroupUniqueTitleRequest group_id
             * @property {string|null} [target_uid] SetGroupUniqueTitleRequest target_uid
             * @property {number|Long|null} [target_uin] SetGroupUniqueTitleRequest target_uin
             * @property {string|null} [unique_title] SetGroupUniqueTitleRequest unique_title
             */

            /**
             * Constructs a new SetGroupUniqueTitleRequest.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupUniqueTitleRequest.
             * @implements ISetGroupUniqueTitleRequest
             * @constructor
             * @param {kritor.group.ISetGroupUniqueTitleRequest=} [properties] Properties to set
             */
            function SetGroupUniqueTitleRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetGroupUniqueTitleRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             */
            SetGroupUniqueTitleRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetGroupUniqueTitleRequest target_uid.
             * @member {string|null|undefined} target_uid
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             */
            SetGroupUniqueTitleRequest.prototype.target_uid = null;

            /**
             * SetGroupUniqueTitleRequest target_uin.
             * @member {number|Long|null|undefined} target_uin
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             */
            SetGroupUniqueTitleRequest.prototype.target_uin = null;

            /**
             * SetGroupUniqueTitleRequest unique_title.
             * @member {string} unique_title
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             */
            SetGroupUniqueTitleRequest.prototype.unique_title = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SetGroupUniqueTitleRequest target.
             * @member {"target_uid"|"target_uin"|undefined} target
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             */
            Object.defineProperty(SetGroupUniqueTitleRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["target_uid", "target_uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SetGroupUniqueTitleRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleRequest=} [properties] Properties to set
             * @returns {kritor.group.SetGroupUniqueTitleRequest} SetGroupUniqueTitleRequest instance
             */
            SetGroupUniqueTitleRequest.create = function create(properties) {
                return new SetGroupUniqueTitleRequest(properties);
            };

            /**
             * Encodes the specified SetGroupUniqueTitleRequest message. Does not implicitly {@link kritor.group.SetGroupUniqueTitleRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleRequest} message SetGroupUniqueTitleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupUniqueTitleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.target_uin);
                if (message.unique_title != null && Object.hasOwnProperty.call(message, "unique_title"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.unique_title);
                return writer;
            };

            /**
             * Encodes the specified SetGroupUniqueTitleRequest message, length delimited. Does not implicitly {@link kritor.group.SetGroupUniqueTitleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleRequest} message SetGroupUniqueTitleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupUniqueTitleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupUniqueTitleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupUniqueTitleRequest} SetGroupUniqueTitleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupUniqueTitleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupUniqueTitleRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.unique_title = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupUniqueTitleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupUniqueTitleRequest} SetGroupUniqueTitleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupUniqueTitleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupUniqueTitleRequest message.
             * @function verify
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupUniqueTitleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    properties.target = 1;
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                }
                if (message.unique_title != null && message.hasOwnProperty("unique_title"))
                    if (!$util.isString(message.unique_title))
                        return "unique_title: string expected";
                return null;
            };

            /**
             * Creates a SetGroupUniqueTitleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupUniqueTitleRequest} SetGroupUniqueTitleRequest
             */
            SetGroupUniqueTitleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupUniqueTitleRequest)
                    return object;
                let message = new $root.kritor.group.SetGroupUniqueTitleRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                if (object.unique_title != null)
                    message.unique_title = String(object.unique_title);
                return message;
            };

            /**
             * Creates a plain object from a SetGroupUniqueTitleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {kritor.group.SetGroupUniqueTitleRequest} message SetGroupUniqueTitleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupUniqueTitleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.unique_title = "";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    object.target_uid = message.target_uid;
                    if (options.oneofs)
                        object.target = "target_uid";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                    if (options.oneofs)
                        object.target = "target_uin";
                }
                if (message.unique_title != null && message.hasOwnProperty("unique_title"))
                    object.unique_title = message.unique_title;
                return object;
            };

            /**
             * Converts this SetGroupUniqueTitleRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupUniqueTitleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupUniqueTitleRequest
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupUniqueTitleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupUniqueTitleRequest";
            };

            return SetGroupUniqueTitleRequest;
        })();

        group.SetGroupUniqueTitleResponse = (function() {

            /**
             * Properties of a SetGroupUniqueTitleResponse.
             * @memberof kritor.group
             * @interface ISetGroupUniqueTitleResponse
             */

            /**
             * Constructs a new SetGroupUniqueTitleResponse.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupUniqueTitleResponse.
             * @implements ISetGroupUniqueTitleResponse
             * @constructor
             * @param {kritor.group.ISetGroupUniqueTitleResponse=} [properties] Properties to set
             */
            function SetGroupUniqueTitleResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetGroupUniqueTitleResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleResponse=} [properties] Properties to set
             * @returns {kritor.group.SetGroupUniqueTitleResponse} SetGroupUniqueTitleResponse instance
             */
            SetGroupUniqueTitleResponse.create = function create(properties) {
                return new SetGroupUniqueTitleResponse(properties);
            };

            /**
             * Encodes the specified SetGroupUniqueTitleResponse message. Does not implicitly {@link kritor.group.SetGroupUniqueTitleResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleResponse} message SetGroupUniqueTitleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupUniqueTitleResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetGroupUniqueTitleResponse message, length delimited. Does not implicitly {@link kritor.group.SetGroupUniqueTitleResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleResponse} message SetGroupUniqueTitleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupUniqueTitleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupUniqueTitleResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupUniqueTitleResponse} SetGroupUniqueTitleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupUniqueTitleResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupUniqueTitleResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupUniqueTitleResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupUniqueTitleResponse} SetGroupUniqueTitleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupUniqueTitleResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupUniqueTitleResponse message.
             * @function verify
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupUniqueTitleResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetGroupUniqueTitleResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupUniqueTitleResponse} SetGroupUniqueTitleResponse
             */
            SetGroupUniqueTitleResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupUniqueTitleResponse)
                    return object;
                return new $root.kritor.group.SetGroupUniqueTitleResponse();
            };

            /**
             * Creates a plain object from a SetGroupUniqueTitleResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {kritor.group.SetGroupUniqueTitleResponse} message SetGroupUniqueTitleResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupUniqueTitleResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetGroupUniqueTitleResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupUniqueTitleResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupUniqueTitleResponse
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupUniqueTitleResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupUniqueTitleResponse";
            };

            return SetGroupUniqueTitleResponse;
        })();

        group.SetGroupWholeBanRequest = (function() {

            /**
             * Properties of a SetGroupWholeBanRequest.
             * @memberof kritor.group
             * @interface ISetGroupWholeBanRequest
             * @property {number|Long|null} [group_id] SetGroupWholeBanRequest group_id
             * @property {boolean|null} [is_ban] SetGroupWholeBanRequest is_ban
             */

            /**
             * Constructs a new SetGroupWholeBanRequest.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupWholeBanRequest.
             * @implements ISetGroupWholeBanRequest
             * @constructor
             * @param {kritor.group.ISetGroupWholeBanRequest=} [properties] Properties to set
             */
            function SetGroupWholeBanRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetGroupWholeBanRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @instance
             */
            SetGroupWholeBanRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetGroupWholeBanRequest is_ban.
             * @member {boolean} is_ban
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @instance
             */
            SetGroupWholeBanRequest.prototype.is_ban = false;

            /**
             * Creates a new SetGroupWholeBanRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {kritor.group.ISetGroupWholeBanRequest=} [properties] Properties to set
             * @returns {kritor.group.SetGroupWholeBanRequest} SetGroupWholeBanRequest instance
             */
            SetGroupWholeBanRequest.create = function create(properties) {
                return new SetGroupWholeBanRequest(properties);
            };

            /**
             * Encodes the specified SetGroupWholeBanRequest message. Does not implicitly {@link kritor.group.SetGroupWholeBanRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {kritor.group.ISetGroupWholeBanRequest} message SetGroupWholeBanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupWholeBanRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.is_ban != null && Object.hasOwnProperty.call(message, "is_ban"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_ban);
                return writer;
            };

            /**
             * Encodes the specified SetGroupWholeBanRequest message, length delimited. Does not implicitly {@link kritor.group.SetGroupWholeBanRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {kritor.group.ISetGroupWholeBanRequest} message SetGroupWholeBanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupWholeBanRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupWholeBanRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupWholeBanRequest} SetGroupWholeBanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupWholeBanRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupWholeBanRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.is_ban = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupWholeBanRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupWholeBanRequest} SetGroupWholeBanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupWholeBanRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupWholeBanRequest message.
             * @function verify
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupWholeBanRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.is_ban != null && message.hasOwnProperty("is_ban"))
                    if (typeof message.is_ban !== "boolean")
                        return "is_ban: boolean expected";
                return null;
            };

            /**
             * Creates a SetGroupWholeBanRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupWholeBanRequest} SetGroupWholeBanRequest
             */
            SetGroupWholeBanRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupWholeBanRequest)
                    return object;
                let message = new $root.kritor.group.SetGroupWholeBanRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.is_ban != null)
                    message.is_ban = Boolean(object.is_ban);
                return message;
            };

            /**
             * Creates a plain object from a SetGroupWholeBanRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {kritor.group.SetGroupWholeBanRequest} message SetGroupWholeBanRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupWholeBanRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.is_ban = false;
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.is_ban != null && message.hasOwnProperty("is_ban"))
                    object.is_ban = message.is_ban;
                return object;
            };

            /**
             * Converts this SetGroupWholeBanRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupWholeBanRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupWholeBanRequest
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupWholeBanRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupWholeBanRequest";
            };

            return SetGroupWholeBanRequest;
        })();

        group.SetGroupWholeBanResponse = (function() {

            /**
             * Properties of a SetGroupWholeBanResponse.
             * @memberof kritor.group
             * @interface ISetGroupWholeBanResponse
             */

            /**
             * Constructs a new SetGroupWholeBanResponse.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupWholeBanResponse.
             * @implements ISetGroupWholeBanResponse
             * @constructor
             * @param {kritor.group.ISetGroupWholeBanResponse=} [properties] Properties to set
             */
            function SetGroupWholeBanResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetGroupWholeBanResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {kritor.group.ISetGroupWholeBanResponse=} [properties] Properties to set
             * @returns {kritor.group.SetGroupWholeBanResponse} SetGroupWholeBanResponse instance
             */
            SetGroupWholeBanResponse.create = function create(properties) {
                return new SetGroupWholeBanResponse(properties);
            };

            /**
             * Encodes the specified SetGroupWholeBanResponse message. Does not implicitly {@link kritor.group.SetGroupWholeBanResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {kritor.group.ISetGroupWholeBanResponse} message SetGroupWholeBanResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupWholeBanResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetGroupWholeBanResponse message, length delimited. Does not implicitly {@link kritor.group.SetGroupWholeBanResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {kritor.group.ISetGroupWholeBanResponse} message SetGroupWholeBanResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupWholeBanResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupWholeBanResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupWholeBanResponse} SetGroupWholeBanResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupWholeBanResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupWholeBanResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupWholeBanResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupWholeBanResponse} SetGroupWholeBanResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupWholeBanResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupWholeBanResponse message.
             * @function verify
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupWholeBanResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetGroupWholeBanResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupWholeBanResponse} SetGroupWholeBanResponse
             */
            SetGroupWholeBanResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupWholeBanResponse)
                    return object;
                return new $root.kritor.group.SetGroupWholeBanResponse();
            };

            /**
             * Creates a plain object from a SetGroupWholeBanResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {kritor.group.SetGroupWholeBanResponse} message SetGroupWholeBanResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupWholeBanResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetGroupWholeBanResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupWholeBanResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupWholeBanResponse
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupWholeBanResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupWholeBanResponse";
            };

            return SetGroupWholeBanResponse;
        })();

        group.GetGroupInfoRequest = (function() {

            /**
             * Properties of a GetGroupInfoRequest.
             * @memberof kritor.group
             * @interface IGetGroupInfoRequest
             * @property {number|Long|null} [group_id] GetGroupInfoRequest group_id
             */

            /**
             * Constructs a new GetGroupInfoRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupInfoRequest.
             * @implements IGetGroupInfoRequest
             * @constructor
             * @param {kritor.group.IGetGroupInfoRequest=} [properties] Properties to set
             */
            function GetGroupInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupInfoRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.GetGroupInfoRequest
             * @instance
             */
            GetGroupInfoRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetGroupInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {kritor.group.IGetGroupInfoRequest=} [properties] Properties to set
             * @returns {kritor.group.GetGroupInfoRequest} GetGroupInfoRequest instance
             */
            GetGroupInfoRequest.create = function create(properties) {
                return new GetGroupInfoRequest(properties);
            };

            /**
             * Encodes the specified GetGroupInfoRequest message. Does not implicitly {@link kritor.group.GetGroupInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {kritor.group.IGetGroupInfoRequest} message GetGroupInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                return writer;
            };

            /**
             * Encodes the specified GetGroupInfoRequest message, length delimited. Does not implicitly {@link kritor.group.GetGroupInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {kritor.group.IGetGroupInfoRequest} message GetGroupInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupInfoRequest} GetGroupInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupInfoRequest} GetGroupInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupInfoRequest message.
             * @function verify
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetGroupInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupInfoRequest} GetGroupInfoRequest
             */
            GetGroupInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupInfoRequest)
                    return object;
                let message = new $root.kritor.group.GetGroupInfoRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetGroupInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {kritor.group.GetGroupInfoRequest} message GetGroupInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupInfoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                return object;
            };

            /**
             * Converts this GetGroupInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupInfoRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupInfoRequest";
            };

            return GetGroupInfoRequest;
        })();

        group.GetGroupInfoResponse = (function() {

            /**
             * Properties of a GetGroupInfoResponse.
             * @memberof kritor.group
             * @interface IGetGroupInfoResponse
             * @property {kritor.group.IGroupInfo|null} [group_info] GetGroupInfoResponse group_info
             */

            /**
             * Constructs a new GetGroupInfoResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupInfoResponse.
             * @implements IGetGroupInfoResponse
             * @constructor
             * @param {kritor.group.IGetGroupInfoResponse=} [properties] Properties to set
             */
            function GetGroupInfoResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupInfoResponse group_info.
             * @member {kritor.group.IGroupInfo|null|undefined} group_info
             * @memberof kritor.group.GetGroupInfoResponse
             * @instance
             */
            GetGroupInfoResponse.prototype.group_info = null;

            /**
             * Creates a new GetGroupInfoResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {kritor.group.IGetGroupInfoResponse=} [properties] Properties to set
             * @returns {kritor.group.GetGroupInfoResponse} GetGroupInfoResponse instance
             */
            GetGroupInfoResponse.create = function create(properties) {
                return new GetGroupInfoResponse(properties);
            };

            /**
             * Encodes the specified GetGroupInfoResponse message. Does not implicitly {@link kritor.group.GetGroupInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {kritor.group.IGetGroupInfoResponse} message GetGroupInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_info != null && Object.hasOwnProperty.call(message, "group_info"))
                    $root.kritor.group.GroupInfo.encode(message.group_info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGroupInfoResponse message, length delimited. Does not implicitly {@link kritor.group.GetGroupInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {kritor.group.IGetGroupInfoResponse} message GetGroupInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupInfoResponse} GetGroupInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupInfoResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_info = $root.kritor.group.GroupInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupInfoResponse} GetGroupInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupInfoResponse message.
             * @function verify
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_info != null && message.hasOwnProperty("group_info")) {
                    let error = $root.kritor.group.GroupInfo.verify(message.group_info);
                    if (error)
                        return "group_info." + error;
                }
                return null;
            };

            /**
             * Creates a GetGroupInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupInfoResponse} GetGroupInfoResponse
             */
            GetGroupInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupInfoResponse)
                    return object;
                let message = new $root.kritor.group.GetGroupInfoResponse();
                if (object.group_info != null) {
                    if (typeof object.group_info !== "object")
                        throw TypeError(".kritor.group.GetGroupInfoResponse.group_info: object expected");
                    message.group_info = $root.kritor.group.GroupInfo.fromObject(object.group_info);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGroupInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {kritor.group.GetGroupInfoResponse} message GetGroupInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.group_info = null;
                if (message.group_info != null && message.hasOwnProperty("group_info"))
                    object.group_info = $root.kritor.group.GroupInfo.toObject(message.group_info, options);
                return object;
            };

            /**
             * Converts this GetGroupInfoResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupInfoResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupInfoResponse";
            };

            return GetGroupInfoResponse;
        })();

        group.GetGroupListRequest = (function() {

            /**
             * Properties of a GetGroupListRequest.
             * @memberof kritor.group
             * @interface IGetGroupListRequest
             * @property {boolean|null} [refresh] GetGroupListRequest refresh
             */

            /**
             * Constructs a new GetGroupListRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupListRequest.
             * @implements IGetGroupListRequest
             * @constructor
             * @param {kritor.group.IGetGroupListRequest=} [properties] Properties to set
             */
            function GetGroupListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupListRequest refresh.
             * @member {boolean|null|undefined} refresh
             * @memberof kritor.group.GetGroupListRequest
             * @instance
             */
            GetGroupListRequest.prototype.refresh = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetGroupListRequest _refresh.
             * @member {"refresh"|undefined} _refresh
             * @memberof kritor.group.GetGroupListRequest
             * @instance
             */
            Object.defineProperty(GetGroupListRequest.prototype, "_refresh", {
                get: $util.oneOfGetter($oneOfFields = ["refresh"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetGroupListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {kritor.group.IGetGroupListRequest=} [properties] Properties to set
             * @returns {kritor.group.GetGroupListRequest} GetGroupListRequest instance
             */
            GetGroupListRequest.create = function create(properties) {
                return new GetGroupListRequest(properties);
            };

            /**
             * Encodes the specified GetGroupListRequest message. Does not implicitly {@link kritor.group.GetGroupListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {kritor.group.IGetGroupListRequest} message GetGroupListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGroupListRequest message, length delimited. Does not implicitly {@link kritor.group.GetGroupListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {kritor.group.IGetGroupListRequest} message GetGroupListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupListRequest} GetGroupListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupListRequest} GetGroupListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupListRequest message.
             * @function verify
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    properties._refresh = 1;
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetGroupListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupListRequest} GetGroupListRequest
             */
            GetGroupListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupListRequest)
                    return object;
                let message = new $root.kritor.group.GetGroupListRequest();
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGroupListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {kritor.group.GetGroupListRequest} message GetGroupListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    object.refresh = message.refresh;
                    if (options.oneofs)
                        object._refresh = "refresh";
                }
                return object;
            };

            /**
             * Converts this GetGroupListRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupListRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupListRequest";
            };

            return GetGroupListRequest;
        })();

        group.GetGroupListResponse = (function() {

            /**
             * Properties of a GetGroupListResponse.
             * @memberof kritor.group
             * @interface IGetGroupListResponse
             * @property {Array.<kritor.group.IGroupInfo>|null} [groups_info] GetGroupListResponse groups_info
             */

            /**
             * Constructs a new GetGroupListResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupListResponse.
             * @implements IGetGroupListResponse
             * @constructor
             * @param {kritor.group.IGetGroupListResponse=} [properties] Properties to set
             */
            function GetGroupListResponse(properties) {
                this.groups_info = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupListResponse groups_info.
             * @member {Array.<kritor.group.IGroupInfo>} groups_info
             * @memberof kritor.group.GetGroupListResponse
             * @instance
             */
            GetGroupListResponse.prototype.groups_info = $util.emptyArray;

            /**
             * Creates a new GetGroupListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {kritor.group.IGetGroupListResponse=} [properties] Properties to set
             * @returns {kritor.group.GetGroupListResponse} GetGroupListResponse instance
             */
            GetGroupListResponse.create = function create(properties) {
                return new GetGroupListResponse(properties);
            };

            /**
             * Encodes the specified GetGroupListResponse message. Does not implicitly {@link kritor.group.GetGroupListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {kritor.group.IGetGroupListResponse} message GetGroupListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groups_info != null && message.groups_info.length)
                    for (let i = 0; i < message.groups_info.length; ++i)
                        $root.kritor.group.GroupInfo.encode(message.groups_info[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGroupListResponse message, length delimited. Does not implicitly {@link kritor.group.GetGroupListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {kritor.group.IGetGroupListResponse} message GetGroupListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupListResponse} GetGroupListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.groups_info && message.groups_info.length))
                                message.groups_info = [];
                            message.groups_info.push($root.kritor.group.GroupInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupListResponse} GetGroupListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupListResponse message.
             * @function verify
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groups_info != null && message.hasOwnProperty("groups_info")) {
                    if (!Array.isArray(message.groups_info))
                        return "groups_info: array expected";
                    for (let i = 0; i < message.groups_info.length; ++i) {
                        let error = $root.kritor.group.GroupInfo.verify(message.groups_info[i]);
                        if (error)
                            return "groups_info." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetGroupListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupListResponse} GetGroupListResponse
             */
            GetGroupListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupListResponse)
                    return object;
                let message = new $root.kritor.group.GetGroupListResponse();
                if (object.groups_info) {
                    if (!Array.isArray(object.groups_info))
                        throw TypeError(".kritor.group.GetGroupListResponse.groups_info: array expected");
                    message.groups_info = [];
                    for (let i = 0; i < object.groups_info.length; ++i) {
                        if (typeof object.groups_info[i] !== "object")
                            throw TypeError(".kritor.group.GetGroupListResponse.groups_info: object expected");
                        message.groups_info[i] = $root.kritor.group.GroupInfo.fromObject(object.groups_info[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGroupListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {kritor.group.GetGroupListResponse} message GetGroupListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.groups_info = [];
                if (message.groups_info && message.groups_info.length) {
                    object.groups_info = [];
                    for (let j = 0; j < message.groups_info.length; ++j)
                        object.groups_info[j] = $root.kritor.group.GroupInfo.toObject(message.groups_info[j], options);
                }
                return object;
            };

            /**
             * Converts this GetGroupListResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupListResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupListResponse";
            };

            return GetGroupListResponse;
        })();

        group.GetGroupMemberInfoRequest = (function() {

            /**
             * Properties of a GetGroupMemberInfoRequest.
             * @memberof kritor.group
             * @interface IGetGroupMemberInfoRequest
             * @property {number|Long|null} [group_id] GetGroupMemberInfoRequest group_id
             * @property {string|null} [target_uid] GetGroupMemberInfoRequest target_uid
             * @property {number|Long|null} [target_uin] GetGroupMemberInfoRequest target_uin
             * @property {boolean|null} [refresh] GetGroupMemberInfoRequest refresh
             */

            /**
             * Constructs a new GetGroupMemberInfoRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupMemberInfoRequest.
             * @implements IGetGroupMemberInfoRequest
             * @constructor
             * @param {kritor.group.IGetGroupMemberInfoRequest=} [properties] Properties to set
             */
            function GetGroupMemberInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupMemberInfoRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            GetGroupMemberInfoRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGroupMemberInfoRequest target_uid.
             * @member {string|null|undefined} target_uid
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            GetGroupMemberInfoRequest.prototype.target_uid = null;

            /**
             * GetGroupMemberInfoRequest target_uin.
             * @member {number|Long|null|undefined} target_uin
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            GetGroupMemberInfoRequest.prototype.target_uin = null;

            /**
             * GetGroupMemberInfoRequest refresh.
             * @member {boolean|null|undefined} refresh
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            GetGroupMemberInfoRequest.prototype.refresh = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetGroupMemberInfoRequest target.
             * @member {"target_uid"|"target_uin"|undefined} target
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            Object.defineProperty(GetGroupMemberInfoRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["target_uid", "target_uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GetGroupMemberInfoRequest _refresh.
             * @member {"refresh"|undefined} _refresh
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            Object.defineProperty(GetGroupMemberInfoRequest.prototype, "_refresh", {
                get: $util.oneOfGetter($oneOfFields = ["refresh"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetGroupMemberInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {kritor.group.IGetGroupMemberInfoRequest=} [properties] Properties to set
             * @returns {kritor.group.GetGroupMemberInfoRequest} GetGroupMemberInfoRequest instance
             */
            GetGroupMemberInfoRequest.create = function create(properties) {
                return new GetGroupMemberInfoRequest(properties);
            };

            /**
             * Encodes the specified GetGroupMemberInfoRequest message. Does not implicitly {@link kritor.group.GetGroupMemberInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {kritor.group.IGetGroupMemberInfoRequest} message GetGroupMemberInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.target_uid != null && Object.hasOwnProperty.call(message, "target_uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.target_uid);
                if (message.target_uin != null && Object.hasOwnProperty.call(message, "target_uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.target_uin);
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGroupMemberInfoRequest message, length delimited. Does not implicitly {@link kritor.group.GetGroupMemberInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {kritor.group.IGetGroupMemberInfoRequest} message GetGroupMemberInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupMemberInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupMemberInfoRequest} GetGroupMemberInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupMemberInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.target_uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.target_uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupMemberInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupMemberInfoRequest} GetGroupMemberInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupMemberInfoRequest message.
             * @function verify
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupMemberInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    properties.target = 1;
                    if (!$util.isString(message.target_uid))
                        return "target_uid: string expected";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.target_uin) && !(message.target_uin && $util.isInteger(message.target_uin.low) && $util.isInteger(message.target_uin.high)))
                        return "target_uin: integer|Long expected";
                }
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    properties._refresh = 1;
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetGroupMemberInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupMemberInfoRequest} GetGroupMemberInfoRequest
             */
            GetGroupMemberInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupMemberInfoRequest)
                    return object;
                let message = new $root.kritor.group.GetGroupMemberInfoRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.target_uid != null)
                    message.target_uid = String(object.target_uid);
                if (object.target_uin != null)
                    if ($util.Long)
                        (message.target_uin = $util.Long.fromValue(object.target_uin)).unsigned = true;
                    else if (typeof object.target_uin === "string")
                        message.target_uin = parseInt(object.target_uin, 10);
                    else if (typeof object.target_uin === "number")
                        message.target_uin = object.target_uin;
                    else if (typeof object.target_uin === "object")
                        message.target_uin = new $util.LongBits(object.target_uin.low >>> 0, object.target_uin.high >>> 0).toNumber(true);
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGroupMemberInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {kritor.group.GetGroupMemberInfoRequest} message GetGroupMemberInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupMemberInfoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.target_uid != null && message.hasOwnProperty("target_uid")) {
                    object.target_uid = message.target_uid;
                    if (options.oneofs)
                        object.target = "target_uid";
                }
                if (message.target_uin != null && message.hasOwnProperty("target_uin")) {
                    if (typeof message.target_uin === "number")
                        object.target_uin = options.longs === String ? String(message.target_uin) : message.target_uin;
                    else
                        object.target_uin = options.longs === String ? $util.Long.prototype.toString.call(message.target_uin) : options.longs === Number ? new $util.LongBits(message.target_uin.low >>> 0, message.target_uin.high >>> 0).toNumber(true) : message.target_uin;
                    if (options.oneofs)
                        object.target = "target_uin";
                }
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    object.refresh = message.refresh;
                    if (options.oneofs)
                        object._refresh = "refresh";
                }
                return object;
            };

            /**
             * Converts this GetGroupMemberInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupMemberInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupMemberInfoRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupMemberInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupMemberInfoRequest";
            };

            return GetGroupMemberInfoRequest;
        })();

        group.GetGroupMemberInfoResponse = (function() {

            /**
             * Properties of a GetGroupMemberInfoResponse.
             * @memberof kritor.group
             * @interface IGetGroupMemberInfoResponse
             * @property {kritor.group.IGroupMemberInfo|null} [group_member_info] GetGroupMemberInfoResponse group_member_info
             */

            /**
             * Constructs a new GetGroupMemberInfoResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupMemberInfoResponse.
             * @implements IGetGroupMemberInfoResponse
             * @constructor
             * @param {kritor.group.IGetGroupMemberInfoResponse=} [properties] Properties to set
             */
            function GetGroupMemberInfoResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupMemberInfoResponse group_member_info.
             * @member {kritor.group.IGroupMemberInfo|null|undefined} group_member_info
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @instance
             */
            GetGroupMemberInfoResponse.prototype.group_member_info = null;

            /**
             * Creates a new GetGroupMemberInfoResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {kritor.group.IGetGroupMemberInfoResponse=} [properties] Properties to set
             * @returns {kritor.group.GetGroupMemberInfoResponse} GetGroupMemberInfoResponse instance
             */
            GetGroupMemberInfoResponse.create = function create(properties) {
                return new GetGroupMemberInfoResponse(properties);
            };

            /**
             * Encodes the specified GetGroupMemberInfoResponse message. Does not implicitly {@link kritor.group.GetGroupMemberInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {kritor.group.IGetGroupMemberInfoResponse} message GetGroupMemberInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_member_info != null && Object.hasOwnProperty.call(message, "group_member_info"))
                    $root.kritor.group.GroupMemberInfo.encode(message.group_member_info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGroupMemberInfoResponse message, length delimited. Does not implicitly {@link kritor.group.GetGroupMemberInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {kritor.group.IGetGroupMemberInfoResponse} message GetGroupMemberInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupMemberInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupMemberInfoResponse} GetGroupMemberInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupMemberInfoResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_member_info = $root.kritor.group.GroupMemberInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupMemberInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupMemberInfoResponse} GetGroupMemberInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupMemberInfoResponse message.
             * @function verify
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupMemberInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_member_info != null && message.hasOwnProperty("group_member_info")) {
                    let error = $root.kritor.group.GroupMemberInfo.verify(message.group_member_info);
                    if (error)
                        return "group_member_info." + error;
                }
                return null;
            };

            /**
             * Creates a GetGroupMemberInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupMemberInfoResponse} GetGroupMemberInfoResponse
             */
            GetGroupMemberInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupMemberInfoResponse)
                    return object;
                let message = new $root.kritor.group.GetGroupMemberInfoResponse();
                if (object.group_member_info != null) {
                    if (typeof object.group_member_info !== "object")
                        throw TypeError(".kritor.group.GetGroupMemberInfoResponse.group_member_info: object expected");
                    message.group_member_info = $root.kritor.group.GroupMemberInfo.fromObject(object.group_member_info);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGroupMemberInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {kritor.group.GetGroupMemberInfoResponse} message GetGroupMemberInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupMemberInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.group_member_info = null;
                if (message.group_member_info != null && message.hasOwnProperty("group_member_info"))
                    object.group_member_info = $root.kritor.group.GroupMemberInfo.toObject(message.group_member_info, options);
                return object;
            };

            /**
             * Converts this GetGroupMemberInfoResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupMemberInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupMemberInfoResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupMemberInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupMemberInfoResponse";
            };

            return GetGroupMemberInfoResponse;
        })();

        group.GetGroupMemberListRequest = (function() {

            /**
             * Properties of a GetGroupMemberListRequest.
             * @memberof kritor.group
             * @interface IGetGroupMemberListRequest
             * @property {number|Long|null} [group_id] GetGroupMemberListRequest group_id
             * @property {boolean|null} [refresh] GetGroupMemberListRequest refresh
             */

            /**
             * Constructs a new GetGroupMemberListRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupMemberListRequest.
             * @implements IGetGroupMemberListRequest
             * @constructor
             * @param {kritor.group.IGetGroupMemberListRequest=} [properties] Properties to set
             */
            function GetGroupMemberListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupMemberListRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.GetGroupMemberListRequest
             * @instance
             */
            GetGroupMemberListRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGroupMemberListRequest refresh.
             * @member {boolean|null|undefined} refresh
             * @memberof kritor.group.GetGroupMemberListRequest
             * @instance
             */
            GetGroupMemberListRequest.prototype.refresh = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetGroupMemberListRequest _refresh.
             * @member {"refresh"|undefined} _refresh
             * @memberof kritor.group.GetGroupMemberListRequest
             * @instance
             */
            Object.defineProperty(GetGroupMemberListRequest.prototype, "_refresh", {
                get: $util.oneOfGetter($oneOfFields = ["refresh"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetGroupMemberListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {kritor.group.IGetGroupMemberListRequest=} [properties] Properties to set
             * @returns {kritor.group.GetGroupMemberListRequest} GetGroupMemberListRequest instance
             */
            GetGroupMemberListRequest.create = function create(properties) {
                return new GetGroupMemberListRequest(properties);
            };

            /**
             * Encodes the specified GetGroupMemberListRequest message. Does not implicitly {@link kritor.group.GetGroupMemberListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {kritor.group.IGetGroupMemberListRequest} message GetGroupMemberListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGroupMemberListRequest message, length delimited. Does not implicitly {@link kritor.group.GetGroupMemberListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {kritor.group.IGetGroupMemberListRequest} message GetGroupMemberListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupMemberListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupMemberListRequest} GetGroupMemberListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupMemberListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupMemberListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupMemberListRequest} GetGroupMemberListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupMemberListRequest message.
             * @function verify
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupMemberListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    properties._refresh = 1;
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetGroupMemberListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupMemberListRequest} GetGroupMemberListRequest
             */
            GetGroupMemberListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupMemberListRequest)
                    return object;
                let message = new $root.kritor.group.GetGroupMemberListRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGroupMemberListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {kritor.group.GetGroupMemberListRequest} message GetGroupMemberListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupMemberListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    object.refresh = message.refresh;
                    if (options.oneofs)
                        object._refresh = "refresh";
                }
                return object;
            };

            /**
             * Converts this GetGroupMemberListRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupMemberListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupMemberListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupMemberListRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupMemberListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupMemberListRequest";
            };

            return GetGroupMemberListRequest;
        })();

        group.GetGroupMemberListResponse = (function() {

            /**
             * Properties of a GetGroupMemberListResponse.
             * @memberof kritor.group
             * @interface IGetGroupMemberListResponse
             * @property {Array.<kritor.group.IGroupMemberInfo>|null} [group_members_info] GetGroupMemberListResponse group_members_info
             */

            /**
             * Constructs a new GetGroupMemberListResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupMemberListResponse.
             * @implements IGetGroupMemberListResponse
             * @constructor
             * @param {kritor.group.IGetGroupMemberListResponse=} [properties] Properties to set
             */
            function GetGroupMemberListResponse(properties) {
                this.group_members_info = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupMemberListResponse group_members_info.
             * @member {Array.<kritor.group.IGroupMemberInfo>} group_members_info
             * @memberof kritor.group.GetGroupMemberListResponse
             * @instance
             */
            GetGroupMemberListResponse.prototype.group_members_info = $util.emptyArray;

            /**
             * Creates a new GetGroupMemberListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {kritor.group.IGetGroupMemberListResponse=} [properties] Properties to set
             * @returns {kritor.group.GetGroupMemberListResponse} GetGroupMemberListResponse instance
             */
            GetGroupMemberListResponse.create = function create(properties) {
                return new GetGroupMemberListResponse(properties);
            };

            /**
             * Encodes the specified GetGroupMemberListResponse message. Does not implicitly {@link kritor.group.GetGroupMemberListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {kritor.group.IGetGroupMemberListResponse} message GetGroupMemberListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_members_info != null && message.group_members_info.length)
                    for (let i = 0; i < message.group_members_info.length; ++i)
                        $root.kritor.group.GroupMemberInfo.encode(message.group_members_info[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGroupMemberListResponse message, length delimited. Does not implicitly {@link kritor.group.GetGroupMemberListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {kritor.group.IGetGroupMemberListResponse} message GetGroupMemberListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupMemberListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupMemberListResponse} GetGroupMemberListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupMemberListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.group_members_info && message.group_members_info.length))
                                message.group_members_info = [];
                            message.group_members_info.push($root.kritor.group.GroupMemberInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupMemberListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupMemberListResponse} GetGroupMemberListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupMemberListResponse message.
             * @function verify
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupMemberListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_members_info != null && message.hasOwnProperty("group_members_info")) {
                    if (!Array.isArray(message.group_members_info))
                        return "group_members_info: array expected";
                    for (let i = 0; i < message.group_members_info.length; ++i) {
                        let error = $root.kritor.group.GroupMemberInfo.verify(message.group_members_info[i]);
                        if (error)
                            return "group_members_info." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetGroupMemberListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupMemberListResponse} GetGroupMemberListResponse
             */
            GetGroupMemberListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupMemberListResponse)
                    return object;
                let message = new $root.kritor.group.GetGroupMemberListResponse();
                if (object.group_members_info) {
                    if (!Array.isArray(object.group_members_info))
                        throw TypeError(".kritor.group.GetGroupMemberListResponse.group_members_info: array expected");
                    message.group_members_info = [];
                    for (let i = 0; i < object.group_members_info.length; ++i) {
                        if (typeof object.group_members_info[i] !== "object")
                            throw TypeError(".kritor.group.GetGroupMemberListResponse.group_members_info: object expected");
                        message.group_members_info[i] = $root.kritor.group.GroupMemberInfo.fromObject(object.group_members_info[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGroupMemberListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {kritor.group.GetGroupMemberListResponse} message GetGroupMemberListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupMemberListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.group_members_info = [];
                if (message.group_members_info && message.group_members_info.length) {
                    object.group_members_info = [];
                    for (let j = 0; j < message.group_members_info.length; ++j)
                        object.group_members_info[j] = $root.kritor.group.GroupMemberInfo.toObject(message.group_members_info[j], options);
                }
                return object;
            };

            /**
             * Converts this GetGroupMemberListResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupMemberListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupMemberListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupMemberListResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupMemberListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupMemberListResponse";
            };

            return GetGroupMemberListResponse;
        })();

        group.GetProhibitedUserListRequest = (function() {

            /**
             * Properties of a GetProhibitedUserListRequest.
             * @memberof kritor.group
             * @interface IGetProhibitedUserListRequest
             * @property {number|Long|null} [group_id] GetProhibitedUserListRequest group_id
             */

            /**
             * Constructs a new GetProhibitedUserListRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetProhibitedUserListRequest.
             * @implements IGetProhibitedUserListRequest
             * @constructor
             * @param {kritor.group.IGetProhibitedUserListRequest=} [properties] Properties to set
             */
            function GetProhibitedUserListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetProhibitedUserListRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @instance
             */
            GetProhibitedUserListRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetProhibitedUserListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {kritor.group.IGetProhibitedUserListRequest=} [properties] Properties to set
             * @returns {kritor.group.GetProhibitedUserListRequest} GetProhibitedUserListRequest instance
             */
            GetProhibitedUserListRequest.create = function create(properties) {
                return new GetProhibitedUserListRequest(properties);
            };

            /**
             * Encodes the specified GetProhibitedUserListRequest message. Does not implicitly {@link kritor.group.GetProhibitedUserListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {kritor.group.IGetProhibitedUserListRequest} message GetProhibitedUserListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProhibitedUserListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                return writer;
            };

            /**
             * Encodes the specified GetProhibitedUserListRequest message, length delimited. Does not implicitly {@link kritor.group.GetProhibitedUserListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {kritor.group.IGetProhibitedUserListRequest} message GetProhibitedUserListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProhibitedUserListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetProhibitedUserListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetProhibitedUserListRequest} GetProhibitedUserListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProhibitedUserListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetProhibitedUserListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetProhibitedUserListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetProhibitedUserListRequest} GetProhibitedUserListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProhibitedUserListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetProhibitedUserListRequest message.
             * @function verify
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetProhibitedUserListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetProhibitedUserListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetProhibitedUserListRequest} GetProhibitedUserListRequest
             */
            GetProhibitedUserListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetProhibitedUserListRequest)
                    return object;
                let message = new $root.kritor.group.GetProhibitedUserListRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetProhibitedUserListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {kritor.group.GetProhibitedUserListRequest} message GetProhibitedUserListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetProhibitedUserListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                return object;
            };

            /**
             * Converts this GetProhibitedUserListRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetProhibitedUserListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetProhibitedUserListRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetProhibitedUserListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetProhibitedUserListRequest";
            };

            return GetProhibitedUserListRequest;
        })();

        group.GetProhibitedUserListResponse = (function() {

            /**
             * Properties of a GetProhibitedUserListResponse.
             * @memberof kritor.group
             * @interface IGetProhibitedUserListResponse
             * @property {Array.<kritor.group.IProhibitedUserInfo>|null} [prohibited_users_info] GetProhibitedUserListResponse prohibited_users_info
             */

            /**
             * Constructs a new GetProhibitedUserListResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetProhibitedUserListResponse.
             * @implements IGetProhibitedUserListResponse
             * @constructor
             * @param {kritor.group.IGetProhibitedUserListResponse=} [properties] Properties to set
             */
            function GetProhibitedUserListResponse(properties) {
                this.prohibited_users_info = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetProhibitedUserListResponse prohibited_users_info.
             * @member {Array.<kritor.group.IProhibitedUserInfo>} prohibited_users_info
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @instance
             */
            GetProhibitedUserListResponse.prototype.prohibited_users_info = $util.emptyArray;

            /**
             * Creates a new GetProhibitedUserListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {kritor.group.IGetProhibitedUserListResponse=} [properties] Properties to set
             * @returns {kritor.group.GetProhibitedUserListResponse} GetProhibitedUserListResponse instance
             */
            GetProhibitedUserListResponse.create = function create(properties) {
                return new GetProhibitedUserListResponse(properties);
            };

            /**
             * Encodes the specified GetProhibitedUserListResponse message. Does not implicitly {@link kritor.group.GetProhibitedUserListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {kritor.group.IGetProhibitedUserListResponse} message GetProhibitedUserListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProhibitedUserListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.prohibited_users_info != null && message.prohibited_users_info.length)
                    for (let i = 0; i < message.prohibited_users_info.length; ++i)
                        $root.kritor.group.ProhibitedUserInfo.encode(message.prohibited_users_info[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetProhibitedUserListResponse message, length delimited. Does not implicitly {@link kritor.group.GetProhibitedUserListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {kritor.group.IGetProhibitedUserListResponse} message GetProhibitedUserListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProhibitedUserListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetProhibitedUserListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetProhibitedUserListResponse} GetProhibitedUserListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProhibitedUserListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetProhibitedUserListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.prohibited_users_info && message.prohibited_users_info.length))
                                message.prohibited_users_info = [];
                            message.prohibited_users_info.push($root.kritor.group.ProhibitedUserInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetProhibitedUserListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetProhibitedUserListResponse} GetProhibitedUserListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProhibitedUserListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetProhibitedUserListResponse message.
             * @function verify
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetProhibitedUserListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.prohibited_users_info != null && message.hasOwnProperty("prohibited_users_info")) {
                    if (!Array.isArray(message.prohibited_users_info))
                        return "prohibited_users_info: array expected";
                    for (let i = 0; i < message.prohibited_users_info.length; ++i) {
                        let error = $root.kritor.group.ProhibitedUserInfo.verify(message.prohibited_users_info[i]);
                        if (error)
                            return "prohibited_users_info." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetProhibitedUserListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetProhibitedUserListResponse} GetProhibitedUserListResponse
             */
            GetProhibitedUserListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetProhibitedUserListResponse)
                    return object;
                let message = new $root.kritor.group.GetProhibitedUserListResponse();
                if (object.prohibited_users_info) {
                    if (!Array.isArray(object.prohibited_users_info))
                        throw TypeError(".kritor.group.GetProhibitedUserListResponse.prohibited_users_info: array expected");
                    message.prohibited_users_info = [];
                    for (let i = 0; i < object.prohibited_users_info.length; ++i) {
                        if (typeof object.prohibited_users_info[i] !== "object")
                            throw TypeError(".kritor.group.GetProhibitedUserListResponse.prohibited_users_info: object expected");
                        message.prohibited_users_info[i] = $root.kritor.group.ProhibitedUserInfo.fromObject(object.prohibited_users_info[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetProhibitedUserListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {kritor.group.GetProhibitedUserListResponse} message GetProhibitedUserListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetProhibitedUserListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.prohibited_users_info = [];
                if (message.prohibited_users_info && message.prohibited_users_info.length) {
                    object.prohibited_users_info = [];
                    for (let j = 0; j < message.prohibited_users_info.length; ++j)
                        object.prohibited_users_info[j] = $root.kritor.group.ProhibitedUserInfo.toObject(message.prohibited_users_info[j], options);
                }
                return object;
            };

            /**
             * Converts this GetProhibitedUserListResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetProhibitedUserListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetProhibitedUserListResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetProhibitedUserListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetProhibitedUserListResponse";
            };

            return GetProhibitedUserListResponse;
        })();

        group.GetRemainCountAtAllRequest = (function() {

            /**
             * Properties of a GetRemainCountAtAllRequest.
             * @memberof kritor.group
             * @interface IGetRemainCountAtAllRequest
             * @property {number|Long|null} [group_id] GetRemainCountAtAllRequest group_id
             */

            /**
             * Constructs a new GetRemainCountAtAllRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetRemainCountAtAllRequest.
             * @implements IGetRemainCountAtAllRequest
             * @constructor
             * @param {kritor.group.IGetRemainCountAtAllRequest=} [properties] Properties to set
             */
            function GetRemainCountAtAllRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRemainCountAtAllRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @instance
             */
            GetRemainCountAtAllRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetRemainCountAtAllRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {kritor.group.IGetRemainCountAtAllRequest=} [properties] Properties to set
             * @returns {kritor.group.GetRemainCountAtAllRequest} GetRemainCountAtAllRequest instance
             */
            GetRemainCountAtAllRequest.create = function create(properties) {
                return new GetRemainCountAtAllRequest(properties);
            };

            /**
             * Encodes the specified GetRemainCountAtAllRequest message. Does not implicitly {@link kritor.group.GetRemainCountAtAllRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {kritor.group.IGetRemainCountAtAllRequest} message GetRemainCountAtAllRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRemainCountAtAllRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                return writer;
            };

            /**
             * Encodes the specified GetRemainCountAtAllRequest message, length delimited. Does not implicitly {@link kritor.group.GetRemainCountAtAllRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {kritor.group.IGetRemainCountAtAllRequest} message GetRemainCountAtAllRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRemainCountAtAllRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRemainCountAtAllRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetRemainCountAtAllRequest} GetRemainCountAtAllRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRemainCountAtAllRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetRemainCountAtAllRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRemainCountAtAllRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetRemainCountAtAllRequest} GetRemainCountAtAllRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRemainCountAtAllRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRemainCountAtAllRequest message.
             * @function verify
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRemainCountAtAllRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetRemainCountAtAllRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetRemainCountAtAllRequest} GetRemainCountAtAllRequest
             */
            GetRemainCountAtAllRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetRemainCountAtAllRequest)
                    return object;
                let message = new $root.kritor.group.GetRemainCountAtAllRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetRemainCountAtAllRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {kritor.group.GetRemainCountAtAllRequest} message GetRemainCountAtAllRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRemainCountAtAllRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                return object;
            };

            /**
             * Converts this GetRemainCountAtAllRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRemainCountAtAllRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetRemainCountAtAllRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetRemainCountAtAllRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetRemainCountAtAllRequest";
            };

            return GetRemainCountAtAllRequest;
        })();

        group.GetRemainCountAtAllResponse = (function() {

            /**
             * Properties of a GetRemainCountAtAllResponse.
             * @memberof kritor.group
             * @interface IGetRemainCountAtAllResponse
             * @property {boolean|null} [access_at_all] GetRemainCountAtAllResponse access_at_all
             * @property {number|null} [remain_count_for_group] GetRemainCountAtAllResponse remain_count_for_group
             * @property {number|null} [remain_count_for_self] GetRemainCountAtAllResponse remain_count_for_self
             */

            /**
             * Constructs a new GetRemainCountAtAllResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetRemainCountAtAllResponse.
             * @implements IGetRemainCountAtAllResponse
             * @constructor
             * @param {kritor.group.IGetRemainCountAtAllResponse=} [properties] Properties to set
             */
            function GetRemainCountAtAllResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRemainCountAtAllResponse access_at_all.
             * @member {boolean} access_at_all
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @instance
             */
            GetRemainCountAtAllResponse.prototype.access_at_all = false;

            /**
             * GetRemainCountAtAllResponse remain_count_for_group.
             * @member {number} remain_count_for_group
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @instance
             */
            GetRemainCountAtAllResponse.prototype.remain_count_for_group = 0;

            /**
             * GetRemainCountAtAllResponse remain_count_for_self.
             * @member {number} remain_count_for_self
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @instance
             */
            GetRemainCountAtAllResponse.prototype.remain_count_for_self = 0;

            /**
             * Creates a new GetRemainCountAtAllResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {kritor.group.IGetRemainCountAtAllResponse=} [properties] Properties to set
             * @returns {kritor.group.GetRemainCountAtAllResponse} GetRemainCountAtAllResponse instance
             */
            GetRemainCountAtAllResponse.create = function create(properties) {
                return new GetRemainCountAtAllResponse(properties);
            };

            /**
             * Encodes the specified GetRemainCountAtAllResponse message. Does not implicitly {@link kritor.group.GetRemainCountAtAllResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {kritor.group.IGetRemainCountAtAllResponse} message GetRemainCountAtAllResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRemainCountAtAllResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.access_at_all != null && Object.hasOwnProperty.call(message, "access_at_all"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.access_at_all);
                if (message.remain_count_for_group != null && Object.hasOwnProperty.call(message, "remain_count_for_group"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.remain_count_for_group);
                if (message.remain_count_for_self != null && Object.hasOwnProperty.call(message, "remain_count_for_self"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.remain_count_for_self);
                return writer;
            };

            /**
             * Encodes the specified GetRemainCountAtAllResponse message, length delimited. Does not implicitly {@link kritor.group.GetRemainCountAtAllResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {kritor.group.IGetRemainCountAtAllResponse} message GetRemainCountAtAllResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRemainCountAtAllResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRemainCountAtAllResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetRemainCountAtAllResponse} GetRemainCountAtAllResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRemainCountAtAllResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetRemainCountAtAllResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.access_at_all = reader.bool();
                            break;
                        }
                    case 2: {
                            message.remain_count_for_group = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.remain_count_for_self = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRemainCountAtAllResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetRemainCountAtAllResponse} GetRemainCountAtAllResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRemainCountAtAllResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRemainCountAtAllResponse message.
             * @function verify
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRemainCountAtAllResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.access_at_all != null && message.hasOwnProperty("access_at_all"))
                    if (typeof message.access_at_all !== "boolean")
                        return "access_at_all: boolean expected";
                if (message.remain_count_for_group != null && message.hasOwnProperty("remain_count_for_group"))
                    if (!$util.isInteger(message.remain_count_for_group))
                        return "remain_count_for_group: integer expected";
                if (message.remain_count_for_self != null && message.hasOwnProperty("remain_count_for_self"))
                    if (!$util.isInteger(message.remain_count_for_self))
                        return "remain_count_for_self: integer expected";
                return null;
            };

            /**
             * Creates a GetRemainCountAtAllResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetRemainCountAtAllResponse} GetRemainCountAtAllResponse
             */
            GetRemainCountAtAllResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetRemainCountAtAllResponse)
                    return object;
                let message = new $root.kritor.group.GetRemainCountAtAllResponse();
                if (object.access_at_all != null)
                    message.access_at_all = Boolean(object.access_at_all);
                if (object.remain_count_for_group != null)
                    message.remain_count_for_group = object.remain_count_for_group >>> 0;
                if (object.remain_count_for_self != null)
                    message.remain_count_for_self = object.remain_count_for_self >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetRemainCountAtAllResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {kritor.group.GetRemainCountAtAllResponse} message GetRemainCountAtAllResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRemainCountAtAllResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.access_at_all = false;
                    object.remain_count_for_group = 0;
                    object.remain_count_for_self = 0;
                }
                if (message.access_at_all != null && message.hasOwnProperty("access_at_all"))
                    object.access_at_all = message.access_at_all;
                if (message.remain_count_for_group != null && message.hasOwnProperty("remain_count_for_group"))
                    object.remain_count_for_group = message.remain_count_for_group;
                if (message.remain_count_for_self != null && message.hasOwnProperty("remain_count_for_self"))
                    object.remain_count_for_self = message.remain_count_for_self;
                return object;
            };

            /**
             * Converts this GetRemainCountAtAllResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRemainCountAtAllResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetRemainCountAtAllResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetRemainCountAtAllResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetRemainCountAtAllResponse";
            };

            return GetRemainCountAtAllResponse;
        })();

        group.GetNotJoinedGroupInfoRequest = (function() {

            /**
             * Properties of a GetNotJoinedGroupInfoRequest.
             * @memberof kritor.group
             * @interface IGetNotJoinedGroupInfoRequest
             * @property {number|Long|null} [group_id] GetNotJoinedGroupInfoRequest group_id
             */

            /**
             * Constructs a new GetNotJoinedGroupInfoRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetNotJoinedGroupInfoRequest.
             * @implements IGetNotJoinedGroupInfoRequest
             * @constructor
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest=} [properties] Properties to set
             */
            function GetNotJoinedGroupInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetNotJoinedGroupInfoRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @instance
             */
            GetNotJoinedGroupInfoRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetNotJoinedGroupInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest=} [properties] Properties to set
             * @returns {kritor.group.GetNotJoinedGroupInfoRequest} GetNotJoinedGroupInfoRequest instance
             */
            GetNotJoinedGroupInfoRequest.create = function create(properties) {
                return new GetNotJoinedGroupInfoRequest(properties);
            };

            /**
             * Encodes the specified GetNotJoinedGroupInfoRequest message. Does not implicitly {@link kritor.group.GetNotJoinedGroupInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest} message GetNotJoinedGroupInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetNotJoinedGroupInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                return writer;
            };

            /**
             * Encodes the specified GetNotJoinedGroupInfoRequest message, length delimited. Does not implicitly {@link kritor.group.GetNotJoinedGroupInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest} message GetNotJoinedGroupInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetNotJoinedGroupInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetNotJoinedGroupInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetNotJoinedGroupInfoRequest} GetNotJoinedGroupInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetNotJoinedGroupInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetNotJoinedGroupInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetNotJoinedGroupInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetNotJoinedGroupInfoRequest} GetNotJoinedGroupInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetNotJoinedGroupInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetNotJoinedGroupInfoRequest message.
             * @function verify
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetNotJoinedGroupInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetNotJoinedGroupInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetNotJoinedGroupInfoRequest} GetNotJoinedGroupInfoRequest
             */
            GetNotJoinedGroupInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetNotJoinedGroupInfoRequest)
                    return object;
                let message = new $root.kritor.group.GetNotJoinedGroupInfoRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetNotJoinedGroupInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {kritor.group.GetNotJoinedGroupInfoRequest} message GetNotJoinedGroupInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetNotJoinedGroupInfoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                return object;
            };

            /**
             * Converts this GetNotJoinedGroupInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetNotJoinedGroupInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetNotJoinedGroupInfoRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetNotJoinedGroupInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetNotJoinedGroupInfoRequest";
            };

            return GetNotJoinedGroupInfoRequest;
        })();

        group.GetNotJoinedGroupInfoResponse = (function() {

            /**
             * Properties of a GetNotJoinedGroupInfoResponse.
             * @memberof kritor.group
             * @interface IGetNotJoinedGroupInfoResponse
             * @property {kritor.group.INotJoinedGroupInfo|null} [group_info] GetNotJoinedGroupInfoResponse group_info
             */

            /**
             * Constructs a new GetNotJoinedGroupInfoResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetNotJoinedGroupInfoResponse.
             * @implements IGetNotJoinedGroupInfoResponse
             * @constructor
             * @param {kritor.group.IGetNotJoinedGroupInfoResponse=} [properties] Properties to set
             */
            function GetNotJoinedGroupInfoResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetNotJoinedGroupInfoResponse group_info.
             * @member {kritor.group.INotJoinedGroupInfo|null|undefined} group_info
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @instance
             */
            GetNotJoinedGroupInfoResponse.prototype.group_info = null;

            /**
             * Creates a new GetNotJoinedGroupInfoResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoResponse=} [properties] Properties to set
             * @returns {kritor.group.GetNotJoinedGroupInfoResponse} GetNotJoinedGroupInfoResponse instance
             */
            GetNotJoinedGroupInfoResponse.create = function create(properties) {
                return new GetNotJoinedGroupInfoResponse(properties);
            };

            /**
             * Encodes the specified GetNotJoinedGroupInfoResponse message. Does not implicitly {@link kritor.group.GetNotJoinedGroupInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoResponse} message GetNotJoinedGroupInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetNotJoinedGroupInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_info != null && Object.hasOwnProperty.call(message, "group_info"))
                    $root.kritor.group.NotJoinedGroupInfo.encode(message.group_info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetNotJoinedGroupInfoResponse message, length delimited. Does not implicitly {@link kritor.group.GetNotJoinedGroupInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoResponse} message GetNotJoinedGroupInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetNotJoinedGroupInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetNotJoinedGroupInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetNotJoinedGroupInfoResponse} GetNotJoinedGroupInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetNotJoinedGroupInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetNotJoinedGroupInfoResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_info = $root.kritor.group.NotJoinedGroupInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetNotJoinedGroupInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetNotJoinedGroupInfoResponse} GetNotJoinedGroupInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetNotJoinedGroupInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetNotJoinedGroupInfoResponse message.
             * @function verify
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetNotJoinedGroupInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_info != null && message.hasOwnProperty("group_info")) {
                    let error = $root.kritor.group.NotJoinedGroupInfo.verify(message.group_info);
                    if (error)
                        return "group_info." + error;
                }
                return null;
            };

            /**
             * Creates a GetNotJoinedGroupInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetNotJoinedGroupInfoResponse} GetNotJoinedGroupInfoResponse
             */
            GetNotJoinedGroupInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetNotJoinedGroupInfoResponse)
                    return object;
                let message = new $root.kritor.group.GetNotJoinedGroupInfoResponse();
                if (object.group_info != null) {
                    if (typeof object.group_info !== "object")
                        throw TypeError(".kritor.group.GetNotJoinedGroupInfoResponse.group_info: object expected");
                    message.group_info = $root.kritor.group.NotJoinedGroupInfo.fromObject(object.group_info);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetNotJoinedGroupInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {kritor.group.GetNotJoinedGroupInfoResponse} message GetNotJoinedGroupInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetNotJoinedGroupInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.group_info = null;
                if (message.group_info != null && message.hasOwnProperty("group_info"))
                    object.group_info = $root.kritor.group.NotJoinedGroupInfo.toObject(message.group_info, options);
                return object;
            };

            /**
             * Converts this GetNotJoinedGroupInfoResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetNotJoinedGroupInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetNotJoinedGroupInfoResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetNotJoinedGroupInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetNotJoinedGroupInfoResponse";
            };

            return GetNotJoinedGroupInfoResponse;
        })();

        group.GetGroupHonorRequest = (function() {

            /**
             * Properties of a GetGroupHonorRequest.
             * @memberof kritor.group
             * @interface IGetGroupHonorRequest
             * @property {number|Long|null} [group_id] GetGroupHonorRequest group_id
             * @property {boolean|null} [refresh] GetGroupHonorRequest refresh
             */

            /**
             * Constructs a new GetGroupHonorRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupHonorRequest.
             * @implements IGetGroupHonorRequest
             * @constructor
             * @param {kritor.group.IGetGroupHonorRequest=} [properties] Properties to set
             */
            function GetGroupHonorRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupHonorRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.GetGroupHonorRequest
             * @instance
             */
            GetGroupHonorRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGroupHonorRequest refresh.
             * @member {boolean|null|undefined} refresh
             * @memberof kritor.group.GetGroupHonorRequest
             * @instance
             */
            GetGroupHonorRequest.prototype.refresh = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetGroupHonorRequest _refresh.
             * @member {"refresh"|undefined} _refresh
             * @memberof kritor.group.GetGroupHonorRequest
             * @instance
             */
            Object.defineProperty(GetGroupHonorRequest.prototype, "_refresh", {
                get: $util.oneOfGetter($oneOfFields = ["refresh"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetGroupHonorRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {kritor.group.IGetGroupHonorRequest=} [properties] Properties to set
             * @returns {kritor.group.GetGroupHonorRequest} GetGroupHonorRequest instance
             */
            GetGroupHonorRequest.create = function create(properties) {
                return new GetGroupHonorRequest(properties);
            };

            /**
             * Encodes the specified GetGroupHonorRequest message. Does not implicitly {@link kritor.group.GetGroupHonorRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {kritor.group.IGetGroupHonorRequest} message GetGroupHonorRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupHonorRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGroupHonorRequest message, length delimited. Does not implicitly {@link kritor.group.GetGroupHonorRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {kritor.group.IGetGroupHonorRequest} message GetGroupHonorRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupHonorRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupHonorRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupHonorRequest} GetGroupHonorRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupHonorRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupHonorRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupHonorRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupHonorRequest} GetGroupHonorRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupHonorRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupHonorRequest message.
             * @function verify
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupHonorRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    properties._refresh = 1;
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetGroupHonorRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupHonorRequest} GetGroupHonorRequest
             */
            GetGroupHonorRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupHonorRequest)
                    return object;
                let message = new $root.kritor.group.GetGroupHonorRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGroupHonorRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {kritor.group.GetGroupHonorRequest} message GetGroupHonorRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupHonorRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    object.refresh = message.refresh;
                    if (options.oneofs)
                        object._refresh = "refresh";
                }
                return object;
            };

            /**
             * Converts this GetGroupHonorRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupHonorRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupHonorRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupHonorRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupHonorRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupHonorRequest";
            };

            return GetGroupHonorRequest;
        })();

        group.GetGroupHonorResponse = (function() {

            /**
             * Properties of a GetGroupHonorResponse.
             * @memberof kritor.group
             * @interface IGetGroupHonorResponse
             * @property {Array.<kritor.group.IGroupHonorInfo>|null} [group_honors_info] GetGroupHonorResponse group_honors_info
             */

            /**
             * Constructs a new GetGroupHonorResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupHonorResponse.
             * @implements IGetGroupHonorResponse
             * @constructor
             * @param {kritor.group.IGetGroupHonorResponse=} [properties] Properties to set
             */
            function GetGroupHonorResponse(properties) {
                this.group_honors_info = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupHonorResponse group_honors_info.
             * @member {Array.<kritor.group.IGroupHonorInfo>} group_honors_info
             * @memberof kritor.group.GetGroupHonorResponse
             * @instance
             */
            GetGroupHonorResponse.prototype.group_honors_info = $util.emptyArray;

            /**
             * Creates a new GetGroupHonorResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {kritor.group.IGetGroupHonorResponse=} [properties] Properties to set
             * @returns {kritor.group.GetGroupHonorResponse} GetGroupHonorResponse instance
             */
            GetGroupHonorResponse.create = function create(properties) {
                return new GetGroupHonorResponse(properties);
            };

            /**
             * Encodes the specified GetGroupHonorResponse message. Does not implicitly {@link kritor.group.GetGroupHonorResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {kritor.group.IGetGroupHonorResponse} message GetGroupHonorResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupHonorResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_honors_info != null && message.group_honors_info.length)
                    for (let i = 0; i < message.group_honors_info.length; ++i)
                        $root.kritor.group.GroupHonorInfo.encode(message.group_honors_info[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGroupHonorResponse message, length delimited. Does not implicitly {@link kritor.group.GetGroupHonorResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {kritor.group.IGetGroupHonorResponse} message GetGroupHonorResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupHonorResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupHonorResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupHonorResponse} GetGroupHonorResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupHonorResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupHonorResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.group_honors_info && message.group_honors_info.length))
                                message.group_honors_info = [];
                            message.group_honors_info.push($root.kritor.group.GroupHonorInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupHonorResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupHonorResponse} GetGroupHonorResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupHonorResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupHonorResponse message.
             * @function verify
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupHonorResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_honors_info != null && message.hasOwnProperty("group_honors_info")) {
                    if (!Array.isArray(message.group_honors_info))
                        return "group_honors_info: array expected";
                    for (let i = 0; i < message.group_honors_info.length; ++i) {
                        let error = $root.kritor.group.GroupHonorInfo.verify(message.group_honors_info[i]);
                        if (error)
                            return "group_honors_info." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetGroupHonorResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupHonorResponse} GetGroupHonorResponse
             */
            GetGroupHonorResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupHonorResponse)
                    return object;
                let message = new $root.kritor.group.GetGroupHonorResponse();
                if (object.group_honors_info) {
                    if (!Array.isArray(object.group_honors_info))
                        throw TypeError(".kritor.group.GetGroupHonorResponse.group_honors_info: array expected");
                    message.group_honors_info = [];
                    for (let i = 0; i < object.group_honors_info.length; ++i) {
                        if (typeof object.group_honors_info[i] !== "object")
                            throw TypeError(".kritor.group.GetGroupHonorResponse.group_honors_info: object expected");
                        message.group_honors_info[i] = $root.kritor.group.GroupHonorInfo.fromObject(object.group_honors_info[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGroupHonorResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {kritor.group.GetGroupHonorResponse} message GetGroupHonorResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupHonorResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.group_honors_info = [];
                if (message.group_honors_info && message.group_honors_info.length) {
                    object.group_honors_info = [];
                    for (let j = 0; j < message.group_honors_info.length; ++j)
                        object.group_honors_info[j] = $root.kritor.group.GroupHonorInfo.toObject(message.group_honors_info[j], options);
                }
                return object;
            };

            /**
             * Converts this GetGroupHonorResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupHonorResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupHonorResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupHonorResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupHonorResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupHonorResponse";
            };

            return GetGroupHonorResponse;
        })();

        group.GroupInfo = (function() {

            /**
             * Properties of a GroupInfo.
             * @memberof kritor.group
             * @interface IGroupInfo
             * @property {number|Long|null} [group_id] GroupInfo group_id
             * @property {string|null} [group_name] GroupInfo group_name
             * @property {string|null} [group_remark] GroupInfo group_remark
             * @property {number|Long|null} [owner] GroupInfo owner
             * @property {Array.<number|Long>|null} [admins] GroupInfo admins
             * @property {number|null} [max_member_count] GroupInfo max_member_count
             * @property {number|null} [member_count] GroupInfo member_count
             * @property {number|Long|null} [group_uin] GroupInfo group_uin
             */

            /**
             * Constructs a new GroupInfo.
             * @memberof kritor.group
             * @classdesc Represents a GroupInfo.
             * @implements IGroupInfo
             * @constructor
             * @param {kritor.group.IGroupInfo=} [properties] Properties to set
             */
            function GroupInfo(properties) {
                this.admins = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupInfo group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupInfo group_name.
             * @member {string} group_name
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.group_name = "";

            /**
             * GroupInfo group_remark.
             * @member {string} group_remark
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.group_remark = "";

            /**
             * GroupInfo owner.
             * @member {number|Long} owner
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.owner = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupInfo admins.
             * @member {Array.<number|Long>} admins
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.admins = $util.emptyArray;

            /**
             * GroupInfo max_member_count.
             * @member {number} max_member_count
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.max_member_count = 0;

            /**
             * GroupInfo member_count.
             * @member {number} member_count
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.member_count = 0;

            /**
             * GroupInfo group_uin.
             * @member {number|Long} group_uin
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.group_uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GroupInfo instance using the specified properties.
             * @function create
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {kritor.group.IGroupInfo=} [properties] Properties to set
             * @returns {kritor.group.GroupInfo} GroupInfo instance
             */
            GroupInfo.create = function create(properties) {
                return new GroupInfo(properties);
            };

            /**
             * Encodes the specified GroupInfo message. Does not implicitly {@link kritor.group.GroupInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {kritor.group.IGroupInfo} message GroupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.group_name != null && Object.hasOwnProperty.call(message, "group_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.group_name);
                if (message.group_remark != null && Object.hasOwnProperty.call(message, "group_remark"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.group_remark);
                if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.owner);
                if (message.admins != null && message.admins.length) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork();
                    for (let i = 0; i < message.admins.length; ++i)
                        writer.uint64(message.admins[i]);
                    writer.ldelim();
                }
                if (message.max_member_count != null && Object.hasOwnProperty.call(message, "max_member_count"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.max_member_count);
                if (message.member_count != null && Object.hasOwnProperty.call(message, "member_count"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.member_count);
                if (message.group_uin != null && Object.hasOwnProperty.call(message, "group_uin"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.group_uin);
                return writer;
            };

            /**
             * Encodes the specified GroupInfo message, length delimited. Does not implicitly {@link kritor.group.GroupInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {kritor.group.IGroupInfo} message GroupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GroupInfo} GroupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GroupInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.group_name = reader.string();
                            break;
                        }
                    case 3: {
                            message.group_remark = reader.string();
                            break;
                        }
                    case 4: {
                            message.owner = reader.uint64();
                            break;
                        }
                    case 5: {
                            if (!(message.admins && message.admins.length))
                                message.admins = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.admins.push(reader.uint64());
                            } else
                                message.admins.push(reader.uint64());
                            break;
                        }
                    case 6: {
                            message.max_member_count = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.member_count = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.group_uin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GroupInfo} GroupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupInfo message.
             * @function verify
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.group_name != null && message.hasOwnProperty("group_name"))
                    if (!$util.isString(message.group_name))
                        return "group_name: string expected";
                if (message.group_remark != null && message.hasOwnProperty("group_remark"))
                    if (!$util.isString(message.group_remark))
                        return "group_remark: string expected";
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (!$util.isInteger(message.owner) && !(message.owner && $util.isInteger(message.owner.low) && $util.isInteger(message.owner.high)))
                        return "owner: integer|Long expected";
                if (message.admins != null && message.hasOwnProperty("admins")) {
                    if (!Array.isArray(message.admins))
                        return "admins: array expected";
                    for (let i = 0; i < message.admins.length; ++i)
                        if (!$util.isInteger(message.admins[i]) && !(message.admins[i] && $util.isInteger(message.admins[i].low) && $util.isInteger(message.admins[i].high)))
                            return "admins: integer|Long[] expected";
                }
                if (message.max_member_count != null && message.hasOwnProperty("max_member_count"))
                    if (!$util.isInteger(message.max_member_count))
                        return "max_member_count: integer expected";
                if (message.member_count != null && message.hasOwnProperty("member_count"))
                    if (!$util.isInteger(message.member_count))
                        return "member_count: integer expected";
                if (message.group_uin != null && message.hasOwnProperty("group_uin"))
                    if (!$util.isInteger(message.group_uin) && !(message.group_uin && $util.isInteger(message.group_uin.low) && $util.isInteger(message.group_uin.high)))
                        return "group_uin: integer|Long expected";
                return null;
            };

            /**
             * Creates a GroupInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GroupInfo} GroupInfo
             */
            GroupInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GroupInfo)
                    return object;
                let message = new $root.kritor.group.GroupInfo();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.group_name != null)
                    message.group_name = String(object.group_name);
                if (object.group_remark != null)
                    message.group_remark = String(object.group_remark);
                if (object.owner != null)
                    if ($util.Long)
                        (message.owner = $util.Long.fromValue(object.owner)).unsigned = true;
                    else if (typeof object.owner === "string")
                        message.owner = parseInt(object.owner, 10);
                    else if (typeof object.owner === "number")
                        message.owner = object.owner;
                    else if (typeof object.owner === "object")
                        message.owner = new $util.LongBits(object.owner.low >>> 0, object.owner.high >>> 0).toNumber(true);
                if (object.admins) {
                    if (!Array.isArray(object.admins))
                        throw TypeError(".kritor.group.GroupInfo.admins: array expected");
                    message.admins = [];
                    for (let i = 0; i < object.admins.length; ++i)
                        if ($util.Long)
                            (message.admins[i] = $util.Long.fromValue(object.admins[i])).unsigned = true;
                        else if (typeof object.admins[i] === "string")
                            message.admins[i] = parseInt(object.admins[i], 10);
                        else if (typeof object.admins[i] === "number")
                            message.admins[i] = object.admins[i];
                        else if (typeof object.admins[i] === "object")
                            message.admins[i] = new $util.LongBits(object.admins[i].low >>> 0, object.admins[i].high >>> 0).toNumber(true);
                }
                if (object.max_member_count != null)
                    message.max_member_count = object.max_member_count >>> 0;
                if (object.member_count != null)
                    message.member_count = object.member_count >>> 0;
                if (object.group_uin != null)
                    if ($util.Long)
                        (message.group_uin = $util.Long.fromValue(object.group_uin)).unsigned = true;
                    else if (typeof object.group_uin === "string")
                        message.group_uin = parseInt(object.group_uin, 10);
                    else if (typeof object.group_uin === "number")
                        message.group_uin = object.group_uin;
                    else if (typeof object.group_uin === "object")
                        message.group_uin = new $util.LongBits(object.group_uin.low >>> 0, object.group_uin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GroupInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {kritor.group.GroupInfo} message GroupInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.admins = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.group_name = "";
                    object.group_remark = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.owner = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.owner = options.longs === String ? "0" : 0;
                    object.max_member_count = 0;
                    object.member_count = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_uin = options.longs === String ? "0" : 0;
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.group_name != null && message.hasOwnProperty("group_name"))
                    object.group_name = message.group_name;
                if (message.group_remark != null && message.hasOwnProperty("group_remark"))
                    object.group_remark = message.group_remark;
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (typeof message.owner === "number")
                        object.owner = options.longs === String ? String(message.owner) : message.owner;
                    else
                        object.owner = options.longs === String ? $util.Long.prototype.toString.call(message.owner) : options.longs === Number ? new $util.LongBits(message.owner.low >>> 0, message.owner.high >>> 0).toNumber(true) : message.owner;
                if (message.admins && message.admins.length) {
                    object.admins = [];
                    for (let j = 0; j < message.admins.length; ++j)
                        if (typeof message.admins[j] === "number")
                            object.admins[j] = options.longs === String ? String(message.admins[j]) : message.admins[j];
                        else
                            object.admins[j] = options.longs === String ? $util.Long.prototype.toString.call(message.admins[j]) : options.longs === Number ? new $util.LongBits(message.admins[j].low >>> 0, message.admins[j].high >>> 0).toNumber(true) : message.admins[j];
                }
                if (message.max_member_count != null && message.hasOwnProperty("max_member_count"))
                    object.max_member_count = message.max_member_count;
                if (message.member_count != null && message.hasOwnProperty("member_count"))
                    object.member_count = message.member_count;
                if (message.group_uin != null && message.hasOwnProperty("group_uin"))
                    if (typeof message.group_uin === "number")
                        object.group_uin = options.longs === String ? String(message.group_uin) : message.group_uin;
                    else
                        object.group_uin = options.longs === String ? $util.Long.prototype.toString.call(message.group_uin) : options.longs === Number ? new $util.LongBits(message.group_uin.low >>> 0, message.group_uin.high >>> 0).toNumber(true) : message.group_uin;
                return object;
            };

            /**
             * Converts this GroupInfo to JSON.
             * @function toJSON
             * @memberof kritor.group.GroupInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupInfo
             * @function getTypeUrl
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GroupInfo";
            };

            return GroupInfo;
        })();

        group.NotJoinedGroupInfo = (function() {

            /**
             * Properties of a NotJoinedGroupInfo.
             * @memberof kritor.group
             * @interface INotJoinedGroupInfo
             * @property {number|Long|null} [group_id] NotJoinedGroupInfo group_id
             * @property {number|null} [max_member_count] NotJoinedGroupInfo max_member_count
             * @property {number|null} [member_count] NotJoinedGroupInfo member_count
             * @property {string|null} [group_name] NotJoinedGroupInfo group_name
             * @property {string|null} [group_desc] NotJoinedGroupInfo group_desc
             * @property {number|Long|null} [owner] NotJoinedGroupInfo owner
             * @property {number|null} [create_time] NotJoinedGroupInfo create_time
             * @property {number|null} [group_flag] NotJoinedGroupInfo group_flag
             * @property {number|null} [group_flag_ext] NotJoinedGroupInfo group_flag_ext
             */

            /**
             * Constructs a new NotJoinedGroupInfo.
             * @memberof kritor.group
             * @classdesc Represents a NotJoinedGroupInfo.
             * @implements INotJoinedGroupInfo
             * @constructor
             * @param {kritor.group.INotJoinedGroupInfo=} [properties] Properties to set
             */
            function NotJoinedGroupInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NotJoinedGroupInfo group_id.
             * @member {number|Long} group_id
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * NotJoinedGroupInfo max_member_count.
             * @member {number} max_member_count
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.max_member_count = 0;

            /**
             * NotJoinedGroupInfo member_count.
             * @member {number} member_count
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.member_count = 0;

            /**
             * NotJoinedGroupInfo group_name.
             * @member {string} group_name
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.group_name = "";

            /**
             * NotJoinedGroupInfo group_desc.
             * @member {string} group_desc
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.group_desc = "";

            /**
             * NotJoinedGroupInfo owner.
             * @member {number|Long} owner
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.owner = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * NotJoinedGroupInfo create_time.
             * @member {number} create_time
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.create_time = 0;

            /**
             * NotJoinedGroupInfo group_flag.
             * @member {number} group_flag
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.group_flag = 0;

            /**
             * NotJoinedGroupInfo group_flag_ext.
             * @member {number} group_flag_ext
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.group_flag_ext = 0;

            /**
             * Creates a new NotJoinedGroupInfo instance using the specified properties.
             * @function create
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {kritor.group.INotJoinedGroupInfo=} [properties] Properties to set
             * @returns {kritor.group.NotJoinedGroupInfo} NotJoinedGroupInfo instance
             */
            NotJoinedGroupInfo.create = function create(properties) {
                return new NotJoinedGroupInfo(properties);
            };

            /**
             * Encodes the specified NotJoinedGroupInfo message. Does not implicitly {@link kritor.group.NotJoinedGroupInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {kritor.group.INotJoinedGroupInfo} message NotJoinedGroupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotJoinedGroupInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.max_member_count != null && Object.hasOwnProperty.call(message, "max_member_count"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.max_member_count);
                if (message.member_count != null && Object.hasOwnProperty.call(message, "member_count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.member_count);
                if (message.group_name != null && Object.hasOwnProperty.call(message, "group_name"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.group_name);
                if (message.group_desc != null && Object.hasOwnProperty.call(message, "group_desc"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.group_desc);
                if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.owner);
                if (message.create_time != null && Object.hasOwnProperty.call(message, "create_time"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.create_time);
                if (message.group_flag != null && Object.hasOwnProperty.call(message, "group_flag"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.group_flag);
                if (message.group_flag_ext != null && Object.hasOwnProperty.call(message, "group_flag_ext"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.group_flag_ext);
                return writer;
            };

            /**
             * Encodes the specified NotJoinedGroupInfo message, length delimited. Does not implicitly {@link kritor.group.NotJoinedGroupInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {kritor.group.INotJoinedGroupInfo} message NotJoinedGroupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotJoinedGroupInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NotJoinedGroupInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.NotJoinedGroupInfo} NotJoinedGroupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotJoinedGroupInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.NotJoinedGroupInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.max_member_count = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.member_count = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.group_name = reader.string();
                            break;
                        }
                    case 5: {
                            message.group_desc = reader.string();
                            break;
                        }
                    case 6: {
                            message.owner = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.create_time = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.group_flag = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.group_flag_ext = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NotJoinedGroupInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.NotJoinedGroupInfo} NotJoinedGroupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotJoinedGroupInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NotJoinedGroupInfo message.
             * @function verify
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NotJoinedGroupInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.max_member_count != null && message.hasOwnProperty("max_member_count"))
                    if (!$util.isInteger(message.max_member_count))
                        return "max_member_count: integer expected";
                if (message.member_count != null && message.hasOwnProperty("member_count"))
                    if (!$util.isInteger(message.member_count))
                        return "member_count: integer expected";
                if (message.group_name != null && message.hasOwnProperty("group_name"))
                    if (!$util.isString(message.group_name))
                        return "group_name: string expected";
                if (message.group_desc != null && message.hasOwnProperty("group_desc"))
                    if (!$util.isString(message.group_desc))
                        return "group_desc: string expected";
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (!$util.isInteger(message.owner) && !(message.owner && $util.isInteger(message.owner.low) && $util.isInteger(message.owner.high)))
                        return "owner: integer|Long expected";
                if (message.create_time != null && message.hasOwnProperty("create_time"))
                    if (!$util.isInteger(message.create_time))
                        return "create_time: integer expected";
                if (message.group_flag != null && message.hasOwnProperty("group_flag"))
                    if (!$util.isInteger(message.group_flag))
                        return "group_flag: integer expected";
                if (message.group_flag_ext != null && message.hasOwnProperty("group_flag_ext"))
                    if (!$util.isInteger(message.group_flag_ext))
                        return "group_flag_ext: integer expected";
                return null;
            };

            /**
             * Creates a NotJoinedGroupInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.NotJoinedGroupInfo} NotJoinedGroupInfo
             */
            NotJoinedGroupInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.NotJoinedGroupInfo)
                    return object;
                let message = new $root.kritor.group.NotJoinedGroupInfo();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.max_member_count != null)
                    message.max_member_count = object.max_member_count >>> 0;
                if (object.member_count != null)
                    message.member_count = object.member_count >>> 0;
                if (object.group_name != null)
                    message.group_name = String(object.group_name);
                if (object.group_desc != null)
                    message.group_desc = String(object.group_desc);
                if (object.owner != null)
                    if ($util.Long)
                        (message.owner = $util.Long.fromValue(object.owner)).unsigned = true;
                    else if (typeof object.owner === "string")
                        message.owner = parseInt(object.owner, 10);
                    else if (typeof object.owner === "number")
                        message.owner = object.owner;
                    else if (typeof object.owner === "object")
                        message.owner = new $util.LongBits(object.owner.low >>> 0, object.owner.high >>> 0).toNumber(true);
                if (object.create_time != null)
                    message.create_time = object.create_time >>> 0;
                if (object.group_flag != null)
                    message.group_flag = object.group_flag >>> 0;
                if (object.group_flag_ext != null)
                    message.group_flag_ext = object.group_flag_ext >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a NotJoinedGroupInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {kritor.group.NotJoinedGroupInfo} message NotJoinedGroupInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NotJoinedGroupInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.max_member_count = 0;
                    object.member_count = 0;
                    object.group_name = "";
                    object.group_desc = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.owner = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.owner = options.longs === String ? "0" : 0;
                    object.create_time = 0;
                    object.group_flag = 0;
                    object.group_flag_ext = 0;
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.max_member_count != null && message.hasOwnProperty("max_member_count"))
                    object.max_member_count = message.max_member_count;
                if (message.member_count != null && message.hasOwnProperty("member_count"))
                    object.member_count = message.member_count;
                if (message.group_name != null && message.hasOwnProperty("group_name"))
                    object.group_name = message.group_name;
                if (message.group_desc != null && message.hasOwnProperty("group_desc"))
                    object.group_desc = message.group_desc;
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (typeof message.owner === "number")
                        object.owner = options.longs === String ? String(message.owner) : message.owner;
                    else
                        object.owner = options.longs === String ? $util.Long.prototype.toString.call(message.owner) : options.longs === Number ? new $util.LongBits(message.owner.low >>> 0, message.owner.high >>> 0).toNumber(true) : message.owner;
                if (message.create_time != null && message.hasOwnProperty("create_time"))
                    object.create_time = message.create_time;
                if (message.group_flag != null && message.hasOwnProperty("group_flag"))
                    object.group_flag = message.group_flag;
                if (message.group_flag_ext != null && message.hasOwnProperty("group_flag_ext"))
                    object.group_flag_ext = message.group_flag_ext;
                return object;
            };

            /**
             * Converts this NotJoinedGroupInfo to JSON.
             * @function toJSON
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NotJoinedGroupInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NotJoinedGroupInfo
             * @function getTypeUrl
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NotJoinedGroupInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.NotJoinedGroupInfo";
            };

            return NotJoinedGroupInfo;
        })();

        group.ProhibitedUserInfo = (function() {

            /**
             * Properties of a ProhibitedUserInfo.
             * @memberof kritor.group
             * @interface IProhibitedUserInfo
             * @property {string|null} [uid] ProhibitedUserInfo uid
             * @property {number|Long|null} [uin] ProhibitedUserInfo uin
             * @property {number|null} [prohibited_time] ProhibitedUserInfo prohibited_time
             */

            /**
             * Constructs a new ProhibitedUserInfo.
             * @memberof kritor.group
             * @classdesc Represents a ProhibitedUserInfo.
             * @implements IProhibitedUserInfo
             * @constructor
             * @param {kritor.group.IProhibitedUserInfo=} [properties] Properties to set
             */
            function ProhibitedUserInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProhibitedUserInfo uid.
             * @member {string} uid
             * @memberof kritor.group.ProhibitedUserInfo
             * @instance
             */
            ProhibitedUserInfo.prototype.uid = "";

            /**
             * ProhibitedUserInfo uin.
             * @member {number|Long} uin
             * @memberof kritor.group.ProhibitedUserInfo
             * @instance
             */
            ProhibitedUserInfo.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ProhibitedUserInfo prohibited_time.
             * @member {number} prohibited_time
             * @memberof kritor.group.ProhibitedUserInfo
             * @instance
             */
            ProhibitedUserInfo.prototype.prohibited_time = 0;

            /**
             * Creates a new ProhibitedUserInfo instance using the specified properties.
             * @function create
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {kritor.group.IProhibitedUserInfo=} [properties] Properties to set
             * @returns {kritor.group.ProhibitedUserInfo} ProhibitedUserInfo instance
             */
            ProhibitedUserInfo.create = function create(properties) {
                return new ProhibitedUserInfo(properties);
            };

            /**
             * Encodes the specified ProhibitedUserInfo message. Does not implicitly {@link kritor.group.ProhibitedUserInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {kritor.group.IProhibitedUserInfo} message ProhibitedUserInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProhibitedUserInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.prohibited_time != null && Object.hasOwnProperty.call(message, "prohibited_time"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.prohibited_time);
                return writer;
            };

            /**
             * Encodes the specified ProhibitedUserInfo message, length delimited. Does not implicitly {@link kritor.group.ProhibitedUserInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {kritor.group.IProhibitedUserInfo} message ProhibitedUserInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProhibitedUserInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProhibitedUserInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ProhibitedUserInfo} ProhibitedUserInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProhibitedUserInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ProhibitedUserInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.prohibited_time = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProhibitedUserInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ProhibitedUserInfo} ProhibitedUserInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProhibitedUserInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProhibitedUserInfo message.
             * @function verify
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProhibitedUserInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.prohibited_time != null && message.hasOwnProperty("prohibited_time"))
                    if (!$util.isInteger(message.prohibited_time))
                        return "prohibited_time: integer expected";
                return null;
            };

            /**
             * Creates a ProhibitedUserInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ProhibitedUserInfo} ProhibitedUserInfo
             */
            ProhibitedUserInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ProhibitedUserInfo)
                    return object;
                let message = new $root.kritor.group.ProhibitedUserInfo();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.prohibited_time != null)
                    message.prohibited_time = object.prohibited_time >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ProhibitedUserInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {kritor.group.ProhibitedUserInfo} message ProhibitedUserInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProhibitedUserInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.prohibited_time = 0;
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.prohibited_time != null && message.hasOwnProperty("prohibited_time"))
                    object.prohibited_time = message.prohibited_time;
                return object;
            };

            /**
             * Converts this ProhibitedUserInfo to JSON.
             * @function toJSON
             * @memberof kritor.group.ProhibitedUserInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProhibitedUserInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ProhibitedUserInfo
             * @function getTypeUrl
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ProhibitedUserInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ProhibitedUserInfo";
            };

            return ProhibitedUserInfo;
        })();

        group.GroupHonorInfo = (function() {

            /**
             * Properties of a GroupHonorInfo.
             * @memberof kritor.group
             * @interface IGroupHonorInfo
             * @property {string|null} [uid] GroupHonorInfo uid
             * @property {number|Long|null} [uin] GroupHonorInfo uin
             * @property {string|null} [nick] GroupHonorInfo nick
             * @property {string|null} [honor_name] GroupHonorInfo honor_name
             * @property {string|null} [avatar] GroupHonorInfo avatar
             * @property {number|null} [id] GroupHonorInfo id
             * @property {string|null} [description] GroupHonorInfo description
             */

            /**
             * Constructs a new GroupHonorInfo.
             * @memberof kritor.group
             * @classdesc Represents a GroupHonorInfo.
             * @implements IGroupHonorInfo
             * @constructor
             * @param {kritor.group.IGroupHonorInfo=} [properties] Properties to set
             */
            function GroupHonorInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupHonorInfo uid.
             * @member {string} uid
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.uid = "";

            /**
             * GroupHonorInfo uin.
             * @member {number|Long} uin
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupHonorInfo nick.
             * @member {string} nick
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.nick = "";

            /**
             * GroupHonorInfo honor_name.
             * @member {string} honor_name
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.honor_name = "";

            /**
             * GroupHonorInfo avatar.
             * @member {string} avatar
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.avatar = "";

            /**
             * GroupHonorInfo id.
             * @member {number} id
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.id = 0;

            /**
             * GroupHonorInfo description.
             * @member {string} description
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.description = "";

            /**
             * Creates a new GroupHonorInfo instance using the specified properties.
             * @function create
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {kritor.group.IGroupHonorInfo=} [properties] Properties to set
             * @returns {kritor.group.GroupHonorInfo} GroupHonorInfo instance
             */
            GroupHonorInfo.create = function create(properties) {
                return new GroupHonorInfo(properties);
            };

            /**
             * Encodes the specified GroupHonorInfo message. Does not implicitly {@link kritor.group.GroupHonorInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {kritor.group.IGroupHonorInfo} message GroupHonorInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupHonorInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.nick);
                if (message.honor_name != null && Object.hasOwnProperty.call(message, "honor_name"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.honor_name);
                if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.avatar);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.id);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.description);
                return writer;
            };

            /**
             * Encodes the specified GroupHonorInfo message, length delimited. Does not implicitly {@link kritor.group.GroupHonorInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {kritor.group.IGroupHonorInfo} message GroupHonorInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupHonorInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupHonorInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GroupHonorInfo} GroupHonorInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupHonorInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GroupHonorInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.nick = reader.string();
                            break;
                        }
                    case 4: {
                            message.honor_name = reader.string();
                            break;
                        }
                    case 5: {
                            message.avatar = reader.string();
                            break;
                        }
                    case 6: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.description = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupHonorInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GroupHonorInfo} GroupHonorInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupHonorInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupHonorInfo message.
             * @function verify
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupHonorInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.nick != null && message.hasOwnProperty("nick"))
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                if (message.honor_name != null && message.hasOwnProperty("honor_name"))
                    if (!$util.isString(message.honor_name))
                        return "honor_name: string expected";
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    if (!$util.isString(message.avatar))
                        return "avatar: string expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                return null;
            };

            /**
             * Creates a GroupHonorInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GroupHonorInfo} GroupHonorInfo
             */
            GroupHonorInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GroupHonorInfo)
                    return object;
                let message = new $root.kritor.group.GroupHonorInfo();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.nick != null)
                    message.nick = String(object.nick);
                if (object.honor_name != null)
                    message.honor_name = String(object.honor_name);
                if (object.avatar != null)
                    message.avatar = String(object.avatar);
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.description != null)
                    message.description = String(object.description);
                return message;
            };

            /**
             * Creates a plain object from a GroupHonorInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {kritor.group.GroupHonorInfo} message GroupHonorInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupHonorInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.nick = "";
                    object.honor_name = "";
                    object.avatar = "";
                    object.id = 0;
                    object.description = "";
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.nick != null && message.hasOwnProperty("nick"))
                    object.nick = message.nick;
                if (message.honor_name != null && message.hasOwnProperty("honor_name"))
                    object.honor_name = message.honor_name;
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    object.avatar = message.avatar;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                return object;
            };

            /**
             * Converts this GroupHonorInfo to JSON.
             * @function toJSON
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupHonorInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupHonorInfo
             * @function getTypeUrl
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupHonorInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GroupHonorInfo";
            };

            return GroupHonorInfo;
        })();

        /**
         * MemberRole enum.
         * @name kritor.group.MemberRole
         * @enum {number}
         * @property {number} ADMIN=0 ADMIN value
         * @property {number} MEMBER=1 MEMBER value
         * @property {number} OWNER=2 OWNER value
         * @property {number} STRANGER=3 STRANGER value
         */
        group.MemberRole = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ADMIN"] = 0;
            values[valuesById[1] = "MEMBER"] = 1;
            values[valuesById[2] = "OWNER"] = 2;
            values[valuesById[3] = "STRANGER"] = 3;
            return values;
        })();

        group.GroupMemberInfo = (function() {

            /**
             * Properties of a GroupMemberInfo.
             * @memberof kritor.group
             * @interface IGroupMemberInfo
             * @property {string|null} [uid] GroupMemberInfo uid
             * @property {number|Long|null} [uin] GroupMemberInfo uin
             * @property {string|null} [nick] GroupMemberInfo nick
             * @property {number|null} [age] GroupMemberInfo age
             * @property {string|null} [unique_title] GroupMemberInfo unique_title
             * @property {number|null} [unique_title_expire_time] GroupMemberInfo unique_title_expire_time
             * @property {string|null} [card] GroupMemberInfo card
             * @property {number|Long|null} [join_time] GroupMemberInfo join_time
             * @property {number|Long|null} [last_active_time] GroupMemberInfo last_active_time
             * @property {number|null} [level] GroupMemberInfo level
             * @property {number|Long|null} [shut_up_timestamp] GroupMemberInfo shut_up_timestamp
             * @property {number|null} [distance] GroupMemberInfo distance
             * @property {Array.<number>|null} [honors] GroupMemberInfo honors
             * @property {boolean|null} [unfriendly] GroupMemberInfo unfriendly
             * @property {boolean|null} [card_changeable] GroupMemberInfo card_changeable
             */

            /**
             * Constructs a new GroupMemberInfo.
             * @memberof kritor.group
             * @classdesc Represents a GroupMemberInfo.
             * @implements IGroupMemberInfo
             * @constructor
             * @param {kritor.group.IGroupMemberInfo=} [properties] Properties to set
             */
            function GroupMemberInfo(properties) {
                this.honors = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupMemberInfo uid.
             * @member {string} uid
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.uid = "";

            /**
             * GroupMemberInfo uin.
             * @member {number|Long} uin
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberInfo nick.
             * @member {string} nick
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.nick = "";

            /**
             * GroupMemberInfo age.
             * @member {number} age
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.age = 0;

            /**
             * GroupMemberInfo unique_title.
             * @member {string} unique_title
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.unique_title = "";

            /**
             * GroupMemberInfo unique_title_expire_time.
             * @member {number} unique_title_expire_time
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.unique_title_expire_time = 0;

            /**
             * GroupMemberInfo card.
             * @member {string} card
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.card = "";

            /**
             * GroupMemberInfo join_time.
             * @member {number|Long} join_time
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.join_time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberInfo last_active_time.
             * @member {number|Long} last_active_time
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.last_active_time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberInfo level.
             * @member {number} level
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.level = 0;

            /**
             * GroupMemberInfo shut_up_timestamp.
             * @member {number|Long} shut_up_timestamp
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.shut_up_timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberInfo distance.
             * @member {number|null|undefined} distance
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.distance = null;

            /**
             * GroupMemberInfo honors.
             * @member {Array.<number>} honors
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.honors = $util.emptyArray;

            /**
             * GroupMemberInfo unfriendly.
             * @member {boolean|null|undefined} unfriendly
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.unfriendly = null;

            /**
             * GroupMemberInfo card_changeable.
             * @member {boolean|null|undefined} card_changeable
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.card_changeable = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GroupMemberInfo _distance.
             * @member {"distance"|undefined} _distance
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            Object.defineProperty(GroupMemberInfo.prototype, "_distance", {
                get: $util.oneOfGetter($oneOfFields = ["distance"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GroupMemberInfo _unfriendly.
             * @member {"unfriendly"|undefined} _unfriendly
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            Object.defineProperty(GroupMemberInfo.prototype, "_unfriendly", {
                get: $util.oneOfGetter($oneOfFields = ["unfriendly"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GroupMemberInfo _card_changeable.
             * @member {"card_changeable"|undefined} _card_changeable
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            Object.defineProperty(GroupMemberInfo.prototype, "_card_changeable", {
                get: $util.oneOfGetter($oneOfFields = ["card_changeable"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GroupMemberInfo instance using the specified properties.
             * @function create
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {kritor.group.IGroupMemberInfo=} [properties] Properties to set
             * @returns {kritor.group.GroupMemberInfo} GroupMemberInfo instance
             */
            GroupMemberInfo.create = function create(properties) {
                return new GroupMemberInfo(properties);
            };

            /**
             * Encodes the specified GroupMemberInfo message. Does not implicitly {@link kritor.group.GroupMemberInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {kritor.group.IGroupMemberInfo} message GroupMemberInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.nick);
                if (message.age != null && Object.hasOwnProperty.call(message, "age"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.age);
                if (message.unique_title != null && Object.hasOwnProperty.call(message, "unique_title"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.unique_title);
                if (message.unique_title_expire_time != null && Object.hasOwnProperty.call(message, "unique_title_expire_time"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.unique_title_expire_time);
                if (message.card != null && Object.hasOwnProperty.call(message, "card"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.card);
                if (message.join_time != null && Object.hasOwnProperty.call(message, "join_time"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.join_time);
                if (message.last_active_time != null && Object.hasOwnProperty.call(message, "last_active_time"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.last_active_time);
                if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.level);
                if (message.shut_up_timestamp != null && Object.hasOwnProperty.call(message, "shut_up_timestamp"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.shut_up_timestamp);
                if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                    writer.uint32(/* id 100, wireType 0 =*/800).uint32(message.distance);
                if (message.honors != null && message.honors.length) {
                    writer.uint32(/* id 101, wireType 2 =*/810).fork();
                    for (let i = 0; i < message.honors.length; ++i)
                        writer.uint32(message.honors[i]);
                    writer.ldelim();
                }
                if (message.unfriendly != null && Object.hasOwnProperty.call(message, "unfriendly"))
                    writer.uint32(/* id 102, wireType 0 =*/816).bool(message.unfriendly);
                if (message.card_changeable != null && Object.hasOwnProperty.call(message, "card_changeable"))
                    writer.uint32(/* id 103, wireType 0 =*/824).bool(message.card_changeable);
                return writer;
            };

            /**
             * Encodes the specified GroupMemberInfo message, length delimited. Does not implicitly {@link kritor.group.GroupMemberInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {kritor.group.IGroupMemberInfo} message GroupMemberInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupMemberInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GroupMemberInfo} GroupMemberInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GroupMemberInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.nick = reader.string();
                            break;
                        }
                    case 4: {
                            message.age = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.unique_title = reader.string();
                            break;
                        }
                    case 6: {
                            message.unique_title_expire_time = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.card = reader.string();
                            break;
                        }
                    case 8: {
                            message.join_time = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.last_active_time = reader.uint64();
                            break;
                        }
                    case 10: {
                            message.level = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.shut_up_timestamp = reader.uint64();
                            break;
                        }
                    case 100: {
                            message.distance = reader.uint32();
                            break;
                        }
                    case 101: {
                            if (!(message.honors && message.honors.length))
                                message.honors = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.honors.push(reader.uint32());
                            } else
                                message.honors.push(reader.uint32());
                            break;
                        }
                    case 102: {
                            message.unfriendly = reader.bool();
                            break;
                        }
                    case 103: {
                            message.card_changeable = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupMemberInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GroupMemberInfo} GroupMemberInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupMemberInfo message.
             * @function verify
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupMemberInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.nick != null && message.hasOwnProperty("nick"))
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                if (message.age != null && message.hasOwnProperty("age"))
                    if (!$util.isInteger(message.age))
                        return "age: integer expected";
                if (message.unique_title != null && message.hasOwnProperty("unique_title"))
                    if (!$util.isString(message.unique_title))
                        return "unique_title: string expected";
                if (message.unique_title_expire_time != null && message.hasOwnProperty("unique_title_expire_time"))
                    if (!$util.isInteger(message.unique_title_expire_time))
                        return "unique_title_expire_time: integer expected";
                if (message.card != null && message.hasOwnProperty("card"))
                    if (!$util.isString(message.card))
                        return "card: string expected";
                if (message.join_time != null && message.hasOwnProperty("join_time"))
                    if (!$util.isInteger(message.join_time) && !(message.join_time && $util.isInteger(message.join_time.low) && $util.isInteger(message.join_time.high)))
                        return "join_time: integer|Long expected";
                if (message.last_active_time != null && message.hasOwnProperty("last_active_time"))
                    if (!$util.isInteger(message.last_active_time) && !(message.last_active_time && $util.isInteger(message.last_active_time.low) && $util.isInteger(message.last_active_time.high)))
                        return "last_active_time: integer|Long expected";
                if (message.level != null && message.hasOwnProperty("level"))
                    if (!$util.isInteger(message.level))
                        return "level: integer expected";
                if (message.shut_up_timestamp != null && message.hasOwnProperty("shut_up_timestamp"))
                    if (!$util.isInteger(message.shut_up_timestamp) && !(message.shut_up_timestamp && $util.isInteger(message.shut_up_timestamp.low) && $util.isInteger(message.shut_up_timestamp.high)))
                        return "shut_up_timestamp: integer|Long expected";
                if (message.distance != null && message.hasOwnProperty("distance")) {
                    properties._distance = 1;
                    if (!$util.isInteger(message.distance))
                        return "distance: integer expected";
                }
                if (message.honors != null && message.hasOwnProperty("honors")) {
                    if (!Array.isArray(message.honors))
                        return "honors: array expected";
                    for (let i = 0; i < message.honors.length; ++i)
                        if (!$util.isInteger(message.honors[i]))
                            return "honors: integer[] expected";
                }
                if (message.unfriendly != null && message.hasOwnProperty("unfriendly")) {
                    properties._unfriendly = 1;
                    if (typeof message.unfriendly !== "boolean")
                        return "unfriendly: boolean expected";
                }
                if (message.card_changeable != null && message.hasOwnProperty("card_changeable")) {
                    properties._card_changeable = 1;
                    if (typeof message.card_changeable !== "boolean")
                        return "card_changeable: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GroupMemberInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GroupMemberInfo} GroupMemberInfo
             */
            GroupMemberInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GroupMemberInfo)
                    return object;
                let message = new $root.kritor.group.GroupMemberInfo();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.nick != null)
                    message.nick = String(object.nick);
                if (object.age != null)
                    message.age = object.age >>> 0;
                if (object.unique_title != null)
                    message.unique_title = String(object.unique_title);
                if (object.unique_title_expire_time != null)
                    message.unique_title_expire_time = object.unique_title_expire_time >>> 0;
                if (object.card != null)
                    message.card = String(object.card);
                if (object.join_time != null)
                    if ($util.Long)
                        (message.join_time = $util.Long.fromValue(object.join_time)).unsigned = true;
                    else if (typeof object.join_time === "string")
                        message.join_time = parseInt(object.join_time, 10);
                    else if (typeof object.join_time === "number")
                        message.join_time = object.join_time;
                    else if (typeof object.join_time === "object")
                        message.join_time = new $util.LongBits(object.join_time.low >>> 0, object.join_time.high >>> 0).toNumber(true);
                if (object.last_active_time != null)
                    if ($util.Long)
                        (message.last_active_time = $util.Long.fromValue(object.last_active_time)).unsigned = true;
                    else if (typeof object.last_active_time === "string")
                        message.last_active_time = parseInt(object.last_active_time, 10);
                    else if (typeof object.last_active_time === "number")
                        message.last_active_time = object.last_active_time;
                    else if (typeof object.last_active_time === "object")
                        message.last_active_time = new $util.LongBits(object.last_active_time.low >>> 0, object.last_active_time.high >>> 0).toNumber(true);
                if (object.level != null)
                    message.level = object.level >>> 0;
                if (object.shut_up_timestamp != null)
                    if ($util.Long)
                        (message.shut_up_timestamp = $util.Long.fromValue(object.shut_up_timestamp)).unsigned = true;
                    else if (typeof object.shut_up_timestamp === "string")
                        message.shut_up_timestamp = parseInt(object.shut_up_timestamp, 10);
                    else if (typeof object.shut_up_timestamp === "number")
                        message.shut_up_timestamp = object.shut_up_timestamp;
                    else if (typeof object.shut_up_timestamp === "object")
                        message.shut_up_timestamp = new $util.LongBits(object.shut_up_timestamp.low >>> 0, object.shut_up_timestamp.high >>> 0).toNumber(true);
                if (object.distance != null)
                    message.distance = object.distance >>> 0;
                if (object.honors) {
                    if (!Array.isArray(object.honors))
                        throw TypeError(".kritor.group.GroupMemberInfo.honors: array expected");
                    message.honors = [];
                    for (let i = 0; i < object.honors.length; ++i)
                        message.honors[i] = object.honors[i] >>> 0;
                }
                if (object.unfriendly != null)
                    message.unfriendly = Boolean(object.unfriendly);
                if (object.card_changeable != null)
                    message.card_changeable = Boolean(object.card_changeable);
                return message;
            };

            /**
             * Creates a plain object from a GroupMemberInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {kritor.group.GroupMemberInfo} message GroupMemberInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupMemberInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.honors = [];
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.nick = "";
                    object.age = 0;
                    object.unique_title = "";
                    object.unique_title_expire_time = 0;
                    object.card = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.join_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.join_time = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.last_active_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.last_active_time = options.longs === String ? "0" : 0;
                    object.level = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.shut_up_timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.shut_up_timestamp = options.longs === String ? "0" : 0;
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.nick != null && message.hasOwnProperty("nick"))
                    object.nick = message.nick;
                if (message.age != null && message.hasOwnProperty("age"))
                    object.age = message.age;
                if (message.unique_title != null && message.hasOwnProperty("unique_title"))
                    object.unique_title = message.unique_title;
                if (message.unique_title_expire_time != null && message.hasOwnProperty("unique_title_expire_time"))
                    object.unique_title_expire_time = message.unique_title_expire_time;
                if (message.card != null && message.hasOwnProperty("card"))
                    object.card = message.card;
                if (message.join_time != null && message.hasOwnProperty("join_time"))
                    if (typeof message.join_time === "number")
                        object.join_time = options.longs === String ? String(message.join_time) : message.join_time;
                    else
                        object.join_time = options.longs === String ? $util.Long.prototype.toString.call(message.join_time) : options.longs === Number ? new $util.LongBits(message.join_time.low >>> 0, message.join_time.high >>> 0).toNumber(true) : message.join_time;
                if (message.last_active_time != null && message.hasOwnProperty("last_active_time"))
                    if (typeof message.last_active_time === "number")
                        object.last_active_time = options.longs === String ? String(message.last_active_time) : message.last_active_time;
                    else
                        object.last_active_time = options.longs === String ? $util.Long.prototype.toString.call(message.last_active_time) : options.longs === Number ? new $util.LongBits(message.last_active_time.low >>> 0, message.last_active_time.high >>> 0).toNumber(true) : message.last_active_time;
                if (message.level != null && message.hasOwnProperty("level"))
                    object.level = message.level;
                if (message.shut_up_timestamp != null && message.hasOwnProperty("shut_up_timestamp"))
                    if (typeof message.shut_up_timestamp === "number")
                        object.shut_up_timestamp = options.longs === String ? String(message.shut_up_timestamp) : message.shut_up_timestamp;
                    else
                        object.shut_up_timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.shut_up_timestamp) : options.longs === Number ? new $util.LongBits(message.shut_up_timestamp.low >>> 0, message.shut_up_timestamp.high >>> 0).toNumber(true) : message.shut_up_timestamp;
                if (message.distance != null && message.hasOwnProperty("distance")) {
                    object.distance = message.distance;
                    if (options.oneofs)
                        object._distance = "distance";
                }
                if (message.honors && message.honors.length) {
                    object.honors = [];
                    for (let j = 0; j < message.honors.length; ++j)
                        object.honors[j] = message.honors[j];
                }
                if (message.unfriendly != null && message.hasOwnProperty("unfriendly")) {
                    object.unfriendly = message.unfriendly;
                    if (options.oneofs)
                        object._unfriendly = "unfriendly";
                }
                if (message.card_changeable != null && message.hasOwnProperty("card_changeable")) {
                    object.card_changeable = message.card_changeable;
                    if (options.oneofs)
                        object._card_changeable = "card_changeable";
                }
                return object;
            };

            /**
             * Converts this GroupMemberInfo to JSON.
             * @function toJSON
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupMemberInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupMemberInfo
             * @function getTypeUrl
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupMemberInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GroupMemberInfo";
            };

            return GroupMemberInfo;
        })();

        return group;
    })();

    kritor.guild = (function() {

        /**
         * Namespace guild.
         * @memberof kritor
         * @namespace
         */
        const guild = {};

        guild.GuildService = (function() {

            /**
             * Constructs a new GuildService service.
             * @memberof kritor.guild
             * @classdesc Represents a GuildService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function GuildService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (GuildService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = GuildService;

            /**
             * Creates new GuildService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.guild.GuildService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {GuildService} RPC service. Useful where requests and/or responses are streamed.
             */
            GuildService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.guild.GuildService#getBotInfo}.
             * @memberof kritor.guild.GuildService
             * @typedef GetBotInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetBotInfoResponse} [response] GetBotInfoResponse
             */

            /**
             * Calls GetBotInfo.
             * @function getBotInfo
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetBotInfoRequest} request GetBotInfoRequest message or plain object
             * @param {kritor.guild.GuildService.GetBotInfoCallback} callback Node-style callback called with the error, if any, and GetBotInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getBotInfo = function getBotInfo(request, callback) {
                return this.rpcCall(getBotInfo, $root.kritor.guild.GetBotInfoRequest, $root.kritor.guild.GetBotInfoResponse, request, callback);
            }, "name", { value: "GetBotInfo" });

            /**
             * Calls GetBotInfo.
             * @function getBotInfo
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetBotInfoRequest} request GetBotInfoRequest message or plain object
             * @returns {Promise<kritor.guild.GetBotInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getChannelList}.
             * @memberof kritor.guild.GuildService
             * @typedef GetChannelListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetChannelListResponse} [response] GetChannelListResponse
             */

            /**
             * Calls GetChannelList.
             * @function getChannelList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetChannelListRequest} request GetChannelListRequest message or plain object
             * @param {kritor.guild.GuildService.GetChannelListCallback} callback Node-style callback called with the error, if any, and GetChannelListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getChannelList = function getChannelList(request, callback) {
                return this.rpcCall(getChannelList, $root.kritor.guild.GetChannelListRequest, $root.kritor.guild.GetChannelListResponse, request, callback);
            }, "name", { value: "GetChannelList" });

            /**
             * Calls GetChannelList.
             * @function getChannelList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetChannelListRequest} request GetChannelListRequest message or plain object
             * @returns {Promise<kritor.guild.GetChannelListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildMetaByGuest}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildMetaByGuestCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildMetaByGuestResponse} [response] GetGuildMetaByGuestResponse
             */

            /**
             * Calls GetGuildMetaByGuest.
             * @function getGuildMetaByGuest
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMetaByGuestRequest} request GetGuildMetaByGuestRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildMetaByGuestCallback} callback Node-style callback called with the error, if any, and GetGuildMetaByGuestResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildMetaByGuest = function getGuildMetaByGuest(request, callback) {
                return this.rpcCall(getGuildMetaByGuest, $root.kritor.guild.GetGuildMetaByGuestRequest, $root.kritor.guild.GetGuildMetaByGuestResponse, request, callback);
            }, "name", { value: "GetGuildMetaByGuest" });

            /**
             * Calls GetGuildMetaByGuest.
             * @function getGuildMetaByGuest
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMetaByGuestRequest} request GetGuildMetaByGuestRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildMetaByGuestResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildChannelList}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildChannelListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildChannelListResponse} [response] GetGuildChannelListResponse
             */

            /**
             * Calls GetGuildChannelList.
             * @function getGuildChannelList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildChannelListRequest} request GetGuildChannelListRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildChannelListCallback} callback Node-style callback called with the error, if any, and GetGuildChannelListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildChannelList = function getGuildChannelList(request, callback) {
                return this.rpcCall(getGuildChannelList, $root.kritor.guild.GetGuildChannelListRequest, $root.kritor.guild.GetGuildChannelListResponse, request, callback);
            }, "name", { value: "GetGuildChannelList" });

            /**
             * Calls GetGuildChannelList.
             * @function getGuildChannelList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildChannelListRequest} request GetGuildChannelListRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildChannelListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildMemberList}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildMemberListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildMemberListResponse} [response] GetGuildMemberListResponse
             */

            /**
             * Calls GetGuildMemberList.
             * @function getGuildMemberList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMemberListRequest} request GetGuildMemberListRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildMemberListCallback} callback Node-style callback called with the error, if any, and GetGuildMemberListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildMemberList = function getGuildMemberList(request, callback) {
                return this.rpcCall(getGuildMemberList, $root.kritor.guild.GetGuildMemberListRequest, $root.kritor.guild.GetGuildMemberListResponse, request, callback);
            }, "name", { value: "GetGuildMemberList" });

            /**
             * Calls GetGuildMemberList.
             * @function getGuildMemberList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMemberListRequest} request GetGuildMemberListRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildMemberListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildMember}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildMemberCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildMemberResponse} [response] GetGuildMemberResponse
             */

            /**
             * Calls GetGuildMember.
             * @function getGuildMember
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMemberRequest} request GetGuildMemberRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildMemberCallback} callback Node-style callback called with the error, if any, and GetGuildMemberResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildMember = function getGuildMember(request, callback) {
                return this.rpcCall(getGuildMember, $root.kritor.guild.GetGuildMemberRequest, $root.kritor.guild.GetGuildMemberResponse, request, callback);
            }, "name", { value: "GetGuildMember" });

            /**
             * Calls GetGuildMember.
             * @function getGuildMember
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMemberRequest} request GetGuildMemberRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildMemberResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#sendChannelMessage}.
             * @memberof kritor.guild.GuildService
             * @typedef SendChannelMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.SendChannelMessageResponse} [response] SendChannelMessageResponse
             */

            /**
             * Calls SendChannelMessage.
             * @function sendChannelMessage
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ISendChannelMessageRequest} request SendChannelMessageRequest message or plain object
             * @param {kritor.guild.GuildService.SendChannelMessageCallback} callback Node-style callback called with the error, if any, and SendChannelMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.sendChannelMessage = function sendChannelMessage(request, callback) {
                return this.rpcCall(sendChannelMessage, $root.kritor.guild.SendChannelMessageRequest, $root.kritor.guild.SendChannelMessageResponse, request, callback);
            }, "name", { value: "SendChannelMessage" });

            /**
             * Calls SendChannelMessage.
             * @function sendChannelMessage
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ISendChannelMessageRequest} request SendChannelMessageRequest message or plain object
             * @returns {Promise<kritor.guild.SendChannelMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildFeedList}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildFeedListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildFeedListResponse} [response] GetGuildFeedListResponse
             */

            /**
             * Calls GetGuildFeedList.
             * @function getGuildFeedList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildFeedListRequest} request GetGuildFeedListRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildFeedListCallback} callback Node-style callback called with the error, if any, and GetGuildFeedListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildFeedList = function getGuildFeedList(request, callback) {
                return this.rpcCall(getGuildFeedList, $root.kritor.guild.GetGuildFeedListRequest, $root.kritor.guild.GetGuildFeedListResponse, request, callback);
            }, "name", { value: "GetGuildFeedList" });

            /**
             * Calls GetGuildFeedList.
             * @function getGuildFeedList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildFeedListRequest} request GetGuildFeedListRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildFeedListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildRoleList}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildRoleListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildRoleListResponse} [response] GetGuildRoleListResponse
             */

            /**
             * Calls GetGuildRoleList.
             * @function getGuildRoleList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildRoleListRequest} request GetGuildRoleListRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildRoleListCallback} callback Node-style callback called with the error, if any, and GetGuildRoleListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildRoleList = function getGuildRoleList(request, callback) {
                return this.rpcCall(getGuildRoleList, $root.kritor.guild.GetGuildRoleListRequest, $root.kritor.guild.GetGuildRoleListResponse, request, callback);
            }, "name", { value: "GetGuildRoleList" });

            /**
             * Calls GetGuildRoleList.
             * @function getGuildRoleList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildRoleListRequest} request GetGuildRoleListRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildRoleListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#deleteGuildRole}.
             * @memberof kritor.guild.GuildService
             * @typedef DeleteGuildRoleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.DeleteGuildRoleResponse} [response] DeleteGuildRoleResponse
             */

            /**
             * Calls DeleteGuildRole.
             * @function deleteGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IDeleteGuildRoleRequest} request DeleteGuildRoleRequest message or plain object
             * @param {kritor.guild.GuildService.DeleteGuildRoleCallback} callback Node-style callback called with the error, if any, and DeleteGuildRoleResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.deleteGuildRole = function deleteGuildRole(request, callback) {
                return this.rpcCall(deleteGuildRole, $root.kritor.guild.DeleteGuildRoleRequest, $root.kritor.guild.DeleteGuildRoleResponse, request, callback);
            }, "name", { value: "DeleteGuildRole" });

            /**
             * Calls DeleteGuildRole.
             * @function deleteGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IDeleteGuildRoleRequest} request DeleteGuildRoleRequest message or plain object
             * @returns {Promise<kritor.guild.DeleteGuildRoleResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#setGuildMemberRole}.
             * @memberof kritor.guild.GuildService
             * @typedef SetGuildMemberRoleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.SetGuildMemberRoleResponse} [response] SetGuildMemberRoleResponse
             */

            /**
             * Calls SetGuildMemberRole.
             * @function setGuildMemberRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ISetGuildMemberRoleRequest} request SetGuildMemberRoleRequest message or plain object
             * @param {kritor.guild.GuildService.SetGuildMemberRoleCallback} callback Node-style callback called with the error, if any, and SetGuildMemberRoleResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.setGuildMemberRole = function setGuildMemberRole(request, callback) {
                return this.rpcCall(setGuildMemberRole, $root.kritor.guild.SetGuildMemberRoleRequest, $root.kritor.guild.SetGuildMemberRoleResponse, request, callback);
            }, "name", { value: "SetGuildMemberRole" });

            /**
             * Calls SetGuildMemberRole.
             * @function setGuildMemberRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ISetGuildMemberRoleRequest} request SetGuildMemberRoleRequest message or plain object
             * @returns {Promise<kritor.guild.SetGuildMemberRoleResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#updateGuildRole}.
             * @memberof kritor.guild.GuildService
             * @typedef UpdateGuildRoleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.UpdateGuildRoleResponse} [response] UpdateGuildRoleResponse
             */

            /**
             * Calls UpdateGuildRole.
             * @function updateGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IUpdateGuildRoleRequest} request UpdateGuildRoleRequest message or plain object
             * @param {kritor.guild.GuildService.UpdateGuildRoleCallback} callback Node-style callback called with the error, if any, and UpdateGuildRoleResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.updateGuildRole = function updateGuildRole(request, callback) {
                return this.rpcCall(updateGuildRole, $root.kritor.guild.UpdateGuildRoleRequest, $root.kritor.guild.UpdateGuildRoleResponse, request, callback);
            }, "name", { value: "UpdateGuildRole" });

            /**
             * Calls UpdateGuildRole.
             * @function updateGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IUpdateGuildRoleRequest} request UpdateGuildRoleRequest message or plain object
             * @returns {Promise<kritor.guild.UpdateGuildRoleResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#createGuildRole}.
             * @memberof kritor.guild.GuildService
             * @typedef CreateGuildRoleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.CreateGuildRoleResponse} [response] CreateGuildRoleResponse
             */

            /**
             * Calls CreateGuildRole.
             * @function createGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ICreateGuildRoleRequest} request CreateGuildRoleRequest message or plain object
             * @param {kritor.guild.GuildService.CreateGuildRoleCallback} callback Node-style callback called with the error, if any, and CreateGuildRoleResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.createGuildRole = function createGuildRole(request, callback) {
                return this.rpcCall(createGuildRole, $root.kritor.guild.CreateGuildRoleRequest, $root.kritor.guild.CreateGuildRoleResponse, request, callback);
            }, "name", { value: "CreateGuildRole" });

            /**
             * Calls CreateGuildRole.
             * @function createGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ICreateGuildRoleRequest} request CreateGuildRoleRequest message or plain object
             * @returns {Promise<kritor.guild.CreateGuildRoleResponse>} Promise
             * @variation 2
             */

            return GuildService;
        })();

        guild.GetBotInfoRequest = (function() {

            /**
             * Properties of a GetBotInfoRequest.
             * @memberof kritor.guild
             * @interface IGetBotInfoRequest
             */

            /**
             * Constructs a new GetBotInfoRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetBotInfoRequest.
             * @implements IGetBotInfoRequest
             * @constructor
             * @param {kritor.guild.IGetBotInfoRequest=} [properties] Properties to set
             */
            function GetBotInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetBotInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {kritor.guild.IGetBotInfoRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetBotInfoRequest} GetBotInfoRequest instance
             */
            GetBotInfoRequest.create = function create(properties) {
                return new GetBotInfoRequest(properties);
            };

            /**
             * Encodes the specified GetBotInfoRequest message. Does not implicitly {@link kritor.guild.GetBotInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {kritor.guild.IGetBotInfoRequest} message GetBotInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetBotInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetBotInfoRequest message, length delimited. Does not implicitly {@link kritor.guild.GetBotInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {kritor.guild.IGetBotInfoRequest} message GetBotInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetBotInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetBotInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetBotInfoRequest} GetBotInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetBotInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetBotInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetBotInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetBotInfoRequest} GetBotInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetBotInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetBotInfoRequest message.
             * @function verify
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetBotInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetBotInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetBotInfoRequest} GetBotInfoRequest
             */
            GetBotInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetBotInfoRequest)
                    return object;
                return new $root.kritor.guild.GetBotInfoRequest();
            };

            /**
             * Creates a plain object from a GetBotInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {kritor.guild.GetBotInfoRequest} message GetBotInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetBotInfoRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetBotInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetBotInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetBotInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetBotInfoRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetBotInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetBotInfoRequest";
            };

            return GetBotInfoRequest;
        })();

        guild.GetBotInfoResponse = (function() {

            /**
             * Properties of a GetBotInfoResponse.
             * @memberof kritor.guild
             * @interface IGetBotInfoResponse
             * @property {string|null} [nickname] GetBotInfoResponse nickname
             * @property {number|Long|null} [tiny_id] GetBotInfoResponse tiny_id
             * @property {string|null} [avatar] GetBotInfoResponse avatar
             */

            /**
             * Constructs a new GetBotInfoResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetBotInfoResponse.
             * @implements IGetBotInfoResponse
             * @constructor
             * @param {kritor.guild.IGetBotInfoResponse=} [properties] Properties to set
             */
            function GetBotInfoResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetBotInfoResponse nickname.
             * @member {string} nickname
             * @memberof kritor.guild.GetBotInfoResponse
             * @instance
             */
            GetBotInfoResponse.prototype.nickname = "";

            /**
             * GetBotInfoResponse tiny_id.
             * @member {number|Long} tiny_id
             * @memberof kritor.guild.GetBotInfoResponse
             * @instance
             */
            GetBotInfoResponse.prototype.tiny_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetBotInfoResponse avatar.
             * @member {string} avatar
             * @memberof kritor.guild.GetBotInfoResponse
             * @instance
             */
            GetBotInfoResponse.prototype.avatar = "";

            /**
             * Creates a new GetBotInfoResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {kritor.guild.IGetBotInfoResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetBotInfoResponse} GetBotInfoResponse instance
             */
            GetBotInfoResponse.create = function create(properties) {
                return new GetBotInfoResponse(properties);
            };

            /**
             * Encodes the specified GetBotInfoResponse message. Does not implicitly {@link kritor.guild.GetBotInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {kritor.guild.IGetBotInfoResponse} message GetBotInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetBotInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nickname);
                if (message.tiny_id != null && Object.hasOwnProperty.call(message, "tiny_id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.tiny_id);
                if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatar);
                return writer;
            };

            /**
             * Encodes the specified GetBotInfoResponse message, length delimited. Does not implicitly {@link kritor.guild.GetBotInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {kritor.guild.IGetBotInfoResponse} message GetBotInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetBotInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetBotInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetBotInfoResponse} GetBotInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetBotInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetBotInfoResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.nickname = reader.string();
                            break;
                        }
                    case 2: {
                            message.tiny_id = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.avatar = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetBotInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetBotInfoResponse} GetBotInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetBotInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetBotInfoResponse message.
             * @function verify
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetBotInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    if (!$util.isString(message.nickname))
                        return "nickname: string expected";
                if (message.tiny_id != null && message.hasOwnProperty("tiny_id"))
                    if (!$util.isInteger(message.tiny_id) && !(message.tiny_id && $util.isInteger(message.tiny_id.low) && $util.isInteger(message.tiny_id.high)))
                        return "tiny_id: integer|Long expected";
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    if (!$util.isString(message.avatar))
                        return "avatar: string expected";
                return null;
            };

            /**
             * Creates a GetBotInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetBotInfoResponse} GetBotInfoResponse
             */
            GetBotInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetBotInfoResponse)
                    return object;
                let message = new $root.kritor.guild.GetBotInfoResponse();
                if (object.nickname != null)
                    message.nickname = String(object.nickname);
                if (object.tiny_id != null)
                    if ($util.Long)
                        (message.tiny_id = $util.Long.fromValue(object.tiny_id)).unsigned = true;
                    else if (typeof object.tiny_id === "string")
                        message.tiny_id = parseInt(object.tiny_id, 10);
                    else if (typeof object.tiny_id === "number")
                        message.tiny_id = object.tiny_id;
                    else if (typeof object.tiny_id === "object")
                        message.tiny_id = new $util.LongBits(object.tiny_id.low >>> 0, object.tiny_id.high >>> 0).toNumber(true);
                if (object.avatar != null)
                    message.avatar = String(object.avatar);
                return message;
            };

            /**
             * Creates a plain object from a GetBotInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {kritor.guild.GetBotInfoResponse} message GetBotInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetBotInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.nickname = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tiny_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tiny_id = options.longs === String ? "0" : 0;
                    object.avatar = "";
                }
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    object.nickname = message.nickname;
                if (message.tiny_id != null && message.hasOwnProperty("tiny_id"))
                    if (typeof message.tiny_id === "number")
                        object.tiny_id = options.longs === String ? String(message.tiny_id) : message.tiny_id;
                    else
                        object.tiny_id = options.longs === String ? $util.Long.prototype.toString.call(message.tiny_id) : options.longs === Number ? new $util.LongBits(message.tiny_id.low >>> 0, message.tiny_id.high >>> 0).toNumber(true) : message.tiny_id;
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    object.avatar = message.avatar;
                return object;
            };

            /**
             * Converts this GetBotInfoResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetBotInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetBotInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetBotInfoResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetBotInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetBotInfoResponse";
            };

            return GetBotInfoResponse;
        })();

        guild.GetChannelListRequest = (function() {

            /**
             * Properties of a GetChannelListRequest.
             * @memberof kritor.guild
             * @interface IGetChannelListRequest
             */

            /**
             * Constructs a new GetChannelListRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetChannelListRequest.
             * @implements IGetChannelListRequest
             * @constructor
             * @param {kritor.guild.IGetChannelListRequest=} [properties] Properties to set
             */
            function GetChannelListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetChannelListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {kritor.guild.IGetChannelListRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetChannelListRequest} GetChannelListRequest instance
             */
            GetChannelListRequest.create = function create(properties) {
                return new GetChannelListRequest(properties);
            };

            /**
             * Encodes the specified GetChannelListRequest message. Does not implicitly {@link kritor.guild.GetChannelListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {kritor.guild.IGetChannelListRequest} message GetChannelListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChannelListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetChannelListRequest message, length delimited. Does not implicitly {@link kritor.guild.GetChannelListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {kritor.guild.IGetChannelListRequest} message GetChannelListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChannelListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetChannelListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetChannelListRequest} GetChannelListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChannelListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetChannelListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetChannelListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetChannelListRequest} GetChannelListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChannelListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetChannelListRequest message.
             * @function verify
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetChannelListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetChannelListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetChannelListRequest} GetChannelListRequest
             */
            GetChannelListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetChannelListRequest)
                    return object;
                return new $root.kritor.guild.GetChannelListRequest();
            };

            /**
             * Creates a plain object from a GetChannelListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {kritor.guild.GetChannelListRequest} message GetChannelListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetChannelListRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetChannelListRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetChannelListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetChannelListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetChannelListRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetChannelListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetChannelListRequest";
            };

            return GetChannelListRequest;
        })();

        guild.GetChannelListResponse = (function() {

            /**
             * Properties of a GetChannelListResponse.
             * @memberof kritor.guild
             * @interface IGetChannelListResponse
             * @property {Array.<kritor.guild.IGuildInfo>|null} [get_guild_list] GetChannelListResponse get_guild_list
             */

            /**
             * Constructs a new GetChannelListResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetChannelListResponse.
             * @implements IGetChannelListResponse
             * @constructor
             * @param {kritor.guild.IGetChannelListResponse=} [properties] Properties to set
             */
            function GetChannelListResponse(properties) {
                this.get_guild_list = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetChannelListResponse get_guild_list.
             * @member {Array.<kritor.guild.IGuildInfo>} get_guild_list
             * @memberof kritor.guild.GetChannelListResponse
             * @instance
             */
            GetChannelListResponse.prototype.get_guild_list = $util.emptyArray;

            /**
             * Creates a new GetChannelListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {kritor.guild.IGetChannelListResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetChannelListResponse} GetChannelListResponse instance
             */
            GetChannelListResponse.create = function create(properties) {
                return new GetChannelListResponse(properties);
            };

            /**
             * Encodes the specified GetChannelListResponse message. Does not implicitly {@link kritor.guild.GetChannelListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {kritor.guild.IGetChannelListResponse} message GetChannelListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChannelListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.get_guild_list != null && message.get_guild_list.length)
                    for (let i = 0; i < message.get_guild_list.length; ++i)
                        $root.kritor.guild.GuildInfo.encode(message.get_guild_list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetChannelListResponse message, length delimited. Does not implicitly {@link kritor.guild.GetChannelListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {kritor.guild.IGetChannelListResponse} message GetChannelListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChannelListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetChannelListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetChannelListResponse} GetChannelListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChannelListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetChannelListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.get_guild_list && message.get_guild_list.length))
                                message.get_guild_list = [];
                            message.get_guild_list.push($root.kritor.guild.GuildInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetChannelListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetChannelListResponse} GetChannelListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChannelListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetChannelListResponse message.
             * @function verify
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetChannelListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.get_guild_list != null && message.hasOwnProperty("get_guild_list")) {
                    if (!Array.isArray(message.get_guild_list))
                        return "get_guild_list: array expected";
                    for (let i = 0; i < message.get_guild_list.length; ++i) {
                        let error = $root.kritor.guild.GuildInfo.verify(message.get_guild_list[i]);
                        if (error)
                            return "get_guild_list." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetChannelListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetChannelListResponse} GetChannelListResponse
             */
            GetChannelListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetChannelListResponse)
                    return object;
                let message = new $root.kritor.guild.GetChannelListResponse();
                if (object.get_guild_list) {
                    if (!Array.isArray(object.get_guild_list))
                        throw TypeError(".kritor.guild.GetChannelListResponse.get_guild_list: array expected");
                    message.get_guild_list = [];
                    for (let i = 0; i < object.get_guild_list.length; ++i) {
                        if (typeof object.get_guild_list[i] !== "object")
                            throw TypeError(".kritor.guild.GetChannelListResponse.get_guild_list: object expected");
                        message.get_guild_list[i] = $root.kritor.guild.GuildInfo.fromObject(object.get_guild_list[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetChannelListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {kritor.guild.GetChannelListResponse} message GetChannelListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetChannelListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.get_guild_list = [];
                if (message.get_guild_list && message.get_guild_list.length) {
                    object.get_guild_list = [];
                    for (let j = 0; j < message.get_guild_list.length; ++j)
                        object.get_guild_list[j] = $root.kritor.guild.GuildInfo.toObject(message.get_guild_list[j], options);
                }
                return object;
            };

            /**
             * Converts this GetChannelListResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetChannelListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetChannelListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetChannelListResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetChannelListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetChannelListResponse";
            };

            return GetChannelListResponse;
        })();

        guild.GetGuildMetaByGuestRequest = (function() {

            /**
             * Properties of a GetGuildMetaByGuestRequest.
             * @memberof kritor.guild
             * @interface IGetGuildMetaByGuestRequest
             * @property {number|Long|null} [guild_id] GetGuildMetaByGuestRequest guild_id
             */

            /**
             * Constructs a new GetGuildMetaByGuestRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMetaByGuestRequest.
             * @implements IGetGuildMetaByGuestRequest
             * @constructor
             * @param {kritor.guild.IGetGuildMetaByGuestRequest=} [properties] Properties to set
             */
            function GetGuildMetaByGuestRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMetaByGuestRequest guild_id.
             * @member {number|Long} guild_id
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @instance
             */
            GetGuildMetaByGuestRequest.prototype.guild_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetGuildMetaByGuestRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMetaByGuestRequest} GetGuildMetaByGuestRequest instance
             */
            GetGuildMetaByGuestRequest.create = function create(properties) {
                return new GetGuildMetaByGuestRequest(properties);
            };

            /**
             * Encodes the specified GetGuildMetaByGuestRequest message. Does not implicitly {@link kritor.guild.GetGuildMetaByGuestRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestRequest} message GetGuildMetaByGuestRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMetaByGuestRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guild_id != null && Object.hasOwnProperty.call(message, "guild_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guild_id);
                return writer;
            };

            /**
             * Encodes the specified GetGuildMetaByGuestRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMetaByGuestRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestRequest} message GetGuildMetaByGuestRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMetaByGuestRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMetaByGuestRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMetaByGuestRequest} GetGuildMetaByGuestRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMetaByGuestRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMetaByGuestRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guild_id = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMetaByGuestRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMetaByGuestRequest} GetGuildMetaByGuestRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMetaByGuestRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMetaByGuestRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMetaByGuestRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (!$util.isInteger(message.guild_id) && !(message.guild_id && $util.isInteger(message.guild_id.low) && $util.isInteger(message.guild_id.high)))
                        return "guild_id: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetGuildMetaByGuestRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMetaByGuestRequest} GetGuildMetaByGuestRequest
             */
            GetGuildMetaByGuestRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMetaByGuestRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildMetaByGuestRequest();
                if (object.guild_id != null)
                    if ($util.Long)
                        (message.guild_id = $util.Long.fromValue(object.guild_id)).unsigned = true;
                    else if (typeof object.guild_id === "string")
                        message.guild_id = parseInt(object.guild_id, 10);
                    else if (typeof object.guild_id === "number")
                        message.guild_id = object.guild_id;
                    else if (typeof object.guild_id === "object")
                        message.guild_id = new $util.LongBits(object.guild_id.low >>> 0, object.guild_id.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMetaByGuestRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {kritor.guild.GetGuildMetaByGuestRequest} message GetGuildMetaByGuestRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMetaByGuestRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guild_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guild_id = options.longs === String ? "0" : 0;
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (typeof message.guild_id === "number")
                        object.guild_id = options.longs === String ? String(message.guild_id) : message.guild_id;
                    else
                        object.guild_id = options.longs === String ? $util.Long.prototype.toString.call(message.guild_id) : options.longs === Number ? new $util.LongBits(message.guild_id.low >>> 0, message.guild_id.high >>> 0).toNumber(true) : message.guild_id;
                return object;
            };

            /**
             * Converts this GetGuildMetaByGuestRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMetaByGuestRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMetaByGuestRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMetaByGuestRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMetaByGuestRequest";
            };

            return GetGuildMetaByGuestRequest;
        })();

        guild.GetGuildMetaByGuestResponse = (function() {

            /**
             * Properties of a GetGuildMetaByGuestResponse.
             * @memberof kritor.guild
             * @interface IGetGuildMetaByGuestResponse
             * @property {number|Long|null} [guild_id] GetGuildMetaByGuestResponse guild_id
             * @property {string|null} [guild_name] GetGuildMetaByGuestResponse guild_name
             * @property {string|null} [guild_profile] GetGuildMetaByGuestResponse guild_profile
             * @property {number|Long|null} [create_time] GetGuildMetaByGuestResponse create_time
             * @property {number|Long|null} [max_member_count] GetGuildMetaByGuestResponse max_member_count
             * @property {number|Long|null} [max_robot_count] GetGuildMetaByGuestResponse max_robot_count
             * @property {number|Long|null} [max_admin_count] GetGuildMetaByGuestResponse max_admin_count
             * @property {number|Long|null} [member_count] GetGuildMetaByGuestResponse member_count
             * @property {number|Long|null} [owner_id] GetGuildMetaByGuestResponse owner_id
             * @property {string|null} [guild_display_id] GetGuildMetaByGuestResponse guild_display_id
             */

            /**
             * Constructs a new GetGuildMetaByGuestResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMetaByGuestResponse.
             * @implements IGetGuildMetaByGuestResponse
             * @constructor
             * @param {kritor.guild.IGetGuildMetaByGuestResponse=} [properties] Properties to set
             */
            function GetGuildMetaByGuestResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMetaByGuestResponse guild_id.
             * @member {number|Long} guild_id
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.guild_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse guild_name.
             * @member {string} guild_name
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.guild_name = "";

            /**
             * GetGuildMetaByGuestResponse guild_profile.
             * @member {string} guild_profile
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.guild_profile = "";

            /**
             * GetGuildMetaByGuestResponse create_time.
             * @member {number|Long} create_time
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.create_time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse max_member_count.
             * @member {number|Long} max_member_count
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.max_member_count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse max_robot_count.
             * @member {number|Long} max_robot_count
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.max_robot_count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse max_admin_count.
             * @member {number|Long} max_admin_count
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.max_admin_count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse member_count.
             * @member {number|Long} member_count
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.member_count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse owner_id.
             * @member {number|Long} owner_id
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.owner_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse guild_display_id.
             * @member {string} guild_display_id
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.guild_display_id = "";

            /**
             * Creates a new GetGuildMetaByGuestResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMetaByGuestResponse} GetGuildMetaByGuestResponse instance
             */
            GetGuildMetaByGuestResponse.create = function create(properties) {
                return new GetGuildMetaByGuestResponse(properties);
            };

            /**
             * Encodes the specified GetGuildMetaByGuestResponse message. Does not implicitly {@link kritor.guild.GetGuildMetaByGuestResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestResponse} message GetGuildMetaByGuestResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMetaByGuestResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guild_id != null && Object.hasOwnProperty.call(message, "guild_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guild_id);
                if (message.guild_name != null && Object.hasOwnProperty.call(message, "guild_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.guild_name);
                if (message.guild_profile != null && Object.hasOwnProperty.call(message, "guild_profile"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.guild_profile);
                if (message.create_time != null && Object.hasOwnProperty.call(message, "create_time"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.create_time);
                if (message.max_member_count != null && Object.hasOwnProperty.call(message, "max_member_count"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.max_member_count);
                if (message.max_robot_count != null && Object.hasOwnProperty.call(message, "max_robot_count"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.max_robot_count);
                if (message.max_admin_count != null && Object.hasOwnProperty.call(message, "max_admin_count"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.max_admin_count);
                if (message.member_count != null && Object.hasOwnProperty.call(message, "member_count"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.member_count);
                if (message.owner_id != null && Object.hasOwnProperty.call(message, "owner_id"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.owner_id);
                if (message.guild_display_id != null && Object.hasOwnProperty.call(message, "guild_display_id"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.guild_display_id);
                return writer;
            };

            /**
             * Encodes the specified GetGuildMetaByGuestResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMetaByGuestResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestResponse} message GetGuildMetaByGuestResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMetaByGuestResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMetaByGuestResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMetaByGuestResponse} GetGuildMetaByGuestResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMetaByGuestResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMetaByGuestResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guild_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.guild_name = reader.string();
                            break;
                        }
                    case 3: {
                            message.guild_profile = reader.string();
                            break;
                        }
                    case 4: {
                            message.create_time = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.max_member_count = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.max_robot_count = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.max_admin_count = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.member_count = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.owner_id = reader.uint64();
                            break;
                        }
                    case 10: {
                            message.guild_display_id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMetaByGuestResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMetaByGuestResponse} GetGuildMetaByGuestResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMetaByGuestResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMetaByGuestResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMetaByGuestResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (!$util.isInteger(message.guild_id) && !(message.guild_id && $util.isInteger(message.guild_id.low) && $util.isInteger(message.guild_id.high)))
                        return "guild_id: integer|Long expected";
                if (message.guild_name != null && message.hasOwnProperty("guild_name"))
                    if (!$util.isString(message.guild_name))
                        return "guild_name: string expected";
                if (message.guild_profile != null && message.hasOwnProperty("guild_profile"))
                    if (!$util.isString(message.guild_profile))
                        return "guild_profile: string expected";
                if (message.create_time != null && message.hasOwnProperty("create_time"))
                    if (!$util.isInteger(message.create_time) && !(message.create_time && $util.isInteger(message.create_time.low) && $util.isInteger(message.create_time.high)))
                        return "create_time: integer|Long expected";
                if (message.max_member_count != null && message.hasOwnProperty("max_member_count"))
                    if (!$util.isInteger(message.max_member_count) && !(message.max_member_count && $util.isInteger(message.max_member_count.low) && $util.isInteger(message.max_member_count.high)))
                        return "max_member_count: integer|Long expected";
                if (message.max_robot_count != null && message.hasOwnProperty("max_robot_count"))
                    if (!$util.isInteger(message.max_robot_count) && !(message.max_robot_count && $util.isInteger(message.max_robot_count.low) && $util.isInteger(message.max_robot_count.high)))
                        return "max_robot_count: integer|Long expected";
                if (message.max_admin_count != null && message.hasOwnProperty("max_admin_count"))
                    if (!$util.isInteger(message.max_admin_count) && !(message.max_admin_count && $util.isInteger(message.max_admin_count.low) && $util.isInteger(message.max_admin_count.high)))
                        return "max_admin_count: integer|Long expected";
                if (message.member_count != null && message.hasOwnProperty("member_count"))
                    if (!$util.isInteger(message.member_count) && !(message.member_count && $util.isInteger(message.member_count.low) && $util.isInteger(message.member_count.high)))
                        return "member_count: integer|Long expected";
                if (message.owner_id != null && message.hasOwnProperty("owner_id"))
                    if (!$util.isInteger(message.owner_id) && !(message.owner_id && $util.isInteger(message.owner_id.low) && $util.isInteger(message.owner_id.high)))
                        return "owner_id: integer|Long expected";
                if (message.guild_display_id != null && message.hasOwnProperty("guild_display_id"))
                    if (!$util.isString(message.guild_display_id))
                        return "guild_display_id: string expected";
                return null;
            };

            /**
             * Creates a GetGuildMetaByGuestResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMetaByGuestResponse} GetGuildMetaByGuestResponse
             */
            GetGuildMetaByGuestResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMetaByGuestResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildMetaByGuestResponse();
                if (object.guild_id != null)
                    if ($util.Long)
                        (message.guild_id = $util.Long.fromValue(object.guild_id)).unsigned = true;
                    else if (typeof object.guild_id === "string")
                        message.guild_id = parseInt(object.guild_id, 10);
                    else if (typeof object.guild_id === "number")
                        message.guild_id = object.guild_id;
                    else if (typeof object.guild_id === "object")
                        message.guild_id = new $util.LongBits(object.guild_id.low >>> 0, object.guild_id.high >>> 0).toNumber(true);
                if (object.guild_name != null)
                    message.guild_name = String(object.guild_name);
                if (object.guild_profile != null)
                    message.guild_profile = String(object.guild_profile);
                if (object.create_time != null)
                    if ($util.Long)
                        (message.create_time = $util.Long.fromValue(object.create_time)).unsigned = true;
                    else if (typeof object.create_time === "string")
                        message.create_time = parseInt(object.create_time, 10);
                    else if (typeof object.create_time === "number")
                        message.create_time = object.create_time;
                    else if (typeof object.create_time === "object")
                        message.create_time = new $util.LongBits(object.create_time.low >>> 0, object.create_time.high >>> 0).toNumber(true);
                if (object.max_member_count != null)
                    if ($util.Long)
                        (message.max_member_count = $util.Long.fromValue(object.max_member_count)).unsigned = true;
                    else if (typeof object.max_member_count === "string")
                        message.max_member_count = parseInt(object.max_member_count, 10);
                    else if (typeof object.max_member_count === "number")
                        message.max_member_count = object.max_member_count;
                    else if (typeof object.max_member_count === "object")
                        message.max_member_count = new $util.LongBits(object.max_member_count.low >>> 0, object.max_member_count.high >>> 0).toNumber(true);
                if (object.max_robot_count != null)
                    if ($util.Long)
                        (message.max_robot_count = $util.Long.fromValue(object.max_robot_count)).unsigned = true;
                    else if (typeof object.max_robot_count === "string")
                        message.max_robot_count = parseInt(object.max_robot_count, 10);
                    else if (typeof object.max_robot_count === "number")
                        message.max_robot_count = object.max_robot_count;
                    else if (typeof object.max_robot_count === "object")
                        message.max_robot_count = new $util.LongBits(object.max_robot_count.low >>> 0, object.max_robot_count.high >>> 0).toNumber(true);
                if (object.max_admin_count != null)
                    if ($util.Long)
                        (message.max_admin_count = $util.Long.fromValue(object.max_admin_count)).unsigned = true;
                    else if (typeof object.max_admin_count === "string")
                        message.max_admin_count = parseInt(object.max_admin_count, 10);
                    else if (typeof object.max_admin_count === "number")
                        message.max_admin_count = object.max_admin_count;
                    else if (typeof object.max_admin_count === "object")
                        message.max_admin_count = new $util.LongBits(object.max_admin_count.low >>> 0, object.max_admin_count.high >>> 0).toNumber(true);
                if (object.member_count != null)
                    if ($util.Long)
                        (message.member_count = $util.Long.fromValue(object.member_count)).unsigned = true;
                    else if (typeof object.member_count === "string")
                        message.member_count = parseInt(object.member_count, 10);
                    else if (typeof object.member_count === "number")
                        message.member_count = object.member_count;
                    else if (typeof object.member_count === "object")
                        message.member_count = new $util.LongBits(object.member_count.low >>> 0, object.member_count.high >>> 0).toNumber(true);
                if (object.owner_id != null)
                    if ($util.Long)
                        (message.owner_id = $util.Long.fromValue(object.owner_id)).unsigned = true;
                    else if (typeof object.owner_id === "string")
                        message.owner_id = parseInt(object.owner_id, 10);
                    else if (typeof object.owner_id === "number")
                        message.owner_id = object.owner_id;
                    else if (typeof object.owner_id === "object")
                        message.owner_id = new $util.LongBits(object.owner_id.low >>> 0, object.owner_id.high >>> 0).toNumber(true);
                if (object.guild_display_id != null)
                    message.guild_display_id = String(object.guild_display_id);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMetaByGuestResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {kritor.guild.GetGuildMetaByGuestResponse} message GetGuildMetaByGuestResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMetaByGuestResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guild_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guild_id = options.longs === String ? "0" : 0;
                    object.guild_name = "";
                    object.guild_profile = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.create_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.create_time = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.max_member_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.max_member_count = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.max_robot_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.max_robot_count = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.max_admin_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.max_admin_count = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.member_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.member_count = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.owner_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.owner_id = options.longs === String ? "0" : 0;
                    object.guild_display_id = "";
                }
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (typeof message.guild_id === "number")
                        object.guild_id = options.longs === String ? String(message.guild_id) : message.guild_id;
                    else
                        object.guild_id = options.longs === String ? $util.Long.prototype.toString.call(message.guild_id) : options.longs === Number ? new $util.LongBits(message.guild_id.low >>> 0, message.guild_id.high >>> 0).toNumber(true) : message.guild_id;
                if (message.guild_name != null && message.hasOwnProperty("guild_name"))
                    object.guild_name = message.guild_name;
                if (message.guild_profile != null && message.hasOwnProperty("guild_profile"))
                    object.guild_profile = message.guild_profile;
                if (message.create_time != null && message.hasOwnProperty("create_time"))
                    if (typeof message.create_time === "number")
                        object.create_time = options.longs === String ? String(message.create_time) : message.create_time;
                    else
                        object.create_time = options.longs === String ? $util.Long.prototype.toString.call(message.create_time) : options.longs === Number ? new $util.LongBits(message.create_time.low >>> 0, message.create_time.high >>> 0).toNumber(true) : message.create_time;
                if (message.max_member_count != null && message.hasOwnProperty("max_member_count"))
                    if (typeof message.max_member_count === "number")
                        object.max_member_count = options.longs === String ? String(message.max_member_count) : message.max_member_count;
                    else
                        object.max_member_count = options.longs === String ? $util.Long.prototype.toString.call(message.max_member_count) : options.longs === Number ? new $util.LongBits(message.max_member_count.low >>> 0, message.max_member_count.high >>> 0).toNumber(true) : message.max_member_count;
                if (message.max_robot_count != null && message.hasOwnProperty("max_robot_count"))
                    if (typeof message.max_robot_count === "number")
                        object.max_robot_count = options.longs === String ? String(message.max_robot_count) : message.max_robot_count;
                    else
                        object.max_robot_count = options.longs === String ? $util.Long.prototype.toString.call(message.max_robot_count) : options.longs === Number ? new $util.LongBits(message.max_robot_count.low >>> 0, message.max_robot_count.high >>> 0).toNumber(true) : message.max_robot_count;
                if (message.max_admin_count != null && message.hasOwnProperty("max_admin_count"))
                    if (typeof message.max_admin_count === "number")
                        object.max_admin_count = options.longs === String ? String(message.max_admin_count) : message.max_admin_count;
                    else
                        object.max_admin_count = options.longs === String ? $util.Long.prototype.toString.call(message.max_admin_count) : options.longs === Number ? new $util.LongBits(message.max_admin_count.low >>> 0, message.max_admin_count.high >>> 0).toNumber(true) : message.max_admin_count;
                if (message.member_count != null && message.hasOwnProperty("member_count"))
                    if (typeof message.member_count === "number")
                        object.member_count = options.longs === String ? String(message.member_count) : message.member_count;
                    else
                        object.member_count = options.longs === String ? $util.Long.prototype.toString.call(message.member_count) : options.longs === Number ? new $util.LongBits(message.member_count.low >>> 0, message.member_count.high >>> 0).toNumber(true) : message.member_count;
                if (message.owner_id != null && message.hasOwnProperty("owner_id"))
                    if (typeof message.owner_id === "number")
                        object.owner_id = options.longs === String ? String(message.owner_id) : message.owner_id;
                    else
                        object.owner_id = options.longs === String ? $util.Long.prototype.toString.call(message.owner_id) : options.longs === Number ? new $util.LongBits(message.owner_id.low >>> 0, message.owner_id.high >>> 0).toNumber(true) : message.owner_id;
                if (message.guild_display_id != null && message.hasOwnProperty("guild_display_id"))
                    object.guild_display_id = message.guild_display_id;
                return object;
            };

            /**
             * Converts this GetGuildMetaByGuestResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMetaByGuestResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMetaByGuestResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMetaByGuestResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMetaByGuestResponse";
            };

            return GetGuildMetaByGuestResponse;
        })();

        guild.GetGuildChannelListRequest = (function() {

            /**
             * Properties of a GetGuildChannelListRequest.
             * @memberof kritor.guild
             * @interface IGetGuildChannelListRequest
             * @property {number|Long|null} [guild_id] GetGuildChannelListRequest guild_id
             * @property {boolean|null} [refresh] GetGuildChannelListRequest refresh
             */

            /**
             * Constructs a new GetGuildChannelListRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildChannelListRequest.
             * @implements IGetGuildChannelListRequest
             * @constructor
             * @param {kritor.guild.IGetGuildChannelListRequest=} [properties] Properties to set
             */
            function GetGuildChannelListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildChannelListRequest guild_id.
             * @member {number|Long} guild_id
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @instance
             */
            GetGuildChannelListRequest.prototype.guild_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildChannelListRequest refresh.
             * @member {boolean} refresh
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @instance
             */
            GetGuildChannelListRequest.prototype.refresh = false;

            /**
             * Creates a new GetGuildChannelListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {kritor.guild.IGetGuildChannelListRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildChannelListRequest} GetGuildChannelListRequest instance
             */
            GetGuildChannelListRequest.create = function create(properties) {
                return new GetGuildChannelListRequest(properties);
            };

            /**
             * Encodes the specified GetGuildChannelListRequest message. Does not implicitly {@link kritor.guild.GetGuildChannelListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {kritor.guild.IGetGuildChannelListRequest} message GetGuildChannelListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildChannelListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guild_id != null && Object.hasOwnProperty.call(message, "guild_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guild_id);
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGuildChannelListRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildChannelListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {kritor.guild.IGetGuildChannelListRequest} message GetGuildChannelListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildChannelListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildChannelListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildChannelListRequest} GetGuildChannelListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildChannelListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildChannelListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guild_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildChannelListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildChannelListRequest} GetGuildChannelListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildChannelListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildChannelListRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildChannelListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (!$util.isInteger(message.guild_id) && !(message.guild_id && $util.isInteger(message.guild_id.low) && $util.isInteger(message.guild_id.high)))
                        return "guild_id: integer|Long expected";
                if (message.refresh != null && message.hasOwnProperty("refresh"))
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                return null;
            };

            /**
             * Creates a GetGuildChannelListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildChannelListRequest} GetGuildChannelListRequest
             */
            GetGuildChannelListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildChannelListRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildChannelListRequest();
                if (object.guild_id != null)
                    if ($util.Long)
                        (message.guild_id = $util.Long.fromValue(object.guild_id)).unsigned = true;
                    else if (typeof object.guild_id === "string")
                        message.guild_id = parseInt(object.guild_id, 10);
                    else if (typeof object.guild_id === "number")
                        message.guild_id = object.guild_id;
                    else if (typeof object.guild_id === "object")
                        message.guild_id = new $util.LongBits(object.guild_id.low >>> 0, object.guild_id.high >>> 0).toNumber(true);
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildChannelListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {kritor.guild.GetGuildChannelListRequest} message GetGuildChannelListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildChannelListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guild_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guild_id = options.longs === String ? "0" : 0;
                    object.refresh = false;
                }
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (typeof message.guild_id === "number")
                        object.guild_id = options.longs === String ? String(message.guild_id) : message.guild_id;
                    else
                        object.guild_id = options.longs === String ? $util.Long.prototype.toString.call(message.guild_id) : options.longs === Number ? new $util.LongBits(message.guild_id.low >>> 0, message.guild_id.high >>> 0).toNumber(true) : message.guild_id;
                if (message.refresh != null && message.hasOwnProperty("refresh"))
                    object.refresh = message.refresh;
                return object;
            };

            /**
             * Converts this GetGuildChannelListRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildChannelListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildChannelListRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildChannelListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildChannelListRequest";
            };

            return GetGuildChannelListRequest;
        })();

        guild.GetGuildChannelListResponse = (function() {

            /**
             * Properties of a GetGuildChannelListResponse.
             * @memberof kritor.guild
             * @interface IGetGuildChannelListResponse
             * @property {Array.<kritor.guild.IChannelInfo>|null} [channels_info] GetGuildChannelListResponse channels_info
             */

            /**
             * Constructs a new GetGuildChannelListResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildChannelListResponse.
             * @implements IGetGuildChannelListResponse
             * @constructor
             * @param {kritor.guild.IGetGuildChannelListResponse=} [properties] Properties to set
             */
            function GetGuildChannelListResponse(properties) {
                this.channels_info = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildChannelListResponse channels_info.
             * @member {Array.<kritor.guild.IChannelInfo>} channels_info
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @instance
             */
            GetGuildChannelListResponse.prototype.channels_info = $util.emptyArray;

            /**
             * Creates a new GetGuildChannelListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {kritor.guild.IGetGuildChannelListResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildChannelListResponse} GetGuildChannelListResponse instance
             */
            GetGuildChannelListResponse.create = function create(properties) {
                return new GetGuildChannelListResponse(properties);
            };

            /**
             * Encodes the specified GetGuildChannelListResponse message. Does not implicitly {@link kritor.guild.GetGuildChannelListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {kritor.guild.IGetGuildChannelListResponse} message GetGuildChannelListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildChannelListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channels_info != null && message.channels_info.length)
                    for (let i = 0; i < message.channels_info.length; ++i)
                        $root.kritor.guild.ChannelInfo.encode(message.channels_info[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGuildChannelListResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildChannelListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {kritor.guild.IGetGuildChannelListResponse} message GetGuildChannelListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildChannelListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildChannelListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildChannelListResponse} GetGuildChannelListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildChannelListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildChannelListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.channels_info && message.channels_info.length))
                                message.channels_info = [];
                            message.channels_info.push($root.kritor.guild.ChannelInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildChannelListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildChannelListResponse} GetGuildChannelListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildChannelListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildChannelListResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildChannelListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channels_info != null && message.hasOwnProperty("channels_info")) {
                    if (!Array.isArray(message.channels_info))
                        return "channels_info: array expected";
                    for (let i = 0; i < message.channels_info.length; ++i) {
                        let error = $root.kritor.guild.ChannelInfo.verify(message.channels_info[i]);
                        if (error)
                            return "channels_info." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetGuildChannelListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildChannelListResponse} GetGuildChannelListResponse
             */
            GetGuildChannelListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildChannelListResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildChannelListResponse();
                if (object.channels_info) {
                    if (!Array.isArray(object.channels_info))
                        throw TypeError(".kritor.guild.GetGuildChannelListResponse.channels_info: array expected");
                    message.channels_info = [];
                    for (let i = 0; i < object.channels_info.length; ++i) {
                        if (typeof object.channels_info[i] !== "object")
                            throw TypeError(".kritor.guild.GetGuildChannelListResponse.channels_info: object expected");
                        message.channels_info[i] = $root.kritor.guild.ChannelInfo.fromObject(object.channels_info[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGuildChannelListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {kritor.guild.GetGuildChannelListResponse} message GetGuildChannelListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildChannelListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.channels_info = [];
                if (message.channels_info && message.channels_info.length) {
                    object.channels_info = [];
                    for (let j = 0; j < message.channels_info.length; ++j)
                        object.channels_info[j] = $root.kritor.guild.ChannelInfo.toObject(message.channels_info[j], options);
                }
                return object;
            };

            /**
             * Converts this GetGuildChannelListResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildChannelListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildChannelListResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildChannelListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildChannelListResponse";
            };

            return GetGuildChannelListResponse;
        })();

        guild.GetGuildMemberListRequest = (function() {

            /**
             * Properties of a GetGuildMemberListRequest.
             * @memberof kritor.guild
             * @interface IGetGuildMemberListRequest
             * @property {number|Long|null} [guild_id] GetGuildMemberListRequest guild_id
             * @property {string|null} [next_token] GetGuildMemberListRequest next_token
             * @property {boolean|null} [all] GetGuildMemberListRequest all
             * @property {boolean|null} [refresh] GetGuildMemberListRequest refresh
             */

            /**
             * Constructs a new GetGuildMemberListRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMemberListRequest.
             * @implements IGetGuildMemberListRequest
             * @constructor
             * @param {kritor.guild.IGetGuildMemberListRequest=} [properties] Properties to set
             */
            function GetGuildMemberListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMemberListRequest guild_id.
             * @member {number|Long} guild_id
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @instance
             */
            GetGuildMemberListRequest.prototype.guild_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMemberListRequest next_token.
             * @member {string} next_token
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @instance
             */
            GetGuildMemberListRequest.prototype.next_token = "";

            /**
             * GetGuildMemberListRequest all.
             * @member {boolean} all
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @instance
             */
            GetGuildMemberListRequest.prototype.all = false;

            /**
             * GetGuildMemberListRequest refresh.
             * @member {boolean} refresh
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @instance
             */
            GetGuildMemberListRequest.prototype.refresh = false;

            /**
             * Creates a new GetGuildMemberListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberListRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMemberListRequest} GetGuildMemberListRequest instance
             */
            GetGuildMemberListRequest.create = function create(properties) {
                return new GetGuildMemberListRequest(properties);
            };

            /**
             * Encodes the specified GetGuildMemberListRequest message. Does not implicitly {@link kritor.guild.GetGuildMemberListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberListRequest} message GetGuildMemberListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guild_id != null && Object.hasOwnProperty.call(message, "guild_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guild_id);
                if (message.next_token != null && Object.hasOwnProperty.call(message, "next_token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.next_token);
                if (message.all != null && Object.hasOwnProperty.call(message, "all"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.all);
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGuildMemberListRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMemberListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberListRequest} message GetGuildMemberListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMemberListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMemberListRequest} GetGuildMemberListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMemberListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guild_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.next_token = reader.string();
                            break;
                        }
                    case 3: {
                            message.all = reader.bool();
                            break;
                        }
                    case 4: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMemberListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMemberListRequest} GetGuildMemberListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMemberListRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMemberListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (!$util.isInteger(message.guild_id) && !(message.guild_id && $util.isInteger(message.guild_id.low) && $util.isInteger(message.guild_id.high)))
                        return "guild_id: integer|Long expected";
                if (message.next_token != null && message.hasOwnProperty("next_token"))
                    if (!$util.isString(message.next_token))
                        return "next_token: string expected";
                if (message.all != null && message.hasOwnProperty("all"))
                    if (typeof message.all !== "boolean")
                        return "all: boolean expected";
                if (message.refresh != null && message.hasOwnProperty("refresh"))
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                return null;
            };

            /**
             * Creates a GetGuildMemberListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMemberListRequest} GetGuildMemberListRequest
             */
            GetGuildMemberListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMemberListRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildMemberListRequest();
                if (object.guild_id != null)
                    if ($util.Long)
                        (message.guild_id = $util.Long.fromValue(object.guild_id)).unsigned = true;
                    else if (typeof object.guild_id === "string")
                        message.guild_id = parseInt(object.guild_id, 10);
                    else if (typeof object.guild_id === "number")
                        message.guild_id = object.guild_id;
                    else if (typeof object.guild_id === "object")
                        message.guild_id = new $util.LongBits(object.guild_id.low >>> 0, object.guild_id.high >>> 0).toNumber(true);
                if (object.next_token != null)
                    message.next_token = String(object.next_token);
                if (object.all != null)
                    message.all = Boolean(object.all);
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMemberListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {kritor.guild.GetGuildMemberListRequest} message GetGuildMemberListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMemberListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guild_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guild_id = options.longs === String ? "0" : 0;
                    object.next_token = "";
                    object.all = false;
                    object.refresh = false;
                }
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (typeof message.guild_id === "number")
                        object.guild_id = options.longs === String ? String(message.guild_id) : message.guild_id;
                    else
                        object.guild_id = options.longs === String ? $util.Long.prototype.toString.call(message.guild_id) : options.longs === Number ? new $util.LongBits(message.guild_id.low >>> 0, message.guild_id.high >>> 0).toNumber(true) : message.guild_id;
                if (message.next_token != null && message.hasOwnProperty("next_token"))
                    object.next_token = message.next_token;
                if (message.all != null && message.hasOwnProperty("all"))
                    object.all = message.all;
                if (message.refresh != null && message.hasOwnProperty("refresh"))
                    object.refresh = message.refresh;
                return object;
            };

            /**
             * Converts this GetGuildMemberListRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMemberListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMemberListRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMemberListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMemberListRequest";
            };

            return GetGuildMemberListRequest;
        })();

        guild.GetGuildMemberListResponse = (function() {

            /**
             * Properties of a GetGuildMemberListResponse.
             * @memberof kritor.guild
             * @interface IGetGuildMemberListResponse
             * @property {Array.<kritor.guild.IMemberInfo>|null} [members_info] GetGuildMemberListResponse members_info
             * @property {string|null} [next_token] GetGuildMemberListResponse next_token
             * @property {boolean|null} [finished] GetGuildMemberListResponse finished
             */

            /**
             * Constructs a new GetGuildMemberListResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMemberListResponse.
             * @implements IGetGuildMemberListResponse
             * @constructor
             * @param {kritor.guild.IGetGuildMemberListResponse=} [properties] Properties to set
             */
            function GetGuildMemberListResponse(properties) {
                this.members_info = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMemberListResponse members_info.
             * @member {Array.<kritor.guild.IMemberInfo>} members_info
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @instance
             */
            GetGuildMemberListResponse.prototype.members_info = $util.emptyArray;

            /**
             * GetGuildMemberListResponse next_token.
             * @member {string} next_token
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @instance
             */
            GetGuildMemberListResponse.prototype.next_token = "";

            /**
             * GetGuildMemberListResponse finished.
             * @member {boolean} finished
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @instance
             */
            GetGuildMemberListResponse.prototype.finished = false;

            /**
             * Creates a new GetGuildMemberListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberListResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMemberListResponse} GetGuildMemberListResponse instance
             */
            GetGuildMemberListResponse.create = function create(properties) {
                return new GetGuildMemberListResponse(properties);
            };

            /**
             * Encodes the specified GetGuildMemberListResponse message. Does not implicitly {@link kritor.guild.GetGuildMemberListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberListResponse} message GetGuildMemberListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.members_info != null && message.members_info.length)
                    for (let i = 0; i < message.members_info.length; ++i)
                        $root.kritor.guild.MemberInfo.encode(message.members_info[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.next_token != null && Object.hasOwnProperty.call(message, "next_token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.next_token);
                if (message.finished != null && Object.hasOwnProperty.call(message, "finished"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.finished);
                return writer;
            };

            /**
             * Encodes the specified GetGuildMemberListResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMemberListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberListResponse} message GetGuildMemberListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMemberListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMemberListResponse} GetGuildMemberListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMemberListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.members_info && message.members_info.length))
                                message.members_info = [];
                            message.members_info.push($root.kritor.guild.MemberInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            message.next_token = reader.string();
                            break;
                        }
                    case 3: {
                            message.finished = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMemberListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMemberListResponse} GetGuildMemberListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMemberListResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMemberListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.members_info != null && message.hasOwnProperty("members_info")) {
                    if (!Array.isArray(message.members_info))
                        return "members_info: array expected";
                    for (let i = 0; i < message.members_info.length; ++i) {
                        let error = $root.kritor.guild.MemberInfo.verify(message.members_info[i]);
                        if (error)
                            return "members_info." + error;
                    }
                }
                if (message.next_token != null && message.hasOwnProperty("next_token"))
                    if (!$util.isString(message.next_token))
                        return "next_token: string expected";
                if (message.finished != null && message.hasOwnProperty("finished"))
                    if (typeof message.finished !== "boolean")
                        return "finished: boolean expected";
                return null;
            };

            /**
             * Creates a GetGuildMemberListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMemberListResponse} GetGuildMemberListResponse
             */
            GetGuildMemberListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMemberListResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildMemberListResponse();
                if (object.members_info) {
                    if (!Array.isArray(object.members_info))
                        throw TypeError(".kritor.guild.GetGuildMemberListResponse.members_info: array expected");
                    message.members_info = [];
                    for (let i = 0; i < object.members_info.length; ++i) {
                        if (typeof object.members_info[i] !== "object")
                            throw TypeError(".kritor.guild.GetGuildMemberListResponse.members_info: object expected");
                        message.members_info[i] = $root.kritor.guild.MemberInfo.fromObject(object.members_info[i]);
                    }
                }
                if (object.next_token != null)
                    message.next_token = String(object.next_token);
                if (object.finished != null)
                    message.finished = Boolean(object.finished);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMemberListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {kritor.guild.GetGuildMemberListResponse} message GetGuildMemberListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMemberListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.members_info = [];
                if (options.defaults) {
                    object.next_token = "";
                    object.finished = false;
                }
                if (message.members_info && message.members_info.length) {
                    object.members_info = [];
                    for (let j = 0; j < message.members_info.length; ++j)
                        object.members_info[j] = $root.kritor.guild.MemberInfo.toObject(message.members_info[j], options);
                }
                if (message.next_token != null && message.hasOwnProperty("next_token"))
                    object.next_token = message.next_token;
                if (message.finished != null && message.hasOwnProperty("finished"))
                    object.finished = message.finished;
                return object;
            };

            /**
             * Converts this GetGuildMemberListResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMemberListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMemberListResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMemberListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMemberListResponse";
            };

            return GetGuildMemberListResponse;
        })();

        guild.GetGuildMemberRequest = (function() {

            /**
             * Properties of a GetGuildMemberRequest.
             * @memberof kritor.guild
             * @interface IGetGuildMemberRequest
             * @property {number|Long|null} [guild_id] GetGuildMemberRequest guild_id
             * @property {number|Long|null} [tiny_id] GetGuildMemberRequest tiny_id
             */

            /**
             * Constructs a new GetGuildMemberRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMemberRequest.
             * @implements IGetGuildMemberRequest
             * @constructor
             * @param {kritor.guild.IGetGuildMemberRequest=} [properties] Properties to set
             */
            function GetGuildMemberRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMemberRequest guild_id.
             * @member {number|Long} guild_id
             * @memberof kritor.guild.GetGuildMemberRequest
             * @instance
             */
            GetGuildMemberRequest.prototype.guild_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMemberRequest tiny_id.
             * @member {number|Long} tiny_id
             * @memberof kritor.guild.GetGuildMemberRequest
             * @instance
             */
            GetGuildMemberRequest.prototype.tiny_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetGuildMemberRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMemberRequest} GetGuildMemberRequest instance
             */
            GetGuildMemberRequest.create = function create(properties) {
                return new GetGuildMemberRequest(properties);
            };

            /**
             * Encodes the specified GetGuildMemberRequest message. Does not implicitly {@link kritor.guild.GetGuildMemberRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberRequest} message GetGuildMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guild_id != null && Object.hasOwnProperty.call(message, "guild_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guild_id);
                if (message.tiny_id != null && Object.hasOwnProperty.call(message, "tiny_id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.tiny_id);
                return writer;
            };

            /**
             * Encodes the specified GetGuildMemberRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMemberRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberRequest} message GetGuildMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMemberRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMemberRequest} GetGuildMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMemberRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guild_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.tiny_id = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMemberRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMemberRequest} GetGuildMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMemberRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMemberRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (!$util.isInteger(message.guild_id) && !(message.guild_id && $util.isInteger(message.guild_id.low) && $util.isInteger(message.guild_id.high)))
                        return "guild_id: integer|Long expected";
                if (message.tiny_id != null && message.hasOwnProperty("tiny_id"))
                    if (!$util.isInteger(message.tiny_id) && !(message.tiny_id && $util.isInteger(message.tiny_id.low) && $util.isInteger(message.tiny_id.high)))
                        return "tiny_id: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetGuildMemberRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMemberRequest} GetGuildMemberRequest
             */
            GetGuildMemberRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMemberRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildMemberRequest();
                if (object.guild_id != null)
                    if ($util.Long)
                        (message.guild_id = $util.Long.fromValue(object.guild_id)).unsigned = true;
                    else if (typeof object.guild_id === "string")
                        message.guild_id = parseInt(object.guild_id, 10);
                    else if (typeof object.guild_id === "number")
                        message.guild_id = object.guild_id;
                    else if (typeof object.guild_id === "object")
                        message.guild_id = new $util.LongBits(object.guild_id.low >>> 0, object.guild_id.high >>> 0).toNumber(true);
                if (object.tiny_id != null)
                    if ($util.Long)
                        (message.tiny_id = $util.Long.fromValue(object.tiny_id)).unsigned = true;
                    else if (typeof object.tiny_id === "string")
                        message.tiny_id = parseInt(object.tiny_id, 10);
                    else if (typeof object.tiny_id === "number")
                        message.tiny_id = object.tiny_id;
                    else if (typeof object.tiny_id === "object")
                        message.tiny_id = new $util.LongBits(object.tiny_id.low >>> 0, object.tiny_id.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMemberRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {kritor.guild.GetGuildMemberRequest} message GetGuildMemberRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMemberRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guild_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guild_id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tiny_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tiny_id = options.longs === String ? "0" : 0;
                }
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (typeof message.guild_id === "number")
                        object.guild_id = options.longs === String ? String(message.guild_id) : message.guild_id;
                    else
                        object.guild_id = options.longs === String ? $util.Long.prototype.toString.call(message.guild_id) : options.longs === Number ? new $util.LongBits(message.guild_id.low >>> 0, message.guild_id.high >>> 0).toNumber(true) : message.guild_id;
                if (message.tiny_id != null && message.hasOwnProperty("tiny_id"))
                    if (typeof message.tiny_id === "number")
                        object.tiny_id = options.longs === String ? String(message.tiny_id) : message.tiny_id;
                    else
                        object.tiny_id = options.longs === String ? $util.Long.prototype.toString.call(message.tiny_id) : options.longs === Number ? new $util.LongBits(message.tiny_id.low >>> 0, message.tiny_id.high >>> 0).toNumber(true) : message.tiny_id;
                return object;
            };

            /**
             * Converts this GetGuildMemberRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMemberRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMemberRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMemberRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMemberRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMemberRequest";
            };

            return GetGuildMemberRequest;
        })();

        guild.GetGuildMemberResponse = (function() {

            /**
             * Properties of a GetGuildMemberResponse.
             * @memberof kritor.guild
             * @interface IGetGuildMemberResponse
             * @property {kritor.guild.IMemberProfile|null} [member_info] GetGuildMemberResponse member_info
             */

            /**
             * Constructs a new GetGuildMemberResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMemberResponse.
             * @implements IGetGuildMemberResponse
             * @constructor
             * @param {kritor.guild.IGetGuildMemberResponse=} [properties] Properties to set
             */
            function GetGuildMemberResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMemberResponse member_info.
             * @member {kritor.guild.IMemberProfile|null|undefined} member_info
             * @memberof kritor.guild.GetGuildMemberResponse
             * @instance
             */
            GetGuildMemberResponse.prototype.member_info = null;

            /**
             * Creates a new GetGuildMemberResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMemberResponse} GetGuildMemberResponse instance
             */
            GetGuildMemberResponse.create = function create(properties) {
                return new GetGuildMemberResponse(properties);
            };

            /**
             * Encodes the specified GetGuildMemberResponse message. Does not implicitly {@link kritor.guild.GetGuildMemberResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberResponse} message GetGuildMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.member_info != null && Object.hasOwnProperty.call(message, "member_info"))
                    $root.kritor.guild.MemberProfile.encode(message.member_info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGuildMemberResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMemberResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberResponse} message GetGuildMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMemberResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMemberResponse} GetGuildMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMemberResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.member_info = $root.kritor.guild.MemberProfile.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMemberResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMemberResponse} GetGuildMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMemberResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMemberResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.member_info != null && message.hasOwnProperty("member_info")) {
                    let error = $root.kritor.guild.MemberProfile.verify(message.member_info);
                    if (error)
                        return "member_info." + error;
                }
                return null;
            };

            /**
             * Creates a GetGuildMemberResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMemberResponse} GetGuildMemberResponse
             */
            GetGuildMemberResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMemberResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildMemberResponse();
                if (object.member_info != null) {
                    if (typeof object.member_info !== "object")
                        throw TypeError(".kritor.guild.GetGuildMemberResponse.member_info: object expected");
                    message.member_info = $root.kritor.guild.MemberProfile.fromObject(object.member_info);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMemberResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {kritor.guild.GetGuildMemberResponse} message GetGuildMemberResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMemberResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.member_info = null;
                if (message.member_info != null && message.hasOwnProperty("member_info"))
                    object.member_info = $root.kritor.guild.MemberProfile.toObject(message.member_info, options);
                return object;
            };

            /**
             * Converts this GetGuildMemberResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMemberResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMemberResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMemberResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMemberResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMemberResponse";
            };

            return GetGuildMemberResponse;
        })();

        guild.SendChannelMessageRequest = (function() {

            /**
             * Properties of a SendChannelMessageRequest.
             * @memberof kritor.guild
             * @interface ISendChannelMessageRequest
             * @property {number|Long|null} [guild_id] SendChannelMessageRequest guild_id
             * @property {number|Long|null} [channel_id] SendChannelMessageRequest channel_id
             * @property {string|null} [message] SendChannelMessageRequest message
             * @property {number|null} [retry_cnt] SendChannelMessageRequest retry_cnt
             * @property {number|Long|null} [recall_duration] SendChannelMessageRequest recall_duration
             */

            /**
             * Constructs a new SendChannelMessageRequest.
             * @memberof kritor.guild
             * @classdesc Represents a SendChannelMessageRequest.
             * @implements ISendChannelMessageRequest
             * @constructor
             * @param {kritor.guild.ISendChannelMessageRequest=} [properties] Properties to set
             */
            function SendChannelMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendChannelMessageRequest guild_id.
             * @member {number|Long} guild_id
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             */
            SendChannelMessageRequest.prototype.guild_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SendChannelMessageRequest channel_id.
             * @member {number|Long} channel_id
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             */
            SendChannelMessageRequest.prototype.channel_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SendChannelMessageRequest message.
             * @member {string} message
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             */
            SendChannelMessageRequest.prototype.message = "";

            /**
             * SendChannelMessageRequest retry_cnt.
             * @member {number} retry_cnt
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             */
            SendChannelMessageRequest.prototype.retry_cnt = 0;

            /**
             * SendChannelMessageRequest recall_duration.
             * @member {number|Long} recall_duration
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             */
            SendChannelMessageRequest.prototype.recall_duration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new SendChannelMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {kritor.guild.ISendChannelMessageRequest=} [properties] Properties to set
             * @returns {kritor.guild.SendChannelMessageRequest} SendChannelMessageRequest instance
             */
            SendChannelMessageRequest.create = function create(properties) {
                return new SendChannelMessageRequest(properties);
            };

            /**
             * Encodes the specified SendChannelMessageRequest message. Does not implicitly {@link kritor.guild.SendChannelMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {kritor.guild.ISendChannelMessageRequest} message SendChannelMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChannelMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guild_id != null && Object.hasOwnProperty.call(message, "guild_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guild_id);
                if (message.channel_id != null && Object.hasOwnProperty.call(message, "channel_id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.channel_id);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.message);
                if (message.retry_cnt != null && Object.hasOwnProperty.call(message, "retry_cnt"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.retry_cnt);
                if (message.recall_duration != null && Object.hasOwnProperty.call(message, "recall_duration"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.recall_duration);
                return writer;
            };

            /**
             * Encodes the specified SendChannelMessageRequest message, length delimited. Does not implicitly {@link kritor.guild.SendChannelMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {kritor.guild.ISendChannelMessageRequest} message SendChannelMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChannelMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendChannelMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.SendChannelMessageRequest} SendChannelMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChannelMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.SendChannelMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guild_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.channel_id = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.message = reader.string();
                            break;
                        }
                    case 4: {
                            message.retry_cnt = reader.int32();
                            break;
                        }
                    case 5: {
                            message.recall_duration = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendChannelMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.SendChannelMessageRequest} SendChannelMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChannelMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendChannelMessageRequest message.
             * @function verify
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendChannelMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (!$util.isInteger(message.guild_id) && !(message.guild_id && $util.isInteger(message.guild_id.low) && $util.isInteger(message.guild_id.high)))
                        return "guild_id: integer|Long expected";
                if (message.channel_id != null && message.hasOwnProperty("channel_id"))
                    if (!$util.isInteger(message.channel_id) && !(message.channel_id && $util.isInteger(message.channel_id.low) && $util.isInteger(message.channel_id.high)))
                        return "channel_id: integer|Long expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.retry_cnt != null && message.hasOwnProperty("retry_cnt"))
                    if (!$util.isInteger(message.retry_cnt))
                        return "retry_cnt: integer expected";
                if (message.recall_duration != null && message.hasOwnProperty("recall_duration"))
                    if (!$util.isInteger(message.recall_duration) && !(message.recall_duration && $util.isInteger(message.recall_duration.low) && $util.isInteger(message.recall_duration.high)))
                        return "recall_duration: integer|Long expected";
                return null;
            };

            /**
             * Creates a SendChannelMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.SendChannelMessageRequest} SendChannelMessageRequest
             */
            SendChannelMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.SendChannelMessageRequest)
                    return object;
                let message = new $root.kritor.guild.SendChannelMessageRequest();
                if (object.guild_id != null)
                    if ($util.Long)
                        (message.guild_id = $util.Long.fromValue(object.guild_id)).unsigned = true;
                    else if (typeof object.guild_id === "string")
                        message.guild_id = parseInt(object.guild_id, 10);
                    else if (typeof object.guild_id === "number")
                        message.guild_id = object.guild_id;
                    else if (typeof object.guild_id === "object")
                        message.guild_id = new $util.LongBits(object.guild_id.low >>> 0, object.guild_id.high >>> 0).toNumber(true);
                if (object.channel_id != null)
                    if ($util.Long)
                        (message.channel_id = $util.Long.fromValue(object.channel_id)).unsigned = true;
                    else if (typeof object.channel_id === "string")
                        message.channel_id = parseInt(object.channel_id, 10);
                    else if (typeof object.channel_id === "number")
                        message.channel_id = object.channel_id;
                    else if (typeof object.channel_id === "object")
                        message.channel_id = new $util.LongBits(object.channel_id.low >>> 0, object.channel_id.high >>> 0).toNumber(true);
                if (object.message != null)
                    message.message = String(object.message);
                if (object.retry_cnt != null)
                    message.retry_cnt = object.retry_cnt | 0;
                if (object.recall_duration != null)
                    if ($util.Long)
                        (message.recall_duration = $util.Long.fromValue(object.recall_duration)).unsigned = false;
                    else if (typeof object.recall_duration === "string")
                        message.recall_duration = parseInt(object.recall_duration, 10);
                    else if (typeof object.recall_duration === "number")
                        message.recall_duration = object.recall_duration;
                    else if (typeof object.recall_duration === "object")
                        message.recall_duration = new $util.LongBits(object.recall_duration.low >>> 0, object.recall_duration.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a SendChannelMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {kritor.guild.SendChannelMessageRequest} message SendChannelMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendChannelMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guild_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guild_id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.channel_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.channel_id = options.longs === String ? "0" : 0;
                    object.message = "";
                    object.retry_cnt = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.recall_duration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.recall_duration = options.longs === String ? "0" : 0;
                }
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (typeof message.guild_id === "number")
                        object.guild_id = options.longs === String ? String(message.guild_id) : message.guild_id;
                    else
                        object.guild_id = options.longs === String ? $util.Long.prototype.toString.call(message.guild_id) : options.longs === Number ? new $util.LongBits(message.guild_id.low >>> 0, message.guild_id.high >>> 0).toNumber(true) : message.guild_id;
                if (message.channel_id != null && message.hasOwnProperty("channel_id"))
                    if (typeof message.channel_id === "number")
                        object.channel_id = options.longs === String ? String(message.channel_id) : message.channel_id;
                    else
                        object.channel_id = options.longs === String ? $util.Long.prototype.toString.call(message.channel_id) : options.longs === Number ? new $util.LongBits(message.channel_id.low >>> 0, message.channel_id.high >>> 0).toNumber(true) : message.channel_id;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.retry_cnt != null && message.hasOwnProperty("retry_cnt"))
                    object.retry_cnt = message.retry_cnt;
                if (message.recall_duration != null && message.hasOwnProperty("recall_duration"))
                    if (typeof message.recall_duration === "number")
                        object.recall_duration = options.longs === String ? String(message.recall_duration) : message.recall_duration;
                    else
                        object.recall_duration = options.longs === String ? $util.Long.prototype.toString.call(message.recall_duration) : options.longs === Number ? new $util.LongBits(message.recall_duration.low >>> 0, message.recall_duration.high >>> 0).toNumber() : message.recall_duration;
                return object;
            };

            /**
             * Converts this SendChannelMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendChannelMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendChannelMessageRequest
             * @function getTypeUrl
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendChannelMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.SendChannelMessageRequest";
            };

            return SendChannelMessageRequest;
        })();

        guild.SendChannelMessageResponse = (function() {

            /**
             * Properties of a SendChannelMessageResponse.
             * @memberof kritor.guild
             * @interface ISendChannelMessageResponse
             * @property {string|null} [message_id] SendChannelMessageResponse message_id
             * @property {number|Long|null} [time] SendChannelMessageResponse time
             */

            /**
             * Constructs a new SendChannelMessageResponse.
             * @memberof kritor.guild
             * @classdesc Represents a SendChannelMessageResponse.
             * @implements ISendChannelMessageResponse
             * @constructor
             * @param {kritor.guild.ISendChannelMessageResponse=} [properties] Properties to set
             */
            function SendChannelMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendChannelMessageResponse message_id.
             * @member {string} message_id
             * @memberof kritor.guild.SendChannelMessageResponse
             * @instance
             */
            SendChannelMessageResponse.prototype.message_id = "";

            /**
             * SendChannelMessageResponse time.
             * @member {number|Long} time
             * @memberof kritor.guild.SendChannelMessageResponse
             * @instance
             */
            SendChannelMessageResponse.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new SendChannelMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {kritor.guild.ISendChannelMessageResponse=} [properties] Properties to set
             * @returns {kritor.guild.SendChannelMessageResponse} SendChannelMessageResponse instance
             */
            SendChannelMessageResponse.create = function create(properties) {
                return new SendChannelMessageResponse(properties);
            };

            /**
             * Encodes the specified SendChannelMessageResponse message. Does not implicitly {@link kritor.guild.SendChannelMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {kritor.guild.ISendChannelMessageResponse} message SendChannelMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChannelMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.message_id);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.time);
                return writer;
            };

            /**
             * Encodes the specified SendChannelMessageResponse message, length delimited. Does not implicitly {@link kritor.guild.SendChannelMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {kritor.guild.ISendChannelMessageResponse} message SendChannelMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChannelMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendChannelMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.SendChannelMessageResponse} SendChannelMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChannelMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.SendChannelMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.message_id = reader.string();
                            break;
                        }
                    case 2: {
                            message.time = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendChannelMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.SendChannelMessageResponse} SendChannelMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChannelMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendChannelMessageResponse message.
             * @function verify
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendChannelMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                        return "time: integer|Long expected";
                return null;
            };

            /**
             * Creates a SendChannelMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.SendChannelMessageResponse} SendChannelMessageResponse
             */
            SendChannelMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.SendChannelMessageResponse)
                    return object;
                let message = new $root.kritor.guild.SendChannelMessageResponse();
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                if (object.time != null)
                    if ($util.Long)
                        (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                    else if (typeof object.time === "string")
                        message.time = parseInt(object.time, 10);
                    else if (typeof object.time === "number")
                        message.time = object.time;
                    else if (typeof object.time === "object")
                        message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a SendChannelMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {kritor.guild.SendChannelMessageResponse} message SendChannelMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendChannelMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.message_id = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.time = options.longs === String ? "0" : 0;
                }
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    object.message_id = message.message_id;
                if (message.time != null && message.hasOwnProperty("time"))
                    if (typeof message.time === "number")
                        object.time = options.longs === String ? String(message.time) : message.time;
                    else
                        object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
                return object;
            };

            /**
             * Converts this SendChannelMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.SendChannelMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendChannelMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendChannelMessageResponse
             * @function getTypeUrl
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendChannelMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.SendChannelMessageResponse";
            };

            return SendChannelMessageResponse;
        })();

        guild.GetGuildFeedListRequest = (function() {

            /**
             * Properties of a GetGuildFeedListRequest.
             * @memberof kritor.guild
             * @interface IGetGuildFeedListRequest
             * @property {number|Long|null} [guild_id] GetGuildFeedListRequest guild_id
             * @property {number|null} [from] GetGuildFeedListRequest from
             */

            /**
             * Constructs a new GetGuildFeedListRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildFeedListRequest.
             * @implements IGetGuildFeedListRequest
             * @constructor
             * @param {kritor.guild.IGetGuildFeedListRequest=} [properties] Properties to set
             */
            function GetGuildFeedListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildFeedListRequest guild_id.
             * @member {number|Long} guild_id
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @instance
             */
            GetGuildFeedListRequest.prototype.guild_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildFeedListRequest from.
             * @member {number} from
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @instance
             */
            GetGuildFeedListRequest.prototype.from = 0;

            /**
             * Creates a new GetGuildFeedListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {kritor.guild.IGetGuildFeedListRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildFeedListRequest} GetGuildFeedListRequest instance
             */
            GetGuildFeedListRequest.create = function create(properties) {
                return new GetGuildFeedListRequest(properties);
            };

            /**
             * Encodes the specified GetGuildFeedListRequest message. Does not implicitly {@link kritor.guild.GetGuildFeedListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {kritor.guild.IGetGuildFeedListRequest} message GetGuildFeedListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildFeedListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guild_id != null && Object.hasOwnProperty.call(message, "guild_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guild_id);
                if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.from);
                return writer;
            };

            /**
             * Encodes the specified GetGuildFeedListRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildFeedListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {kritor.guild.IGetGuildFeedListRequest} message GetGuildFeedListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildFeedListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildFeedListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildFeedListRequest} GetGuildFeedListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildFeedListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildFeedListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guild_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.from = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildFeedListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildFeedListRequest} GetGuildFeedListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildFeedListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildFeedListRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildFeedListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (!$util.isInteger(message.guild_id) && !(message.guild_id && $util.isInteger(message.guild_id.low) && $util.isInteger(message.guild_id.high)))
                        return "guild_id: integer|Long expected";
                if (message.from != null && message.hasOwnProperty("from"))
                    if (!$util.isInteger(message.from))
                        return "from: integer expected";
                return null;
            };

            /**
             * Creates a GetGuildFeedListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildFeedListRequest} GetGuildFeedListRequest
             */
            GetGuildFeedListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildFeedListRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildFeedListRequest();
                if (object.guild_id != null)
                    if ($util.Long)
                        (message.guild_id = $util.Long.fromValue(object.guild_id)).unsigned = true;
                    else if (typeof object.guild_id === "string")
                        message.guild_id = parseInt(object.guild_id, 10);
                    else if (typeof object.guild_id === "number")
                        message.guild_id = object.guild_id;
                    else if (typeof object.guild_id === "object")
                        message.guild_id = new $util.LongBits(object.guild_id.low >>> 0, object.guild_id.high >>> 0).toNumber(true);
                if (object.from != null)
                    message.from = object.from >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetGuildFeedListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {kritor.guild.GetGuildFeedListRequest} message GetGuildFeedListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildFeedListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guild_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guild_id = options.longs === String ? "0" : 0;
                    object.from = 0;
                }
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (typeof message.guild_id === "number")
                        object.guild_id = options.longs === String ? String(message.guild_id) : message.guild_id;
                    else
                        object.guild_id = options.longs === String ? $util.Long.prototype.toString.call(message.guild_id) : options.longs === Number ? new $util.LongBits(message.guild_id.low >>> 0, message.guild_id.high >>> 0).toNumber(true) : message.guild_id;
                if (message.from != null && message.hasOwnProperty("from"))
                    object.from = message.from;
                return object;
            };

            /**
             * Converts this GetGuildFeedListRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildFeedListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildFeedListRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildFeedListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildFeedListRequest";
            };

            return GetGuildFeedListRequest;
        })();

        guild.GetGuildFeedListResponse = (function() {

            /**
             * Properties of a GetGuildFeedListResponse.
             * @memberof kritor.guild
             * @interface IGetGuildFeedListResponse
             * @property {Uint8Array|null} [data] GetGuildFeedListResponse data
             */

            /**
             * Constructs a new GetGuildFeedListResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildFeedListResponse.
             * @implements IGetGuildFeedListResponse
             * @constructor
             * @param {kritor.guild.IGetGuildFeedListResponse=} [properties] Properties to set
             */
            function GetGuildFeedListResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildFeedListResponse data.
             * @member {Uint8Array} data
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @instance
             */
            GetGuildFeedListResponse.prototype.data = $util.newBuffer([]);

            /**
             * Creates a new GetGuildFeedListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {kritor.guild.IGetGuildFeedListResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildFeedListResponse} GetGuildFeedListResponse instance
             */
            GetGuildFeedListResponse.create = function create(properties) {
                return new GetGuildFeedListResponse(properties);
            };

            /**
             * Encodes the specified GetGuildFeedListResponse message. Does not implicitly {@link kritor.guild.GetGuildFeedListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {kritor.guild.IGetGuildFeedListResponse} message GetGuildFeedListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildFeedListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
                return writer;
            };

            /**
             * Encodes the specified GetGuildFeedListResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildFeedListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {kritor.guild.IGetGuildFeedListResponse} message GetGuildFeedListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildFeedListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildFeedListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildFeedListResponse} GetGuildFeedListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildFeedListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildFeedListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.data = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildFeedListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildFeedListResponse} GetGuildFeedListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildFeedListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildFeedListResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildFeedListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };

            /**
             * Creates a GetGuildFeedListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildFeedListResponse} GetGuildFeedListResponse
             */
            GetGuildFeedListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildFeedListResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildFeedListResponse();
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length >= 0)
                        message.data = object.data;
                return message;
            };

            /**
             * Creates a plain object from a GetGuildFeedListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {kritor.guild.GetGuildFeedListResponse} message GetGuildFeedListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildFeedListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                return object;
            };

            /**
             * Converts this GetGuildFeedListResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildFeedListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildFeedListResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildFeedListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildFeedListResponse";
            };

            return GetGuildFeedListResponse;
        })();

        guild.GetGuildRoleListRequest = (function() {

            /**
             * Properties of a GetGuildRoleListRequest.
             * @memberof kritor.guild
             * @interface IGetGuildRoleListRequest
             * @property {number|Long|null} [guild_id] GetGuildRoleListRequest guild_id
             */

            /**
             * Constructs a new GetGuildRoleListRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildRoleListRequest.
             * @implements IGetGuildRoleListRequest
             * @constructor
             * @param {kritor.guild.IGetGuildRoleListRequest=} [properties] Properties to set
             */
            function GetGuildRoleListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildRoleListRequest guild_id.
             * @member {number|Long} guild_id
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @instance
             */
            GetGuildRoleListRequest.prototype.guild_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetGuildRoleListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {kritor.guild.IGetGuildRoleListRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildRoleListRequest} GetGuildRoleListRequest instance
             */
            GetGuildRoleListRequest.create = function create(properties) {
                return new GetGuildRoleListRequest(properties);
            };

            /**
             * Encodes the specified GetGuildRoleListRequest message. Does not implicitly {@link kritor.guild.GetGuildRoleListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {kritor.guild.IGetGuildRoleListRequest} message GetGuildRoleListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildRoleListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guild_id != null && Object.hasOwnProperty.call(message, "guild_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guild_id);
                return writer;
            };

            /**
             * Encodes the specified GetGuildRoleListRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildRoleListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {kritor.guild.IGetGuildRoleListRequest} message GetGuildRoleListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildRoleListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildRoleListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildRoleListRequest} GetGuildRoleListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildRoleListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildRoleListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guild_id = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildRoleListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildRoleListRequest} GetGuildRoleListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildRoleListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildRoleListRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildRoleListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (!$util.isInteger(message.guild_id) && !(message.guild_id && $util.isInteger(message.guild_id.low) && $util.isInteger(message.guild_id.high)))
                        return "guild_id: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetGuildRoleListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildRoleListRequest} GetGuildRoleListRequest
             */
            GetGuildRoleListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildRoleListRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildRoleListRequest();
                if (object.guild_id != null)
                    if ($util.Long)
                        (message.guild_id = $util.Long.fromValue(object.guild_id)).unsigned = true;
                    else if (typeof object.guild_id === "string")
                        message.guild_id = parseInt(object.guild_id, 10);
                    else if (typeof object.guild_id === "number")
                        message.guild_id = object.guild_id;
                    else if (typeof object.guild_id === "object")
                        message.guild_id = new $util.LongBits(object.guild_id.low >>> 0, object.guild_id.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildRoleListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {kritor.guild.GetGuildRoleListRequest} message GetGuildRoleListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildRoleListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guild_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guild_id = options.longs === String ? "0" : 0;
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (typeof message.guild_id === "number")
                        object.guild_id = options.longs === String ? String(message.guild_id) : message.guild_id;
                    else
                        object.guild_id = options.longs === String ? $util.Long.prototype.toString.call(message.guild_id) : options.longs === Number ? new $util.LongBits(message.guild_id.low >>> 0, message.guild_id.high >>> 0).toNumber(true) : message.guild_id;
                return object;
            };

            /**
             * Converts this GetGuildRoleListRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildRoleListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildRoleListRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildRoleListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildRoleListRequest";
            };

            return GetGuildRoleListRequest;
        })();

        guild.GetGuildRoleListResponse = (function() {

            /**
             * Properties of a GetGuildRoleListResponse.
             * @memberof kritor.guild
             * @interface IGetGuildRoleListResponse
             * @property {Array.<kritor.guild.IRoleInfo>|null} [roles_info] GetGuildRoleListResponse roles_info
             */

            /**
             * Constructs a new GetGuildRoleListResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildRoleListResponse.
             * @implements IGetGuildRoleListResponse
             * @constructor
             * @param {kritor.guild.IGetGuildRoleListResponse=} [properties] Properties to set
             */
            function GetGuildRoleListResponse(properties) {
                this.roles_info = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildRoleListResponse roles_info.
             * @member {Array.<kritor.guild.IRoleInfo>} roles_info
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @instance
             */
            GetGuildRoleListResponse.prototype.roles_info = $util.emptyArray;

            /**
             * Creates a new GetGuildRoleListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {kritor.guild.IGetGuildRoleListResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildRoleListResponse} GetGuildRoleListResponse instance
             */
            GetGuildRoleListResponse.create = function create(properties) {
                return new GetGuildRoleListResponse(properties);
            };

            /**
             * Encodes the specified GetGuildRoleListResponse message. Does not implicitly {@link kritor.guild.GetGuildRoleListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {kritor.guild.IGetGuildRoleListResponse} message GetGuildRoleListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildRoleListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roles_info != null && message.roles_info.length)
                    for (let i = 0; i < message.roles_info.length; ++i)
                        $root.kritor.guild.RoleInfo.encode(message.roles_info[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGuildRoleListResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildRoleListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {kritor.guild.IGetGuildRoleListResponse} message GetGuildRoleListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildRoleListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildRoleListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildRoleListResponse} GetGuildRoleListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildRoleListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildRoleListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.roles_info && message.roles_info.length))
                                message.roles_info = [];
                            message.roles_info.push($root.kritor.guild.RoleInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildRoleListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildRoleListResponse} GetGuildRoleListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildRoleListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildRoleListResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildRoleListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.roles_info != null && message.hasOwnProperty("roles_info")) {
                    if (!Array.isArray(message.roles_info))
                        return "roles_info: array expected";
                    for (let i = 0; i < message.roles_info.length; ++i) {
                        let error = $root.kritor.guild.RoleInfo.verify(message.roles_info[i]);
                        if (error)
                            return "roles_info." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetGuildRoleListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildRoleListResponse} GetGuildRoleListResponse
             */
            GetGuildRoleListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildRoleListResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildRoleListResponse();
                if (object.roles_info) {
                    if (!Array.isArray(object.roles_info))
                        throw TypeError(".kritor.guild.GetGuildRoleListResponse.roles_info: array expected");
                    message.roles_info = [];
                    for (let i = 0; i < object.roles_info.length; ++i) {
                        if (typeof object.roles_info[i] !== "object")
                            throw TypeError(".kritor.guild.GetGuildRoleListResponse.roles_info: object expected");
                        message.roles_info[i] = $root.kritor.guild.RoleInfo.fromObject(object.roles_info[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGuildRoleListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {kritor.guild.GetGuildRoleListResponse} message GetGuildRoleListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildRoleListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.roles_info = [];
                if (message.roles_info && message.roles_info.length) {
                    object.roles_info = [];
                    for (let j = 0; j < message.roles_info.length; ++j)
                        object.roles_info[j] = $root.kritor.guild.RoleInfo.toObject(message.roles_info[j], options);
                }
                return object;
            };

            /**
             * Converts this GetGuildRoleListResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildRoleListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildRoleListResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildRoleListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildRoleListResponse";
            };

            return GetGuildRoleListResponse;
        })();

        guild.DeleteGuildRoleRequest = (function() {

            /**
             * Properties of a DeleteGuildRoleRequest.
             * @memberof kritor.guild
             * @interface IDeleteGuildRoleRequest
             * @property {number|Long|null} [guild_id] DeleteGuildRoleRequest guild_id
             * @property {number|Long|null} [role_id] DeleteGuildRoleRequest role_id
             */

            /**
             * Constructs a new DeleteGuildRoleRequest.
             * @memberof kritor.guild
             * @classdesc Represents a DeleteGuildRoleRequest.
             * @implements IDeleteGuildRoleRequest
             * @constructor
             * @param {kritor.guild.IDeleteGuildRoleRequest=} [properties] Properties to set
             */
            function DeleteGuildRoleRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteGuildRoleRequest guild_id.
             * @member {number|Long} guild_id
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @instance
             */
            DeleteGuildRoleRequest.prototype.guild_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * DeleteGuildRoleRequest role_id.
             * @member {number|Long} role_id
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @instance
             */
            DeleteGuildRoleRequest.prototype.role_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new DeleteGuildRoleRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {kritor.guild.IDeleteGuildRoleRequest=} [properties] Properties to set
             * @returns {kritor.guild.DeleteGuildRoleRequest} DeleteGuildRoleRequest instance
             */
            DeleteGuildRoleRequest.create = function create(properties) {
                return new DeleteGuildRoleRequest(properties);
            };

            /**
             * Encodes the specified DeleteGuildRoleRequest message. Does not implicitly {@link kritor.guild.DeleteGuildRoleRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {kritor.guild.IDeleteGuildRoleRequest} message DeleteGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteGuildRoleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guild_id != null && Object.hasOwnProperty.call(message, "guild_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guild_id);
                if (message.role_id != null && Object.hasOwnProperty.call(message, "role_id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.role_id);
                return writer;
            };

            /**
             * Encodes the specified DeleteGuildRoleRequest message, length delimited. Does not implicitly {@link kritor.guild.DeleteGuildRoleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {kritor.guild.IDeleteGuildRoleRequest} message DeleteGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteGuildRoleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteGuildRoleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.DeleteGuildRoleRequest} DeleteGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteGuildRoleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.DeleteGuildRoleRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guild_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.role_id = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteGuildRoleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.DeleteGuildRoleRequest} DeleteGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteGuildRoleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteGuildRoleRequest message.
             * @function verify
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteGuildRoleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (!$util.isInteger(message.guild_id) && !(message.guild_id && $util.isInteger(message.guild_id.low) && $util.isInteger(message.guild_id.high)))
                        return "guild_id: integer|Long expected";
                if (message.role_id != null && message.hasOwnProperty("role_id"))
                    if (!$util.isInteger(message.role_id) && !(message.role_id && $util.isInteger(message.role_id.low) && $util.isInteger(message.role_id.high)))
                        return "role_id: integer|Long expected";
                return null;
            };

            /**
             * Creates a DeleteGuildRoleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.DeleteGuildRoleRequest} DeleteGuildRoleRequest
             */
            DeleteGuildRoleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.DeleteGuildRoleRequest)
                    return object;
                let message = new $root.kritor.guild.DeleteGuildRoleRequest();
                if (object.guild_id != null)
                    if ($util.Long)
                        (message.guild_id = $util.Long.fromValue(object.guild_id)).unsigned = true;
                    else if (typeof object.guild_id === "string")
                        message.guild_id = parseInt(object.guild_id, 10);
                    else if (typeof object.guild_id === "number")
                        message.guild_id = object.guild_id;
                    else if (typeof object.guild_id === "object")
                        message.guild_id = new $util.LongBits(object.guild_id.low >>> 0, object.guild_id.high >>> 0).toNumber(true);
                if (object.role_id != null)
                    if ($util.Long)
                        (message.role_id = $util.Long.fromValue(object.role_id)).unsigned = true;
                    else if (typeof object.role_id === "string")
                        message.role_id = parseInt(object.role_id, 10);
                    else if (typeof object.role_id === "number")
                        message.role_id = object.role_id;
                    else if (typeof object.role_id === "object")
                        message.role_id = new $util.LongBits(object.role_id.low >>> 0, object.role_id.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a DeleteGuildRoleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {kritor.guild.DeleteGuildRoleRequest} message DeleteGuildRoleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteGuildRoleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guild_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guild_id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.role_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.role_id = options.longs === String ? "0" : 0;
                }
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (typeof message.guild_id === "number")
                        object.guild_id = options.longs === String ? String(message.guild_id) : message.guild_id;
                    else
                        object.guild_id = options.longs === String ? $util.Long.prototype.toString.call(message.guild_id) : options.longs === Number ? new $util.LongBits(message.guild_id.low >>> 0, message.guild_id.high >>> 0).toNumber(true) : message.guild_id;
                if (message.role_id != null && message.hasOwnProperty("role_id"))
                    if (typeof message.role_id === "number")
                        object.role_id = options.longs === String ? String(message.role_id) : message.role_id;
                    else
                        object.role_id = options.longs === String ? $util.Long.prototype.toString.call(message.role_id) : options.longs === Number ? new $util.LongBits(message.role_id.low >>> 0, message.role_id.high >>> 0).toNumber(true) : message.role_id;
                return object;
            };

            /**
             * Converts this DeleteGuildRoleRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteGuildRoleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteGuildRoleRequest
             * @function getTypeUrl
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteGuildRoleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.DeleteGuildRoleRequest";
            };

            return DeleteGuildRoleRequest;
        })();

        guild.DeleteGuildRoleResponse = (function() {

            /**
             * Properties of a DeleteGuildRoleResponse.
             * @memberof kritor.guild
             * @interface IDeleteGuildRoleResponse
             */

            /**
             * Constructs a new DeleteGuildRoleResponse.
             * @memberof kritor.guild
             * @classdesc Represents a DeleteGuildRoleResponse.
             * @implements IDeleteGuildRoleResponse
             * @constructor
             * @param {kritor.guild.IDeleteGuildRoleResponse=} [properties] Properties to set
             */
            function DeleteGuildRoleResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteGuildRoleResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {kritor.guild.IDeleteGuildRoleResponse=} [properties] Properties to set
             * @returns {kritor.guild.DeleteGuildRoleResponse} DeleteGuildRoleResponse instance
             */
            DeleteGuildRoleResponse.create = function create(properties) {
                return new DeleteGuildRoleResponse(properties);
            };

            /**
             * Encodes the specified DeleteGuildRoleResponse message. Does not implicitly {@link kritor.guild.DeleteGuildRoleResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {kritor.guild.IDeleteGuildRoleResponse} message DeleteGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteGuildRoleResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteGuildRoleResponse message, length delimited. Does not implicitly {@link kritor.guild.DeleteGuildRoleResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {kritor.guild.IDeleteGuildRoleResponse} message DeleteGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteGuildRoleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteGuildRoleResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.DeleteGuildRoleResponse} DeleteGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteGuildRoleResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.DeleteGuildRoleResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteGuildRoleResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.DeleteGuildRoleResponse} DeleteGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteGuildRoleResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteGuildRoleResponse message.
             * @function verify
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteGuildRoleResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteGuildRoleResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.DeleteGuildRoleResponse} DeleteGuildRoleResponse
             */
            DeleteGuildRoleResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.DeleteGuildRoleResponse)
                    return object;
                return new $root.kritor.guild.DeleteGuildRoleResponse();
            };

            /**
             * Creates a plain object from a DeleteGuildRoleResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {kritor.guild.DeleteGuildRoleResponse} message DeleteGuildRoleResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteGuildRoleResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteGuildRoleResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteGuildRoleResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteGuildRoleResponse
             * @function getTypeUrl
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteGuildRoleResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.DeleteGuildRoleResponse";
            };

            return DeleteGuildRoleResponse;
        })();

        guild.SetGuildMemberRoleRequest = (function() {

            /**
             * Properties of a SetGuildMemberRoleRequest.
             * @memberof kritor.guild
             * @interface ISetGuildMemberRoleRequest
             * @property {number|Long|null} [guild_id] SetGuildMemberRoleRequest guild_id
             * @property {number|Long|null} [role_id] SetGuildMemberRoleRequest role_id
             * @property {boolean|null} [set] SetGuildMemberRoleRequest set
             * @property {Array.<string>|null} [tiny_ids] SetGuildMemberRoleRequest tiny_ids
             */

            /**
             * Constructs a new SetGuildMemberRoleRequest.
             * @memberof kritor.guild
             * @classdesc Represents a SetGuildMemberRoleRequest.
             * @implements ISetGuildMemberRoleRequest
             * @constructor
             * @param {kritor.guild.ISetGuildMemberRoleRequest=} [properties] Properties to set
             */
            function SetGuildMemberRoleRequest(properties) {
                this.tiny_ids = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetGuildMemberRoleRequest guild_id.
             * @member {number|Long} guild_id
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             */
            SetGuildMemberRoleRequest.prototype.guild_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetGuildMemberRoleRequest role_id.
             * @member {number|Long} role_id
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             */
            SetGuildMemberRoleRequest.prototype.role_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetGuildMemberRoleRequest set.
             * @member {boolean} set
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             */
            SetGuildMemberRoleRequest.prototype.set = false;

            /**
             * SetGuildMemberRoleRequest tiny_ids.
             * @member {Array.<string>} tiny_ids
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             */
            SetGuildMemberRoleRequest.prototype.tiny_ids = $util.emptyArray;

            /**
             * Creates a new SetGuildMemberRoleRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleRequest=} [properties] Properties to set
             * @returns {kritor.guild.SetGuildMemberRoleRequest} SetGuildMemberRoleRequest instance
             */
            SetGuildMemberRoleRequest.create = function create(properties) {
                return new SetGuildMemberRoleRequest(properties);
            };

            /**
             * Encodes the specified SetGuildMemberRoleRequest message. Does not implicitly {@link kritor.guild.SetGuildMemberRoleRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleRequest} message SetGuildMemberRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGuildMemberRoleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guild_id != null && Object.hasOwnProperty.call(message, "guild_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guild_id);
                if (message.role_id != null && Object.hasOwnProperty.call(message, "role_id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.role_id);
                if (message.set != null && Object.hasOwnProperty.call(message, "set"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.set);
                if (message.tiny_ids != null && message.tiny_ids.length)
                    for (let i = 0; i < message.tiny_ids.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.tiny_ids[i]);
                return writer;
            };

            /**
             * Encodes the specified SetGuildMemberRoleRequest message, length delimited. Does not implicitly {@link kritor.guild.SetGuildMemberRoleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleRequest} message SetGuildMemberRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGuildMemberRoleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGuildMemberRoleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.SetGuildMemberRoleRequest} SetGuildMemberRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGuildMemberRoleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.SetGuildMemberRoleRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guild_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.role_id = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.set = reader.bool();
                            break;
                        }
                    case 4: {
                            if (!(message.tiny_ids && message.tiny_ids.length))
                                message.tiny_ids = [];
                            message.tiny_ids.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGuildMemberRoleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.SetGuildMemberRoleRequest} SetGuildMemberRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGuildMemberRoleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGuildMemberRoleRequest message.
             * @function verify
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGuildMemberRoleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (!$util.isInteger(message.guild_id) && !(message.guild_id && $util.isInteger(message.guild_id.low) && $util.isInteger(message.guild_id.high)))
                        return "guild_id: integer|Long expected";
                if (message.role_id != null && message.hasOwnProperty("role_id"))
                    if (!$util.isInteger(message.role_id) && !(message.role_id && $util.isInteger(message.role_id.low) && $util.isInteger(message.role_id.high)))
                        return "role_id: integer|Long expected";
                if (message.set != null && message.hasOwnProperty("set"))
                    if (typeof message.set !== "boolean")
                        return "set: boolean expected";
                if (message.tiny_ids != null && message.hasOwnProperty("tiny_ids")) {
                    if (!Array.isArray(message.tiny_ids))
                        return "tiny_ids: array expected";
                    for (let i = 0; i < message.tiny_ids.length; ++i)
                        if (!$util.isString(message.tiny_ids[i]))
                            return "tiny_ids: string[] expected";
                }
                return null;
            };

            /**
             * Creates a SetGuildMemberRoleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.SetGuildMemberRoleRequest} SetGuildMemberRoleRequest
             */
            SetGuildMemberRoleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.SetGuildMemberRoleRequest)
                    return object;
                let message = new $root.kritor.guild.SetGuildMemberRoleRequest();
                if (object.guild_id != null)
                    if ($util.Long)
                        (message.guild_id = $util.Long.fromValue(object.guild_id)).unsigned = true;
                    else if (typeof object.guild_id === "string")
                        message.guild_id = parseInt(object.guild_id, 10);
                    else if (typeof object.guild_id === "number")
                        message.guild_id = object.guild_id;
                    else if (typeof object.guild_id === "object")
                        message.guild_id = new $util.LongBits(object.guild_id.low >>> 0, object.guild_id.high >>> 0).toNumber(true);
                if (object.role_id != null)
                    if ($util.Long)
                        (message.role_id = $util.Long.fromValue(object.role_id)).unsigned = true;
                    else if (typeof object.role_id === "string")
                        message.role_id = parseInt(object.role_id, 10);
                    else if (typeof object.role_id === "number")
                        message.role_id = object.role_id;
                    else if (typeof object.role_id === "object")
                        message.role_id = new $util.LongBits(object.role_id.low >>> 0, object.role_id.high >>> 0).toNumber(true);
                if (object.set != null)
                    message.set = Boolean(object.set);
                if (object.tiny_ids) {
                    if (!Array.isArray(object.tiny_ids))
                        throw TypeError(".kritor.guild.SetGuildMemberRoleRequest.tiny_ids: array expected");
                    message.tiny_ids = [];
                    for (let i = 0; i < object.tiny_ids.length; ++i)
                        message.tiny_ids[i] = String(object.tiny_ids[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a SetGuildMemberRoleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {kritor.guild.SetGuildMemberRoleRequest} message SetGuildMemberRoleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGuildMemberRoleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.tiny_ids = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guild_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guild_id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.role_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.role_id = options.longs === String ? "0" : 0;
                    object.set = false;
                }
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (typeof message.guild_id === "number")
                        object.guild_id = options.longs === String ? String(message.guild_id) : message.guild_id;
                    else
                        object.guild_id = options.longs === String ? $util.Long.prototype.toString.call(message.guild_id) : options.longs === Number ? new $util.LongBits(message.guild_id.low >>> 0, message.guild_id.high >>> 0).toNumber(true) : message.guild_id;
                if (message.role_id != null && message.hasOwnProperty("role_id"))
                    if (typeof message.role_id === "number")
                        object.role_id = options.longs === String ? String(message.role_id) : message.role_id;
                    else
                        object.role_id = options.longs === String ? $util.Long.prototype.toString.call(message.role_id) : options.longs === Number ? new $util.LongBits(message.role_id.low >>> 0, message.role_id.high >>> 0).toNumber(true) : message.role_id;
                if (message.set != null && message.hasOwnProperty("set"))
                    object.set = message.set;
                if (message.tiny_ids && message.tiny_ids.length) {
                    object.tiny_ids = [];
                    for (let j = 0; j < message.tiny_ids.length; ++j)
                        object.tiny_ids[j] = message.tiny_ids[j];
                }
                return object;
            };

            /**
             * Converts this SetGuildMemberRoleRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGuildMemberRoleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGuildMemberRoleRequest
             * @function getTypeUrl
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGuildMemberRoleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.SetGuildMemberRoleRequest";
            };

            return SetGuildMemberRoleRequest;
        })();

        guild.SetGuildMemberRoleResponse = (function() {

            /**
             * Properties of a SetGuildMemberRoleResponse.
             * @memberof kritor.guild
             * @interface ISetGuildMemberRoleResponse
             */

            /**
             * Constructs a new SetGuildMemberRoleResponse.
             * @memberof kritor.guild
             * @classdesc Represents a SetGuildMemberRoleResponse.
             * @implements ISetGuildMemberRoleResponse
             * @constructor
             * @param {kritor.guild.ISetGuildMemberRoleResponse=} [properties] Properties to set
             */
            function SetGuildMemberRoleResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetGuildMemberRoleResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleResponse=} [properties] Properties to set
             * @returns {kritor.guild.SetGuildMemberRoleResponse} SetGuildMemberRoleResponse instance
             */
            SetGuildMemberRoleResponse.create = function create(properties) {
                return new SetGuildMemberRoleResponse(properties);
            };

            /**
             * Encodes the specified SetGuildMemberRoleResponse message. Does not implicitly {@link kritor.guild.SetGuildMemberRoleResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleResponse} message SetGuildMemberRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGuildMemberRoleResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetGuildMemberRoleResponse message, length delimited. Does not implicitly {@link kritor.guild.SetGuildMemberRoleResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleResponse} message SetGuildMemberRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGuildMemberRoleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGuildMemberRoleResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.SetGuildMemberRoleResponse} SetGuildMemberRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGuildMemberRoleResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.SetGuildMemberRoleResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGuildMemberRoleResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.SetGuildMemberRoleResponse} SetGuildMemberRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGuildMemberRoleResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGuildMemberRoleResponse message.
             * @function verify
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGuildMemberRoleResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetGuildMemberRoleResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.SetGuildMemberRoleResponse} SetGuildMemberRoleResponse
             */
            SetGuildMemberRoleResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.SetGuildMemberRoleResponse)
                    return object;
                return new $root.kritor.guild.SetGuildMemberRoleResponse();
            };

            /**
             * Creates a plain object from a SetGuildMemberRoleResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {kritor.guild.SetGuildMemberRoleResponse} message SetGuildMemberRoleResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGuildMemberRoleResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetGuildMemberRoleResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGuildMemberRoleResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGuildMemberRoleResponse
             * @function getTypeUrl
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGuildMemberRoleResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.SetGuildMemberRoleResponse";
            };

            return SetGuildMemberRoleResponse;
        })();

        guild.UpdateGuildRoleRequest = (function() {

            /**
             * Properties of an UpdateGuildRoleRequest.
             * @memberof kritor.guild
             * @interface IUpdateGuildRoleRequest
             * @property {number|Long|null} [guild_id] UpdateGuildRoleRequest guild_id
             * @property {number|Long|null} [role_id] UpdateGuildRoleRequest role_id
             * @property {string|null} [name] UpdateGuildRoleRequest name
             * @property {number|Long|null} [color] UpdateGuildRoleRequest color
             */

            /**
             * Constructs a new UpdateGuildRoleRequest.
             * @memberof kritor.guild
             * @classdesc Represents an UpdateGuildRoleRequest.
             * @implements IUpdateGuildRoleRequest
             * @constructor
             * @param {kritor.guild.IUpdateGuildRoleRequest=} [properties] Properties to set
             */
            function UpdateGuildRoleRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UpdateGuildRoleRequest guild_id.
             * @member {number|Long} guild_id
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @instance
             */
            UpdateGuildRoleRequest.prototype.guild_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UpdateGuildRoleRequest role_id.
             * @member {number|Long} role_id
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @instance
             */
            UpdateGuildRoleRequest.prototype.role_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UpdateGuildRoleRequest name.
             * @member {string} name
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @instance
             */
            UpdateGuildRoleRequest.prototype.name = "";

            /**
             * UpdateGuildRoleRequest color.
             * @member {number|Long} color
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @instance
             */
            UpdateGuildRoleRequest.prototype.color = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new UpdateGuildRoleRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {kritor.guild.IUpdateGuildRoleRequest=} [properties] Properties to set
             * @returns {kritor.guild.UpdateGuildRoleRequest} UpdateGuildRoleRequest instance
             */
            UpdateGuildRoleRequest.create = function create(properties) {
                return new UpdateGuildRoleRequest(properties);
            };

            /**
             * Encodes the specified UpdateGuildRoleRequest message. Does not implicitly {@link kritor.guild.UpdateGuildRoleRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {kritor.guild.IUpdateGuildRoleRequest} message UpdateGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateGuildRoleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guild_id != null && Object.hasOwnProperty.call(message, "guild_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guild_id);
                if (message.role_id != null && Object.hasOwnProperty.call(message, "role_id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.role_id);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.color);
                return writer;
            };

            /**
             * Encodes the specified UpdateGuildRoleRequest message, length delimited. Does not implicitly {@link kritor.guild.UpdateGuildRoleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {kritor.guild.IUpdateGuildRoleRequest} message UpdateGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateGuildRoleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UpdateGuildRoleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.UpdateGuildRoleRequest} UpdateGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateGuildRoleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.UpdateGuildRoleRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guild_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.role_id = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.name = reader.string();
                            break;
                        }
                    case 4: {
                            message.color = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UpdateGuildRoleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.UpdateGuildRoleRequest} UpdateGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateGuildRoleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UpdateGuildRoleRequest message.
             * @function verify
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateGuildRoleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (!$util.isInteger(message.guild_id) && !(message.guild_id && $util.isInteger(message.guild_id.low) && $util.isInteger(message.guild_id.high)))
                        return "guild_id: integer|Long expected";
                if (message.role_id != null && message.hasOwnProperty("role_id"))
                    if (!$util.isInteger(message.role_id) && !(message.role_id && $util.isInteger(message.role_id.low) && $util.isInteger(message.role_id.high)))
                        return "role_id: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.color != null && message.hasOwnProperty("color"))
                    if (!$util.isInteger(message.color) && !(message.color && $util.isInteger(message.color.low) && $util.isInteger(message.color.high)))
                        return "color: integer|Long expected";
                return null;
            };

            /**
             * Creates an UpdateGuildRoleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.UpdateGuildRoleRequest} UpdateGuildRoleRequest
             */
            UpdateGuildRoleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.UpdateGuildRoleRequest)
                    return object;
                let message = new $root.kritor.guild.UpdateGuildRoleRequest();
                if (object.guild_id != null)
                    if ($util.Long)
                        (message.guild_id = $util.Long.fromValue(object.guild_id)).unsigned = true;
                    else if (typeof object.guild_id === "string")
                        message.guild_id = parseInt(object.guild_id, 10);
                    else if (typeof object.guild_id === "number")
                        message.guild_id = object.guild_id;
                    else if (typeof object.guild_id === "object")
                        message.guild_id = new $util.LongBits(object.guild_id.low >>> 0, object.guild_id.high >>> 0).toNumber(true);
                if (object.role_id != null)
                    if ($util.Long)
                        (message.role_id = $util.Long.fromValue(object.role_id)).unsigned = true;
                    else if (typeof object.role_id === "string")
                        message.role_id = parseInt(object.role_id, 10);
                    else if (typeof object.role_id === "number")
                        message.role_id = object.role_id;
                    else if (typeof object.role_id === "object")
                        message.role_id = new $util.LongBits(object.role_id.low >>> 0, object.role_id.high >>> 0).toNumber(true);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.color != null)
                    if ($util.Long)
                        (message.color = $util.Long.fromValue(object.color)).unsigned = false;
                    else if (typeof object.color === "string")
                        message.color = parseInt(object.color, 10);
                    else if (typeof object.color === "number")
                        message.color = object.color;
                    else if (typeof object.color === "object")
                        message.color = new $util.LongBits(object.color.low >>> 0, object.color.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an UpdateGuildRoleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {kritor.guild.UpdateGuildRoleRequest} message UpdateGuildRoleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateGuildRoleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guild_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guild_id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.role_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.role_id = options.longs === String ? "0" : 0;
                    object.name = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.color = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.color = options.longs === String ? "0" : 0;
                }
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (typeof message.guild_id === "number")
                        object.guild_id = options.longs === String ? String(message.guild_id) : message.guild_id;
                    else
                        object.guild_id = options.longs === String ? $util.Long.prototype.toString.call(message.guild_id) : options.longs === Number ? new $util.LongBits(message.guild_id.low >>> 0, message.guild_id.high >>> 0).toNumber(true) : message.guild_id;
                if (message.role_id != null && message.hasOwnProperty("role_id"))
                    if (typeof message.role_id === "number")
                        object.role_id = options.longs === String ? String(message.role_id) : message.role_id;
                    else
                        object.role_id = options.longs === String ? $util.Long.prototype.toString.call(message.role_id) : options.longs === Number ? new $util.LongBits(message.role_id.low >>> 0, message.role_id.high >>> 0).toNumber(true) : message.role_id;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.color != null && message.hasOwnProperty("color"))
                    if (typeof message.color === "number")
                        object.color = options.longs === String ? String(message.color) : message.color;
                    else
                        object.color = options.longs === String ? $util.Long.prototype.toString.call(message.color) : options.longs === Number ? new $util.LongBits(message.color.low >>> 0, message.color.high >>> 0).toNumber() : message.color;
                return object;
            };

            /**
             * Converts this UpdateGuildRoleRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateGuildRoleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UpdateGuildRoleRequest
             * @function getTypeUrl
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateGuildRoleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.UpdateGuildRoleRequest";
            };

            return UpdateGuildRoleRequest;
        })();

        guild.UpdateGuildRoleResponse = (function() {

            /**
             * Properties of an UpdateGuildRoleResponse.
             * @memberof kritor.guild
             * @interface IUpdateGuildRoleResponse
             */

            /**
             * Constructs a new UpdateGuildRoleResponse.
             * @memberof kritor.guild
             * @classdesc Represents an UpdateGuildRoleResponse.
             * @implements IUpdateGuildRoleResponse
             * @constructor
             * @param {kritor.guild.IUpdateGuildRoleResponse=} [properties] Properties to set
             */
            function UpdateGuildRoleResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new UpdateGuildRoleResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {kritor.guild.IUpdateGuildRoleResponse=} [properties] Properties to set
             * @returns {kritor.guild.UpdateGuildRoleResponse} UpdateGuildRoleResponse instance
             */
            UpdateGuildRoleResponse.create = function create(properties) {
                return new UpdateGuildRoleResponse(properties);
            };

            /**
             * Encodes the specified UpdateGuildRoleResponse message. Does not implicitly {@link kritor.guild.UpdateGuildRoleResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {kritor.guild.IUpdateGuildRoleResponse} message UpdateGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateGuildRoleResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified UpdateGuildRoleResponse message, length delimited. Does not implicitly {@link kritor.guild.UpdateGuildRoleResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {kritor.guild.IUpdateGuildRoleResponse} message UpdateGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateGuildRoleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UpdateGuildRoleResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.UpdateGuildRoleResponse} UpdateGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateGuildRoleResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.UpdateGuildRoleResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UpdateGuildRoleResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.UpdateGuildRoleResponse} UpdateGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateGuildRoleResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UpdateGuildRoleResponse message.
             * @function verify
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateGuildRoleResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an UpdateGuildRoleResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.UpdateGuildRoleResponse} UpdateGuildRoleResponse
             */
            UpdateGuildRoleResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.UpdateGuildRoleResponse)
                    return object;
                return new $root.kritor.guild.UpdateGuildRoleResponse();
            };

            /**
             * Creates a plain object from an UpdateGuildRoleResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {kritor.guild.UpdateGuildRoleResponse} message UpdateGuildRoleResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateGuildRoleResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this UpdateGuildRoleResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateGuildRoleResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UpdateGuildRoleResponse
             * @function getTypeUrl
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateGuildRoleResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.UpdateGuildRoleResponse";
            };

            return UpdateGuildRoleResponse;
        })();

        guild.CreateGuildRoleRequest = (function() {

            /**
             * Properties of a CreateGuildRoleRequest.
             * @memberof kritor.guild
             * @interface ICreateGuildRoleRequest
             * @property {number|Long|null} [guild_id] CreateGuildRoleRequest guild_id
             * @property {string|null} [name] CreateGuildRoleRequest name
             * @property {number|Long|null} [color] CreateGuildRoleRequest color
             */

            /**
             * Constructs a new CreateGuildRoleRequest.
             * @memberof kritor.guild
             * @classdesc Represents a CreateGuildRoleRequest.
             * @implements ICreateGuildRoleRequest
             * @constructor
             * @param {kritor.guild.ICreateGuildRoleRequest=} [properties] Properties to set
             */
            function CreateGuildRoleRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateGuildRoleRequest guild_id.
             * @member {number|Long} guild_id
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @instance
             */
            CreateGuildRoleRequest.prototype.guild_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * CreateGuildRoleRequest name.
             * @member {string} name
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @instance
             */
            CreateGuildRoleRequest.prototype.name = "";

            /**
             * CreateGuildRoleRequest color.
             * @member {number|Long} color
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @instance
             */
            CreateGuildRoleRequest.prototype.color = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new CreateGuildRoleRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {kritor.guild.ICreateGuildRoleRequest=} [properties] Properties to set
             * @returns {kritor.guild.CreateGuildRoleRequest} CreateGuildRoleRequest instance
             */
            CreateGuildRoleRequest.create = function create(properties) {
                return new CreateGuildRoleRequest(properties);
            };

            /**
             * Encodes the specified CreateGuildRoleRequest message. Does not implicitly {@link kritor.guild.CreateGuildRoleRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {kritor.guild.ICreateGuildRoleRequest} message CreateGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGuildRoleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guild_id != null && Object.hasOwnProperty.call(message, "guild_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guild_id);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.color);
                return writer;
            };

            /**
             * Encodes the specified CreateGuildRoleRequest message, length delimited. Does not implicitly {@link kritor.guild.CreateGuildRoleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {kritor.guild.ICreateGuildRoleRequest} message CreateGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGuildRoleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateGuildRoleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.CreateGuildRoleRequest} CreateGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGuildRoleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.CreateGuildRoleRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guild_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.color = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateGuildRoleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.CreateGuildRoleRequest} CreateGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGuildRoleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateGuildRoleRequest message.
             * @function verify
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateGuildRoleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (!$util.isInteger(message.guild_id) && !(message.guild_id && $util.isInteger(message.guild_id.low) && $util.isInteger(message.guild_id.high)))
                        return "guild_id: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.color != null && message.hasOwnProperty("color"))
                    if (!$util.isInteger(message.color) && !(message.color && $util.isInteger(message.color.low) && $util.isInteger(message.color.high)))
                        return "color: integer|Long expected";
                return null;
            };

            /**
             * Creates a CreateGuildRoleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.CreateGuildRoleRequest} CreateGuildRoleRequest
             */
            CreateGuildRoleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.CreateGuildRoleRequest)
                    return object;
                let message = new $root.kritor.guild.CreateGuildRoleRequest();
                if (object.guild_id != null)
                    if ($util.Long)
                        (message.guild_id = $util.Long.fromValue(object.guild_id)).unsigned = true;
                    else if (typeof object.guild_id === "string")
                        message.guild_id = parseInt(object.guild_id, 10);
                    else if (typeof object.guild_id === "number")
                        message.guild_id = object.guild_id;
                    else if (typeof object.guild_id === "object")
                        message.guild_id = new $util.LongBits(object.guild_id.low >>> 0, object.guild_id.high >>> 0).toNumber(true);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.color != null)
                    if ($util.Long)
                        (message.color = $util.Long.fromValue(object.color)).unsigned = false;
                    else if (typeof object.color === "string")
                        message.color = parseInt(object.color, 10);
                    else if (typeof object.color === "number")
                        message.color = object.color;
                    else if (typeof object.color === "object")
                        message.color = new $util.LongBits(object.color.low >>> 0, object.color.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a CreateGuildRoleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {kritor.guild.CreateGuildRoleRequest} message CreateGuildRoleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateGuildRoleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guild_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guild_id = options.longs === String ? "0" : 0;
                    object.name = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.color = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.color = options.longs === String ? "0" : 0;
                }
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (typeof message.guild_id === "number")
                        object.guild_id = options.longs === String ? String(message.guild_id) : message.guild_id;
                    else
                        object.guild_id = options.longs === String ? $util.Long.prototype.toString.call(message.guild_id) : options.longs === Number ? new $util.LongBits(message.guild_id.low >>> 0, message.guild_id.high >>> 0).toNumber(true) : message.guild_id;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.color != null && message.hasOwnProperty("color"))
                    if (typeof message.color === "number")
                        object.color = options.longs === String ? String(message.color) : message.color;
                    else
                        object.color = options.longs === String ? $util.Long.prototype.toString.call(message.color) : options.longs === Number ? new $util.LongBits(message.color.low >>> 0, message.color.high >>> 0).toNumber() : message.color;
                return object;
            };

            /**
             * Converts this CreateGuildRoleRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateGuildRoleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateGuildRoleRequest
             * @function getTypeUrl
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateGuildRoleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.CreateGuildRoleRequest";
            };

            return CreateGuildRoleRequest;
        })();

        guild.CreateGuildRoleResponse = (function() {

            /**
             * Properties of a CreateGuildRoleResponse.
             * @memberof kritor.guild
             * @interface ICreateGuildRoleResponse
             * @property {number|Long|null} [role_id] CreateGuildRoleResponse role_id
             */

            /**
             * Constructs a new CreateGuildRoleResponse.
             * @memberof kritor.guild
             * @classdesc Represents a CreateGuildRoleResponse.
             * @implements ICreateGuildRoleResponse
             * @constructor
             * @param {kritor.guild.ICreateGuildRoleResponse=} [properties] Properties to set
             */
            function CreateGuildRoleResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateGuildRoleResponse role_id.
             * @member {number|Long} role_id
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @instance
             */
            CreateGuildRoleResponse.prototype.role_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new CreateGuildRoleResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {kritor.guild.ICreateGuildRoleResponse=} [properties] Properties to set
             * @returns {kritor.guild.CreateGuildRoleResponse} CreateGuildRoleResponse instance
             */
            CreateGuildRoleResponse.create = function create(properties) {
                return new CreateGuildRoleResponse(properties);
            };

            /**
             * Encodes the specified CreateGuildRoleResponse message. Does not implicitly {@link kritor.guild.CreateGuildRoleResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {kritor.guild.ICreateGuildRoleResponse} message CreateGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGuildRoleResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.role_id != null && Object.hasOwnProperty.call(message, "role_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.role_id);
                return writer;
            };

            /**
             * Encodes the specified CreateGuildRoleResponse message, length delimited. Does not implicitly {@link kritor.guild.CreateGuildRoleResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {kritor.guild.ICreateGuildRoleResponse} message CreateGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGuildRoleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateGuildRoleResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.CreateGuildRoleResponse} CreateGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGuildRoleResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.CreateGuildRoleResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.role_id = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateGuildRoleResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.CreateGuildRoleResponse} CreateGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGuildRoleResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateGuildRoleResponse message.
             * @function verify
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateGuildRoleResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.role_id != null && message.hasOwnProperty("role_id"))
                    if (!$util.isInteger(message.role_id) && !(message.role_id && $util.isInteger(message.role_id.low) && $util.isInteger(message.role_id.high)))
                        return "role_id: integer|Long expected";
                return null;
            };

            /**
             * Creates a CreateGuildRoleResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.CreateGuildRoleResponse} CreateGuildRoleResponse
             */
            CreateGuildRoleResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.CreateGuildRoleResponse)
                    return object;
                let message = new $root.kritor.guild.CreateGuildRoleResponse();
                if (object.role_id != null)
                    if ($util.Long)
                        (message.role_id = $util.Long.fromValue(object.role_id)).unsigned = true;
                    else if (typeof object.role_id === "string")
                        message.role_id = parseInt(object.role_id, 10);
                    else if (typeof object.role_id === "number")
                        message.role_id = object.role_id;
                    else if (typeof object.role_id === "object")
                        message.role_id = new $util.LongBits(object.role_id.low >>> 0, object.role_id.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a CreateGuildRoleResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {kritor.guild.CreateGuildRoleResponse} message CreateGuildRoleResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateGuildRoleResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.role_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.role_id = options.longs === String ? "0" : 0;
                if (message.role_id != null && message.hasOwnProperty("role_id"))
                    if (typeof message.role_id === "number")
                        object.role_id = options.longs === String ? String(message.role_id) : message.role_id;
                    else
                        object.role_id = options.longs === String ? $util.Long.prototype.toString.call(message.role_id) : options.longs === Number ? new $util.LongBits(message.role_id.low >>> 0, message.role_id.high >>> 0).toNumber(true) : message.role_id;
                return object;
            };

            /**
             * Converts this CreateGuildRoleResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateGuildRoleResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateGuildRoleResponse
             * @function getTypeUrl
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateGuildRoleResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.CreateGuildRoleResponse";
            };

            return CreateGuildRoleResponse;
        })();

        guild.GuildInfo = (function() {

            /**
             * Properties of a GuildInfo.
             * @memberof kritor.guild
             * @interface IGuildInfo
             * @property {number|Long|null} [guild_id] GuildInfo guild_id
             * @property {string|null} [guild_name] GuildInfo guild_name
             * @property {string|null} [guild_display_id] GuildInfo guild_display_id
             * @property {string|null} [profile] GuildInfo profile
             * @property {boolean|null} [is_enable] GuildInfo is_enable
             * @property {boolean|null} [is_banned] GuildInfo is_banned
             * @property {boolean|null} [is_frozen] GuildInfo is_frozen
             * @property {number|Long|null} [owner_id] GuildInfo owner_id
             * @property {number|Long|null} [shutup_expire_time] GuildInfo shutup_expire_time
             * @property {boolean|null} [allow_search] GuildInfo allow_search
             */

            /**
             * Constructs a new GuildInfo.
             * @memberof kritor.guild
             * @classdesc Represents a GuildInfo.
             * @implements IGuildInfo
             * @constructor
             * @param {kritor.guild.IGuildInfo=} [properties] Properties to set
             */
            function GuildInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GuildInfo guild_id.
             * @member {number|Long} guild_id
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.guild_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GuildInfo guild_name.
             * @member {string} guild_name
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.guild_name = "";

            /**
             * GuildInfo guild_display_id.
             * @member {string} guild_display_id
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.guild_display_id = "";

            /**
             * GuildInfo profile.
             * @member {string} profile
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.profile = "";

            /**
             * GuildInfo is_enable.
             * @member {boolean} is_enable
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.is_enable = false;

            /**
             * GuildInfo is_banned.
             * @member {boolean} is_banned
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.is_banned = false;

            /**
             * GuildInfo is_frozen.
             * @member {boolean} is_frozen
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.is_frozen = false;

            /**
             * GuildInfo owner_id.
             * @member {number|Long} owner_id
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.owner_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GuildInfo shutup_expire_time.
             * @member {number|Long} shutup_expire_time
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.shutup_expire_time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GuildInfo allow_search.
             * @member {boolean} allow_search
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.allow_search = false;

            /**
             * Creates a new GuildInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {kritor.guild.IGuildInfo=} [properties] Properties to set
             * @returns {kritor.guild.GuildInfo} GuildInfo instance
             */
            GuildInfo.create = function create(properties) {
                return new GuildInfo(properties);
            };

            /**
             * Encodes the specified GuildInfo message. Does not implicitly {@link kritor.guild.GuildInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {kritor.guild.IGuildInfo} message GuildInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GuildInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guild_id != null && Object.hasOwnProperty.call(message, "guild_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guild_id);
                if (message.guild_name != null && Object.hasOwnProperty.call(message, "guild_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.guild_name);
                if (message.guild_display_id != null && Object.hasOwnProperty.call(message, "guild_display_id"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.guild_display_id);
                if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.profile);
                if (message.is_enable != null && Object.hasOwnProperty.call(message, "is_enable"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.is_enable);
                if (message.is_banned != null && Object.hasOwnProperty.call(message, "is_banned"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.is_banned);
                if (message.is_frozen != null && Object.hasOwnProperty.call(message, "is_frozen"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.is_frozen);
                if (message.owner_id != null && Object.hasOwnProperty.call(message, "owner_id"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.owner_id);
                if (message.shutup_expire_time != null && Object.hasOwnProperty.call(message, "shutup_expire_time"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.shutup_expire_time);
                if (message.allow_search != null && Object.hasOwnProperty.call(message, "allow_search"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.allow_search);
                return writer;
            };

            /**
             * Encodes the specified GuildInfo message, length delimited. Does not implicitly {@link kritor.guild.GuildInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {kritor.guild.IGuildInfo} message GuildInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GuildInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GuildInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GuildInfo} GuildInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GuildInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GuildInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guild_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.guild_name = reader.string();
                            break;
                        }
                    case 3: {
                            message.guild_display_id = reader.string();
                            break;
                        }
                    case 4: {
                            message.profile = reader.string();
                            break;
                        }
                    case 5: {
                            message.is_enable = reader.bool();
                            break;
                        }
                    case 6: {
                            message.is_banned = reader.bool();
                            break;
                        }
                    case 7: {
                            message.is_frozen = reader.bool();
                            break;
                        }
                    case 8: {
                            message.owner_id = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.shutup_expire_time = reader.uint64();
                            break;
                        }
                    case 10: {
                            message.allow_search = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GuildInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GuildInfo} GuildInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GuildInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GuildInfo message.
             * @function verify
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GuildInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (!$util.isInteger(message.guild_id) && !(message.guild_id && $util.isInteger(message.guild_id.low) && $util.isInteger(message.guild_id.high)))
                        return "guild_id: integer|Long expected";
                if (message.guild_name != null && message.hasOwnProperty("guild_name"))
                    if (!$util.isString(message.guild_name))
                        return "guild_name: string expected";
                if (message.guild_display_id != null && message.hasOwnProperty("guild_display_id"))
                    if (!$util.isString(message.guild_display_id))
                        return "guild_display_id: string expected";
                if (message.profile != null && message.hasOwnProperty("profile"))
                    if (!$util.isString(message.profile))
                        return "profile: string expected";
                if (message.is_enable != null && message.hasOwnProperty("is_enable"))
                    if (typeof message.is_enable !== "boolean")
                        return "is_enable: boolean expected";
                if (message.is_banned != null && message.hasOwnProperty("is_banned"))
                    if (typeof message.is_banned !== "boolean")
                        return "is_banned: boolean expected";
                if (message.is_frozen != null && message.hasOwnProperty("is_frozen"))
                    if (typeof message.is_frozen !== "boolean")
                        return "is_frozen: boolean expected";
                if (message.owner_id != null && message.hasOwnProperty("owner_id"))
                    if (!$util.isInteger(message.owner_id) && !(message.owner_id && $util.isInteger(message.owner_id.low) && $util.isInteger(message.owner_id.high)))
                        return "owner_id: integer|Long expected";
                if (message.shutup_expire_time != null && message.hasOwnProperty("shutup_expire_time"))
                    if (!$util.isInteger(message.shutup_expire_time) && !(message.shutup_expire_time && $util.isInteger(message.shutup_expire_time.low) && $util.isInteger(message.shutup_expire_time.high)))
                        return "shutup_expire_time: integer|Long expected";
                if (message.allow_search != null && message.hasOwnProperty("allow_search"))
                    if (typeof message.allow_search !== "boolean")
                        return "allow_search: boolean expected";
                return null;
            };

            /**
             * Creates a GuildInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GuildInfo} GuildInfo
             */
            GuildInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GuildInfo)
                    return object;
                let message = new $root.kritor.guild.GuildInfo();
                if (object.guild_id != null)
                    if ($util.Long)
                        (message.guild_id = $util.Long.fromValue(object.guild_id)).unsigned = true;
                    else if (typeof object.guild_id === "string")
                        message.guild_id = parseInt(object.guild_id, 10);
                    else if (typeof object.guild_id === "number")
                        message.guild_id = object.guild_id;
                    else if (typeof object.guild_id === "object")
                        message.guild_id = new $util.LongBits(object.guild_id.low >>> 0, object.guild_id.high >>> 0).toNumber(true);
                if (object.guild_name != null)
                    message.guild_name = String(object.guild_name);
                if (object.guild_display_id != null)
                    message.guild_display_id = String(object.guild_display_id);
                if (object.profile != null)
                    message.profile = String(object.profile);
                if (object.is_enable != null)
                    message.is_enable = Boolean(object.is_enable);
                if (object.is_banned != null)
                    message.is_banned = Boolean(object.is_banned);
                if (object.is_frozen != null)
                    message.is_frozen = Boolean(object.is_frozen);
                if (object.owner_id != null)
                    if ($util.Long)
                        (message.owner_id = $util.Long.fromValue(object.owner_id)).unsigned = true;
                    else if (typeof object.owner_id === "string")
                        message.owner_id = parseInt(object.owner_id, 10);
                    else if (typeof object.owner_id === "number")
                        message.owner_id = object.owner_id;
                    else if (typeof object.owner_id === "object")
                        message.owner_id = new $util.LongBits(object.owner_id.low >>> 0, object.owner_id.high >>> 0).toNumber(true);
                if (object.shutup_expire_time != null)
                    if ($util.Long)
                        (message.shutup_expire_time = $util.Long.fromValue(object.shutup_expire_time)).unsigned = true;
                    else if (typeof object.shutup_expire_time === "string")
                        message.shutup_expire_time = parseInt(object.shutup_expire_time, 10);
                    else if (typeof object.shutup_expire_time === "number")
                        message.shutup_expire_time = object.shutup_expire_time;
                    else if (typeof object.shutup_expire_time === "object")
                        message.shutup_expire_time = new $util.LongBits(object.shutup_expire_time.low >>> 0, object.shutup_expire_time.high >>> 0).toNumber(true);
                if (object.allow_search != null)
                    message.allow_search = Boolean(object.allow_search);
                return message;
            };

            /**
             * Creates a plain object from a GuildInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {kritor.guild.GuildInfo} message GuildInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GuildInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guild_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guild_id = options.longs === String ? "0" : 0;
                    object.guild_name = "";
                    object.guild_display_id = "";
                    object.profile = "";
                    object.is_enable = false;
                    object.is_banned = false;
                    object.is_frozen = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.owner_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.owner_id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.shutup_expire_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.shutup_expire_time = options.longs === String ? "0" : 0;
                    object.allow_search = false;
                }
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (typeof message.guild_id === "number")
                        object.guild_id = options.longs === String ? String(message.guild_id) : message.guild_id;
                    else
                        object.guild_id = options.longs === String ? $util.Long.prototype.toString.call(message.guild_id) : options.longs === Number ? new $util.LongBits(message.guild_id.low >>> 0, message.guild_id.high >>> 0).toNumber(true) : message.guild_id;
                if (message.guild_name != null && message.hasOwnProperty("guild_name"))
                    object.guild_name = message.guild_name;
                if (message.guild_display_id != null && message.hasOwnProperty("guild_display_id"))
                    object.guild_display_id = message.guild_display_id;
                if (message.profile != null && message.hasOwnProperty("profile"))
                    object.profile = message.profile;
                if (message.is_enable != null && message.hasOwnProperty("is_enable"))
                    object.is_enable = message.is_enable;
                if (message.is_banned != null && message.hasOwnProperty("is_banned"))
                    object.is_banned = message.is_banned;
                if (message.is_frozen != null && message.hasOwnProperty("is_frozen"))
                    object.is_frozen = message.is_frozen;
                if (message.owner_id != null && message.hasOwnProperty("owner_id"))
                    if (typeof message.owner_id === "number")
                        object.owner_id = options.longs === String ? String(message.owner_id) : message.owner_id;
                    else
                        object.owner_id = options.longs === String ? $util.Long.prototype.toString.call(message.owner_id) : options.longs === Number ? new $util.LongBits(message.owner_id.low >>> 0, message.owner_id.high >>> 0).toNumber(true) : message.owner_id;
                if (message.shutup_expire_time != null && message.hasOwnProperty("shutup_expire_time"))
                    if (typeof message.shutup_expire_time === "number")
                        object.shutup_expire_time = options.longs === String ? String(message.shutup_expire_time) : message.shutup_expire_time;
                    else
                        object.shutup_expire_time = options.longs === String ? $util.Long.prototype.toString.call(message.shutup_expire_time) : options.longs === Number ? new $util.LongBits(message.shutup_expire_time.low >>> 0, message.shutup_expire_time.high >>> 0).toNumber(true) : message.shutup_expire_time;
                if (message.allow_search != null && message.hasOwnProperty("allow_search"))
                    object.allow_search = message.allow_search;
                return object;
            };

            /**
             * Converts this GuildInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.GuildInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GuildInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GuildInfo
             * @function getTypeUrl
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GuildInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GuildInfo";
            };

            return GuildInfo;
        })();

        guild.ChannelInfo = (function() {

            /**
             * Properties of a ChannelInfo.
             * @memberof kritor.guild
             * @interface IChannelInfo
             * @property {number|Long|null} [channel_id] ChannelInfo channel_id
             * @property {number|Long|null} [guild_id] ChannelInfo guild_id
             * @property {string|null} [channel_name] ChannelInfo channel_name
             * @property {number|Long|null} [create_time] ChannelInfo create_time
             * @property {number|Long|null} [max_member_count] ChannelInfo max_member_count
             * @property {number|Long|null} [creator_tiny_id] ChannelInfo creator_tiny_id
             * @property {number|Long|null} [talk_permission] ChannelInfo talk_permission
             * @property {number|Long|null} [visible_type] ChannelInfo visible_type
             * @property {number|Long|null} [current_slow_mode] ChannelInfo current_slow_mode
             * @property {Array.<kritor.guild.ISlowModes>|null} [slow_modes] ChannelInfo slow_modes
             * @property {string|null} [icon_url] ChannelInfo icon_url
             * @property {number|Long|null} [jump_switch] ChannelInfo jump_switch
             * @property {number|Long|null} [jump_type] ChannelInfo jump_type
             * @property {string|null} [jump_url] ChannelInfo jump_url
             * @property {number|Long|null} [category_id] ChannelInfo category_id
             * @property {number|Long|null} [my_talk_permission] ChannelInfo my_talk_permission
             */

            /**
             * Constructs a new ChannelInfo.
             * @memberof kritor.guild
             * @classdesc Represents a ChannelInfo.
             * @implements IChannelInfo
             * @constructor
             * @param {kritor.guild.IChannelInfo=} [properties] Properties to set
             */
            function ChannelInfo(properties) {
                this.slow_modes = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChannelInfo channel_id.
             * @member {number|Long} channel_id
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.channel_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo guild_id.
             * @member {number|Long} guild_id
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.guild_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo channel_name.
             * @member {string} channel_name
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.channel_name = "";

            /**
             * ChannelInfo create_time.
             * @member {number|Long} create_time
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.create_time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo max_member_count.
             * @member {number|Long} max_member_count
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.max_member_count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo creator_tiny_id.
             * @member {number|Long} creator_tiny_id
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.creator_tiny_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo talk_permission.
             * @member {number|Long} talk_permission
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.talk_permission = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo visible_type.
             * @member {number|Long} visible_type
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.visible_type = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo current_slow_mode.
             * @member {number|Long} current_slow_mode
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.current_slow_mode = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo slow_modes.
             * @member {Array.<kritor.guild.ISlowModes>} slow_modes
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.slow_modes = $util.emptyArray;

            /**
             * ChannelInfo icon_url.
             * @member {string} icon_url
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.icon_url = "";

            /**
             * ChannelInfo jump_switch.
             * @member {number|Long} jump_switch
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.jump_switch = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo jump_type.
             * @member {number|Long} jump_type
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.jump_type = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo jump_url.
             * @member {string} jump_url
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.jump_url = "";

            /**
             * ChannelInfo category_id.
             * @member {number|Long} category_id
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.category_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo my_talk_permission.
             * @member {number|Long} my_talk_permission
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.my_talk_permission = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new ChannelInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {kritor.guild.IChannelInfo=} [properties] Properties to set
             * @returns {kritor.guild.ChannelInfo} ChannelInfo instance
             */
            ChannelInfo.create = function create(properties) {
                return new ChannelInfo(properties);
            };

            /**
             * Encodes the specified ChannelInfo message. Does not implicitly {@link kritor.guild.ChannelInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {kritor.guild.IChannelInfo} message ChannelInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel_id != null && Object.hasOwnProperty.call(message, "channel_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channel_id);
                if (message.guild_id != null && Object.hasOwnProperty.call(message, "guild_id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.guild_id);
                if (message.channel_name != null && Object.hasOwnProperty.call(message, "channel_name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.channel_name);
                if (message.create_time != null && Object.hasOwnProperty.call(message, "create_time"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.create_time);
                if (message.max_member_count != null && Object.hasOwnProperty.call(message, "max_member_count"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.max_member_count);
                if (message.creator_tiny_id != null && Object.hasOwnProperty.call(message, "creator_tiny_id"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.creator_tiny_id);
                if (message.talk_permission != null && Object.hasOwnProperty.call(message, "talk_permission"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.talk_permission);
                if (message.visible_type != null && Object.hasOwnProperty.call(message, "visible_type"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.visible_type);
                if (message.current_slow_mode != null && Object.hasOwnProperty.call(message, "current_slow_mode"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.current_slow_mode);
                if (message.slow_modes != null && message.slow_modes.length)
                    for (let i = 0; i < message.slow_modes.length; ++i)
                        $root.kritor.guild.SlowModes.encode(message.slow_modes[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.icon_url != null && Object.hasOwnProperty.call(message, "icon_url"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.icon_url);
                if (message.jump_switch != null && Object.hasOwnProperty.call(message, "jump_switch"))
                    writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.jump_switch);
                if (message.jump_type != null && Object.hasOwnProperty.call(message, "jump_type"))
                    writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.jump_type);
                if (message.jump_url != null && Object.hasOwnProperty.call(message, "jump_url"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.jump_url);
                if (message.category_id != null && Object.hasOwnProperty.call(message, "category_id"))
                    writer.uint32(/* id 15, wireType 0 =*/120).uint64(message.category_id);
                if (message.my_talk_permission != null && Object.hasOwnProperty.call(message, "my_talk_permission"))
                    writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.my_talk_permission);
                return writer;
            };

            /**
             * Encodes the specified ChannelInfo message, length delimited. Does not implicitly {@link kritor.guild.ChannelInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {kritor.guild.IChannelInfo} message ChannelInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChannelInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.ChannelInfo} ChannelInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.ChannelInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.channel_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.guild_id = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.channel_name = reader.string();
                            break;
                        }
                    case 4: {
                            message.create_time = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.max_member_count = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.creator_tiny_id = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.talk_permission = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.visible_type = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.current_slow_mode = reader.uint64();
                            break;
                        }
                    case 10: {
                            if (!(message.slow_modes && message.slow_modes.length))
                                message.slow_modes = [];
                            message.slow_modes.push($root.kritor.guild.SlowModes.decode(reader, reader.uint32()));
                            break;
                        }
                    case 11: {
                            message.icon_url = reader.string();
                            break;
                        }
                    case 12: {
                            message.jump_switch = reader.uint64();
                            break;
                        }
                    case 13: {
                            message.jump_type = reader.uint64();
                            break;
                        }
                    case 14: {
                            message.jump_url = reader.string();
                            break;
                        }
                    case 15: {
                            message.category_id = reader.uint64();
                            break;
                        }
                    case 16: {
                            message.my_talk_permission = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ChannelInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.ChannelInfo} ChannelInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChannelInfo message.
             * @function verify
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChannelInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel_id != null && message.hasOwnProperty("channel_id"))
                    if (!$util.isInteger(message.channel_id) && !(message.channel_id && $util.isInteger(message.channel_id.low) && $util.isInteger(message.channel_id.high)))
                        return "channel_id: integer|Long expected";
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (!$util.isInteger(message.guild_id) && !(message.guild_id && $util.isInteger(message.guild_id.low) && $util.isInteger(message.guild_id.high)))
                        return "guild_id: integer|Long expected";
                if (message.channel_name != null && message.hasOwnProperty("channel_name"))
                    if (!$util.isString(message.channel_name))
                        return "channel_name: string expected";
                if (message.create_time != null && message.hasOwnProperty("create_time"))
                    if (!$util.isInteger(message.create_time) && !(message.create_time && $util.isInteger(message.create_time.low) && $util.isInteger(message.create_time.high)))
                        return "create_time: integer|Long expected";
                if (message.max_member_count != null && message.hasOwnProperty("max_member_count"))
                    if (!$util.isInteger(message.max_member_count) && !(message.max_member_count && $util.isInteger(message.max_member_count.low) && $util.isInteger(message.max_member_count.high)))
                        return "max_member_count: integer|Long expected";
                if (message.creator_tiny_id != null && message.hasOwnProperty("creator_tiny_id"))
                    if (!$util.isInteger(message.creator_tiny_id) && !(message.creator_tiny_id && $util.isInteger(message.creator_tiny_id.low) && $util.isInteger(message.creator_tiny_id.high)))
                        return "creator_tiny_id: integer|Long expected";
                if (message.talk_permission != null && message.hasOwnProperty("talk_permission"))
                    if (!$util.isInteger(message.talk_permission) && !(message.talk_permission && $util.isInteger(message.talk_permission.low) && $util.isInteger(message.talk_permission.high)))
                        return "talk_permission: integer|Long expected";
                if (message.visible_type != null && message.hasOwnProperty("visible_type"))
                    if (!$util.isInteger(message.visible_type) && !(message.visible_type && $util.isInteger(message.visible_type.low) && $util.isInteger(message.visible_type.high)))
                        return "visible_type: integer|Long expected";
                if (message.current_slow_mode != null && message.hasOwnProperty("current_slow_mode"))
                    if (!$util.isInteger(message.current_slow_mode) && !(message.current_slow_mode && $util.isInteger(message.current_slow_mode.low) && $util.isInteger(message.current_slow_mode.high)))
                        return "current_slow_mode: integer|Long expected";
                if (message.slow_modes != null && message.hasOwnProperty("slow_modes")) {
                    if (!Array.isArray(message.slow_modes))
                        return "slow_modes: array expected";
                    for (let i = 0; i < message.slow_modes.length; ++i) {
                        let error = $root.kritor.guild.SlowModes.verify(message.slow_modes[i]);
                        if (error)
                            return "slow_modes." + error;
                    }
                }
                if (message.icon_url != null && message.hasOwnProperty("icon_url"))
                    if (!$util.isString(message.icon_url))
                        return "icon_url: string expected";
                if (message.jump_switch != null && message.hasOwnProperty("jump_switch"))
                    if (!$util.isInteger(message.jump_switch) && !(message.jump_switch && $util.isInteger(message.jump_switch.low) && $util.isInteger(message.jump_switch.high)))
                        return "jump_switch: integer|Long expected";
                if (message.jump_type != null && message.hasOwnProperty("jump_type"))
                    if (!$util.isInteger(message.jump_type) && !(message.jump_type && $util.isInteger(message.jump_type.low) && $util.isInteger(message.jump_type.high)))
                        return "jump_type: integer|Long expected";
                if (message.jump_url != null && message.hasOwnProperty("jump_url"))
                    if (!$util.isString(message.jump_url))
                        return "jump_url: string expected";
                if (message.category_id != null && message.hasOwnProperty("category_id"))
                    if (!$util.isInteger(message.category_id) && !(message.category_id && $util.isInteger(message.category_id.low) && $util.isInteger(message.category_id.high)))
                        return "category_id: integer|Long expected";
                if (message.my_talk_permission != null && message.hasOwnProperty("my_talk_permission"))
                    if (!$util.isInteger(message.my_talk_permission) && !(message.my_talk_permission && $util.isInteger(message.my_talk_permission.low) && $util.isInteger(message.my_talk_permission.high)))
                        return "my_talk_permission: integer|Long expected";
                return null;
            };

            /**
             * Creates a ChannelInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.ChannelInfo} ChannelInfo
             */
            ChannelInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.ChannelInfo)
                    return object;
                let message = new $root.kritor.guild.ChannelInfo();
                if (object.channel_id != null)
                    if ($util.Long)
                        (message.channel_id = $util.Long.fromValue(object.channel_id)).unsigned = true;
                    else if (typeof object.channel_id === "string")
                        message.channel_id = parseInt(object.channel_id, 10);
                    else if (typeof object.channel_id === "number")
                        message.channel_id = object.channel_id;
                    else if (typeof object.channel_id === "object")
                        message.channel_id = new $util.LongBits(object.channel_id.low >>> 0, object.channel_id.high >>> 0).toNumber(true);
                if (object.guild_id != null)
                    if ($util.Long)
                        (message.guild_id = $util.Long.fromValue(object.guild_id)).unsigned = true;
                    else if (typeof object.guild_id === "string")
                        message.guild_id = parseInt(object.guild_id, 10);
                    else if (typeof object.guild_id === "number")
                        message.guild_id = object.guild_id;
                    else if (typeof object.guild_id === "object")
                        message.guild_id = new $util.LongBits(object.guild_id.low >>> 0, object.guild_id.high >>> 0).toNumber(true);
                if (object.channel_name != null)
                    message.channel_name = String(object.channel_name);
                if (object.create_time != null)
                    if ($util.Long)
                        (message.create_time = $util.Long.fromValue(object.create_time)).unsigned = true;
                    else if (typeof object.create_time === "string")
                        message.create_time = parseInt(object.create_time, 10);
                    else if (typeof object.create_time === "number")
                        message.create_time = object.create_time;
                    else if (typeof object.create_time === "object")
                        message.create_time = new $util.LongBits(object.create_time.low >>> 0, object.create_time.high >>> 0).toNumber(true);
                if (object.max_member_count != null)
                    if ($util.Long)
                        (message.max_member_count = $util.Long.fromValue(object.max_member_count)).unsigned = true;
                    else if (typeof object.max_member_count === "string")
                        message.max_member_count = parseInt(object.max_member_count, 10);
                    else if (typeof object.max_member_count === "number")
                        message.max_member_count = object.max_member_count;
                    else if (typeof object.max_member_count === "object")
                        message.max_member_count = new $util.LongBits(object.max_member_count.low >>> 0, object.max_member_count.high >>> 0).toNumber(true);
                if (object.creator_tiny_id != null)
                    if ($util.Long)
                        (message.creator_tiny_id = $util.Long.fromValue(object.creator_tiny_id)).unsigned = true;
                    else if (typeof object.creator_tiny_id === "string")
                        message.creator_tiny_id = parseInt(object.creator_tiny_id, 10);
                    else if (typeof object.creator_tiny_id === "number")
                        message.creator_tiny_id = object.creator_tiny_id;
                    else if (typeof object.creator_tiny_id === "object")
                        message.creator_tiny_id = new $util.LongBits(object.creator_tiny_id.low >>> 0, object.creator_tiny_id.high >>> 0).toNumber(true);
                if (object.talk_permission != null)
                    if ($util.Long)
                        (message.talk_permission = $util.Long.fromValue(object.talk_permission)).unsigned = true;
                    else if (typeof object.talk_permission === "string")
                        message.talk_permission = parseInt(object.talk_permission, 10);
                    else if (typeof object.talk_permission === "number")
                        message.talk_permission = object.talk_permission;
                    else if (typeof object.talk_permission === "object")
                        message.talk_permission = new $util.LongBits(object.talk_permission.low >>> 0, object.talk_permission.high >>> 0).toNumber(true);
                if (object.visible_type != null)
                    if ($util.Long)
                        (message.visible_type = $util.Long.fromValue(object.visible_type)).unsigned = true;
                    else if (typeof object.visible_type === "string")
                        message.visible_type = parseInt(object.visible_type, 10);
                    else if (typeof object.visible_type === "number")
                        message.visible_type = object.visible_type;
                    else if (typeof object.visible_type === "object")
                        message.visible_type = new $util.LongBits(object.visible_type.low >>> 0, object.visible_type.high >>> 0).toNumber(true);
                if (object.current_slow_mode != null)
                    if ($util.Long)
                        (message.current_slow_mode = $util.Long.fromValue(object.current_slow_mode)).unsigned = true;
                    else if (typeof object.current_slow_mode === "string")
                        message.current_slow_mode = parseInt(object.current_slow_mode, 10);
                    else if (typeof object.current_slow_mode === "number")
                        message.current_slow_mode = object.current_slow_mode;
                    else if (typeof object.current_slow_mode === "object")
                        message.current_slow_mode = new $util.LongBits(object.current_slow_mode.low >>> 0, object.current_slow_mode.high >>> 0).toNumber(true);
                if (object.slow_modes) {
                    if (!Array.isArray(object.slow_modes))
                        throw TypeError(".kritor.guild.ChannelInfo.slow_modes: array expected");
                    message.slow_modes = [];
                    for (let i = 0; i < object.slow_modes.length; ++i) {
                        if (typeof object.slow_modes[i] !== "object")
                            throw TypeError(".kritor.guild.ChannelInfo.slow_modes: object expected");
                        message.slow_modes[i] = $root.kritor.guild.SlowModes.fromObject(object.slow_modes[i]);
                    }
                }
                if (object.icon_url != null)
                    message.icon_url = String(object.icon_url);
                if (object.jump_switch != null)
                    if ($util.Long)
                        (message.jump_switch = $util.Long.fromValue(object.jump_switch)).unsigned = true;
                    else if (typeof object.jump_switch === "string")
                        message.jump_switch = parseInt(object.jump_switch, 10);
                    else if (typeof object.jump_switch === "number")
                        message.jump_switch = object.jump_switch;
                    else if (typeof object.jump_switch === "object")
                        message.jump_switch = new $util.LongBits(object.jump_switch.low >>> 0, object.jump_switch.high >>> 0).toNumber(true);
                if (object.jump_type != null)
                    if ($util.Long)
                        (message.jump_type = $util.Long.fromValue(object.jump_type)).unsigned = true;
                    else if (typeof object.jump_type === "string")
                        message.jump_type = parseInt(object.jump_type, 10);
                    else if (typeof object.jump_type === "number")
                        message.jump_type = object.jump_type;
                    else if (typeof object.jump_type === "object")
                        message.jump_type = new $util.LongBits(object.jump_type.low >>> 0, object.jump_type.high >>> 0).toNumber(true);
                if (object.jump_url != null)
                    message.jump_url = String(object.jump_url);
                if (object.category_id != null)
                    if ($util.Long)
                        (message.category_id = $util.Long.fromValue(object.category_id)).unsigned = true;
                    else if (typeof object.category_id === "string")
                        message.category_id = parseInt(object.category_id, 10);
                    else if (typeof object.category_id === "number")
                        message.category_id = object.category_id;
                    else if (typeof object.category_id === "object")
                        message.category_id = new $util.LongBits(object.category_id.low >>> 0, object.category_id.high >>> 0).toNumber(true);
                if (object.my_talk_permission != null)
                    if ($util.Long)
                        (message.my_talk_permission = $util.Long.fromValue(object.my_talk_permission)).unsigned = true;
                    else if (typeof object.my_talk_permission === "string")
                        message.my_talk_permission = parseInt(object.my_talk_permission, 10);
                    else if (typeof object.my_talk_permission === "number")
                        message.my_talk_permission = object.my_talk_permission;
                    else if (typeof object.my_talk_permission === "object")
                        message.my_talk_permission = new $util.LongBits(object.my_talk_permission.low >>> 0, object.my_talk_permission.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a ChannelInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {kritor.guild.ChannelInfo} message ChannelInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChannelInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.slow_modes = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.channel_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.channel_id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guild_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guild_id = options.longs === String ? "0" : 0;
                    object.channel_name = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.create_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.create_time = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.max_member_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.max_member_count = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.creator_tiny_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.creator_tiny_id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.talk_permission = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.talk_permission = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.visible_type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.visible_type = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.current_slow_mode = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.current_slow_mode = options.longs === String ? "0" : 0;
                    object.icon_url = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.jump_switch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.jump_switch = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.jump_type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.jump_type = options.longs === String ? "0" : 0;
                    object.jump_url = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.category_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.category_id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.my_talk_permission = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.my_talk_permission = options.longs === String ? "0" : 0;
                }
                if (message.channel_id != null && message.hasOwnProperty("channel_id"))
                    if (typeof message.channel_id === "number")
                        object.channel_id = options.longs === String ? String(message.channel_id) : message.channel_id;
                    else
                        object.channel_id = options.longs === String ? $util.Long.prototype.toString.call(message.channel_id) : options.longs === Number ? new $util.LongBits(message.channel_id.low >>> 0, message.channel_id.high >>> 0).toNumber(true) : message.channel_id;
                if (message.guild_id != null && message.hasOwnProperty("guild_id"))
                    if (typeof message.guild_id === "number")
                        object.guild_id = options.longs === String ? String(message.guild_id) : message.guild_id;
                    else
                        object.guild_id = options.longs === String ? $util.Long.prototype.toString.call(message.guild_id) : options.longs === Number ? new $util.LongBits(message.guild_id.low >>> 0, message.guild_id.high >>> 0).toNumber(true) : message.guild_id;
                if (message.channel_name != null && message.hasOwnProperty("channel_name"))
                    object.channel_name = message.channel_name;
                if (message.create_time != null && message.hasOwnProperty("create_time"))
                    if (typeof message.create_time === "number")
                        object.create_time = options.longs === String ? String(message.create_time) : message.create_time;
                    else
                        object.create_time = options.longs === String ? $util.Long.prototype.toString.call(message.create_time) : options.longs === Number ? new $util.LongBits(message.create_time.low >>> 0, message.create_time.high >>> 0).toNumber(true) : message.create_time;
                if (message.max_member_count != null && message.hasOwnProperty("max_member_count"))
                    if (typeof message.max_member_count === "number")
                        object.max_member_count = options.longs === String ? String(message.max_member_count) : message.max_member_count;
                    else
                        object.max_member_count = options.longs === String ? $util.Long.prototype.toString.call(message.max_member_count) : options.longs === Number ? new $util.LongBits(message.max_member_count.low >>> 0, message.max_member_count.high >>> 0).toNumber(true) : message.max_member_count;
                if (message.creator_tiny_id != null && message.hasOwnProperty("creator_tiny_id"))
                    if (typeof message.creator_tiny_id === "number")
                        object.creator_tiny_id = options.longs === String ? String(message.creator_tiny_id) : message.creator_tiny_id;
                    else
                        object.creator_tiny_id = options.longs === String ? $util.Long.prototype.toString.call(message.creator_tiny_id) : options.longs === Number ? new $util.LongBits(message.creator_tiny_id.low >>> 0, message.creator_tiny_id.high >>> 0).toNumber(true) : message.creator_tiny_id;
                if (message.talk_permission != null && message.hasOwnProperty("talk_permission"))
                    if (typeof message.talk_permission === "number")
                        object.talk_permission = options.longs === String ? String(message.talk_permission) : message.talk_permission;
                    else
                        object.talk_permission = options.longs === String ? $util.Long.prototype.toString.call(message.talk_permission) : options.longs === Number ? new $util.LongBits(message.talk_permission.low >>> 0, message.talk_permission.high >>> 0).toNumber(true) : message.talk_permission;
                if (message.visible_type != null && message.hasOwnProperty("visible_type"))
                    if (typeof message.visible_type === "number")
                        object.visible_type = options.longs === String ? String(message.visible_type) : message.visible_type;
                    else
                        object.visible_type = options.longs === String ? $util.Long.prototype.toString.call(message.visible_type) : options.longs === Number ? new $util.LongBits(message.visible_type.low >>> 0, message.visible_type.high >>> 0).toNumber(true) : message.visible_type;
                if (message.current_slow_mode != null && message.hasOwnProperty("current_slow_mode"))
                    if (typeof message.current_slow_mode === "number")
                        object.current_slow_mode = options.longs === String ? String(message.current_slow_mode) : message.current_slow_mode;
                    else
                        object.current_slow_mode = options.longs === String ? $util.Long.prototype.toString.call(message.current_slow_mode) : options.longs === Number ? new $util.LongBits(message.current_slow_mode.low >>> 0, message.current_slow_mode.high >>> 0).toNumber(true) : message.current_slow_mode;
                if (message.slow_modes && message.slow_modes.length) {
                    object.slow_modes = [];
                    for (let j = 0; j < message.slow_modes.length; ++j)
                        object.slow_modes[j] = $root.kritor.guild.SlowModes.toObject(message.slow_modes[j], options);
                }
                if (message.icon_url != null && message.hasOwnProperty("icon_url"))
                    object.icon_url = message.icon_url;
                if (message.jump_switch != null && message.hasOwnProperty("jump_switch"))
                    if (typeof message.jump_switch === "number")
                        object.jump_switch = options.longs === String ? String(message.jump_switch) : message.jump_switch;
                    else
                        object.jump_switch = options.longs === String ? $util.Long.prototype.toString.call(message.jump_switch) : options.longs === Number ? new $util.LongBits(message.jump_switch.low >>> 0, message.jump_switch.high >>> 0).toNumber(true) : message.jump_switch;
                if (message.jump_type != null && message.hasOwnProperty("jump_type"))
                    if (typeof message.jump_type === "number")
                        object.jump_type = options.longs === String ? String(message.jump_type) : message.jump_type;
                    else
                        object.jump_type = options.longs === String ? $util.Long.prototype.toString.call(message.jump_type) : options.longs === Number ? new $util.LongBits(message.jump_type.low >>> 0, message.jump_type.high >>> 0).toNumber(true) : message.jump_type;
                if (message.jump_url != null && message.hasOwnProperty("jump_url"))
                    object.jump_url = message.jump_url;
                if (message.category_id != null && message.hasOwnProperty("category_id"))
                    if (typeof message.category_id === "number")
                        object.category_id = options.longs === String ? String(message.category_id) : message.category_id;
                    else
                        object.category_id = options.longs === String ? $util.Long.prototype.toString.call(message.category_id) : options.longs === Number ? new $util.LongBits(message.category_id.low >>> 0, message.category_id.high >>> 0).toNumber(true) : message.category_id;
                if (message.my_talk_permission != null && message.hasOwnProperty("my_talk_permission"))
                    if (typeof message.my_talk_permission === "number")
                        object.my_talk_permission = options.longs === String ? String(message.my_talk_permission) : message.my_talk_permission;
                    else
                        object.my_talk_permission = options.longs === String ? $util.Long.prototype.toString.call(message.my_talk_permission) : options.longs === Number ? new $util.LongBits(message.my_talk_permission.low >>> 0, message.my_talk_permission.high >>> 0).toNumber(true) : message.my_talk_permission;
                return object;
            };

            /**
             * Converts this ChannelInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.ChannelInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChannelInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ChannelInfo
             * @function getTypeUrl
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ChannelInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.ChannelInfo";
            };

            return ChannelInfo;
        })();

        guild.SlowModes = (function() {

            /**
             * Properties of a SlowModes.
             * @memberof kritor.guild
             * @interface ISlowModes
             * @property {number|Long|null} [slow_mode_key] SlowModes slow_mode_key
             * @property {string|null} [slow_mode_text] SlowModes slow_mode_text
             * @property {number|Long|null} [speak_frequency] SlowModes speak_frequency
             * @property {number|Long|null} [slow_mode_circle] SlowModes slow_mode_circle
             */

            /**
             * Constructs a new SlowModes.
             * @memberof kritor.guild
             * @classdesc Represents a SlowModes.
             * @implements ISlowModes
             * @constructor
             * @param {kritor.guild.ISlowModes=} [properties] Properties to set
             */
            function SlowModes(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SlowModes slow_mode_key.
             * @member {number|Long} slow_mode_key
             * @memberof kritor.guild.SlowModes
             * @instance
             */
            SlowModes.prototype.slow_mode_key = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SlowModes slow_mode_text.
             * @member {string} slow_mode_text
             * @memberof kritor.guild.SlowModes
             * @instance
             */
            SlowModes.prototype.slow_mode_text = "";

            /**
             * SlowModes speak_frequency.
             * @member {number|Long} speak_frequency
             * @memberof kritor.guild.SlowModes
             * @instance
             */
            SlowModes.prototype.speak_frequency = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SlowModes slow_mode_circle.
             * @member {number|Long} slow_mode_circle
             * @memberof kritor.guild.SlowModes
             * @instance
             */
            SlowModes.prototype.slow_mode_circle = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new SlowModes instance using the specified properties.
             * @function create
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {kritor.guild.ISlowModes=} [properties] Properties to set
             * @returns {kritor.guild.SlowModes} SlowModes instance
             */
            SlowModes.create = function create(properties) {
                return new SlowModes(properties);
            };

            /**
             * Encodes the specified SlowModes message. Does not implicitly {@link kritor.guild.SlowModes.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {kritor.guild.ISlowModes} message SlowModes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SlowModes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.slow_mode_key != null && Object.hasOwnProperty.call(message, "slow_mode_key"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.slow_mode_key);
                if (message.slow_mode_text != null && Object.hasOwnProperty.call(message, "slow_mode_text"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.slow_mode_text);
                if (message.speak_frequency != null && Object.hasOwnProperty.call(message, "speak_frequency"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.speak_frequency);
                if (message.slow_mode_circle != null && Object.hasOwnProperty.call(message, "slow_mode_circle"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.slow_mode_circle);
                return writer;
            };

            /**
             * Encodes the specified SlowModes message, length delimited. Does not implicitly {@link kritor.guild.SlowModes.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {kritor.guild.ISlowModes} message SlowModes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SlowModes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SlowModes message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.SlowModes} SlowModes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SlowModes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.SlowModes();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.slow_mode_key = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.slow_mode_text = reader.string();
                            break;
                        }
                    case 3: {
                            message.speak_frequency = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.slow_mode_circle = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SlowModes message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.SlowModes} SlowModes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SlowModes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SlowModes message.
             * @function verify
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SlowModes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.slow_mode_key != null && message.hasOwnProperty("slow_mode_key"))
                    if (!$util.isInteger(message.slow_mode_key) && !(message.slow_mode_key && $util.isInteger(message.slow_mode_key.low) && $util.isInteger(message.slow_mode_key.high)))
                        return "slow_mode_key: integer|Long expected";
                if (message.slow_mode_text != null && message.hasOwnProperty("slow_mode_text"))
                    if (!$util.isString(message.slow_mode_text))
                        return "slow_mode_text: string expected";
                if (message.speak_frequency != null && message.hasOwnProperty("speak_frequency"))
                    if (!$util.isInteger(message.speak_frequency) && !(message.speak_frequency && $util.isInteger(message.speak_frequency.low) && $util.isInteger(message.speak_frequency.high)))
                        return "speak_frequency: integer|Long expected";
                if (message.slow_mode_circle != null && message.hasOwnProperty("slow_mode_circle"))
                    if (!$util.isInteger(message.slow_mode_circle) && !(message.slow_mode_circle && $util.isInteger(message.slow_mode_circle.low) && $util.isInteger(message.slow_mode_circle.high)))
                        return "slow_mode_circle: integer|Long expected";
                return null;
            };

            /**
             * Creates a SlowModes message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.SlowModes} SlowModes
             */
            SlowModes.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.SlowModes)
                    return object;
                let message = new $root.kritor.guild.SlowModes();
                if (object.slow_mode_key != null)
                    if ($util.Long)
                        (message.slow_mode_key = $util.Long.fromValue(object.slow_mode_key)).unsigned = true;
                    else if (typeof object.slow_mode_key === "string")
                        message.slow_mode_key = parseInt(object.slow_mode_key, 10);
                    else if (typeof object.slow_mode_key === "number")
                        message.slow_mode_key = object.slow_mode_key;
                    else if (typeof object.slow_mode_key === "object")
                        message.slow_mode_key = new $util.LongBits(object.slow_mode_key.low >>> 0, object.slow_mode_key.high >>> 0).toNumber(true);
                if (object.slow_mode_text != null)
                    message.slow_mode_text = String(object.slow_mode_text);
                if (object.speak_frequency != null)
                    if ($util.Long)
                        (message.speak_frequency = $util.Long.fromValue(object.speak_frequency)).unsigned = true;
                    else if (typeof object.speak_frequency === "string")
                        message.speak_frequency = parseInt(object.speak_frequency, 10);
                    else if (typeof object.speak_frequency === "number")
                        message.speak_frequency = object.speak_frequency;
                    else if (typeof object.speak_frequency === "object")
                        message.speak_frequency = new $util.LongBits(object.speak_frequency.low >>> 0, object.speak_frequency.high >>> 0).toNumber(true);
                if (object.slow_mode_circle != null)
                    if ($util.Long)
                        (message.slow_mode_circle = $util.Long.fromValue(object.slow_mode_circle)).unsigned = true;
                    else if (typeof object.slow_mode_circle === "string")
                        message.slow_mode_circle = parseInt(object.slow_mode_circle, 10);
                    else if (typeof object.slow_mode_circle === "number")
                        message.slow_mode_circle = object.slow_mode_circle;
                    else if (typeof object.slow_mode_circle === "object")
                        message.slow_mode_circle = new $util.LongBits(object.slow_mode_circle.low >>> 0, object.slow_mode_circle.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a SlowModes message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {kritor.guild.SlowModes} message SlowModes
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SlowModes.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.slow_mode_key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.slow_mode_key = options.longs === String ? "0" : 0;
                    object.slow_mode_text = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.speak_frequency = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.speak_frequency = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.slow_mode_circle = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.slow_mode_circle = options.longs === String ? "0" : 0;
                }
                if (message.slow_mode_key != null && message.hasOwnProperty("slow_mode_key"))
                    if (typeof message.slow_mode_key === "number")
                        object.slow_mode_key = options.longs === String ? String(message.slow_mode_key) : message.slow_mode_key;
                    else
                        object.slow_mode_key = options.longs === String ? $util.Long.prototype.toString.call(message.slow_mode_key) : options.longs === Number ? new $util.LongBits(message.slow_mode_key.low >>> 0, message.slow_mode_key.high >>> 0).toNumber(true) : message.slow_mode_key;
                if (message.slow_mode_text != null && message.hasOwnProperty("slow_mode_text"))
                    object.slow_mode_text = message.slow_mode_text;
                if (message.speak_frequency != null && message.hasOwnProperty("speak_frequency"))
                    if (typeof message.speak_frequency === "number")
                        object.speak_frequency = options.longs === String ? String(message.speak_frequency) : message.speak_frequency;
                    else
                        object.speak_frequency = options.longs === String ? $util.Long.prototype.toString.call(message.speak_frequency) : options.longs === Number ? new $util.LongBits(message.speak_frequency.low >>> 0, message.speak_frequency.high >>> 0).toNumber(true) : message.speak_frequency;
                if (message.slow_mode_circle != null && message.hasOwnProperty("slow_mode_circle"))
                    if (typeof message.slow_mode_circle === "number")
                        object.slow_mode_circle = options.longs === String ? String(message.slow_mode_circle) : message.slow_mode_circle;
                    else
                        object.slow_mode_circle = options.longs === String ? $util.Long.prototype.toString.call(message.slow_mode_circle) : options.longs === Number ? new $util.LongBits(message.slow_mode_circle.low >>> 0, message.slow_mode_circle.high >>> 0).toNumber(true) : message.slow_mode_circle;
                return object;
            };

            /**
             * Converts this SlowModes to JSON.
             * @function toJSON
             * @memberof kritor.guild.SlowModes
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SlowModes.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SlowModes
             * @function getTypeUrl
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SlowModes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.SlowModes";
            };

            return SlowModes;
        })();

        guild.MemberInfo = (function() {

            /**
             * Properties of a MemberInfo.
             * @memberof kritor.guild
             * @interface IMemberInfo
             * @property {number|Long|null} [tiny_id] MemberInfo tiny_id
             * @property {string|null} [title] MemberInfo title
             * @property {string|null} [nickname] MemberInfo nickname
             * @property {number|Long|null} [role_id] MemberInfo role_id
             * @property {string|null} [role_name] MemberInfo role_name
             * @property {number|Long|null} [role_color] MemberInfo role_color
             * @property {number|Long|null} [join_time] MemberInfo join_time
             * @property {number|Long|null} [robot_type] MemberInfo robot_type
             * @property {number|Long|null} [type] MemberInfo type
             * @property {boolean|null} [in_black] MemberInfo in_black
             * @property {number|Long|null} [platform] MemberInfo platform
             */

            /**
             * Constructs a new MemberInfo.
             * @memberof kritor.guild
             * @classdesc Represents a MemberInfo.
             * @implements IMemberInfo
             * @constructor
             * @param {kritor.guild.IMemberInfo=} [properties] Properties to set
             */
            function MemberInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MemberInfo tiny_id.
             * @member {number|Long} tiny_id
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.tiny_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo title.
             * @member {string} title
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.title = "";

            /**
             * MemberInfo nickname.
             * @member {string} nickname
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.nickname = "";

            /**
             * MemberInfo role_id.
             * @member {number|Long} role_id
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.role_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo role_name.
             * @member {string} role_name
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.role_name = "";

            /**
             * MemberInfo role_color.
             * @member {number|Long} role_color
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.role_color = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo join_time.
             * @member {number|Long} join_time
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.join_time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo robot_type.
             * @member {number|Long} robot_type
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.robot_type = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo type.
             * @member {number|Long} type
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.type = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo in_black.
             * @member {boolean} in_black
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.in_black = false;

            /**
             * MemberInfo platform.
             * @member {number|Long} platform
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.platform = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new MemberInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {kritor.guild.IMemberInfo=} [properties] Properties to set
             * @returns {kritor.guild.MemberInfo} MemberInfo instance
             */
            MemberInfo.create = function create(properties) {
                return new MemberInfo(properties);
            };

            /**
             * Encodes the specified MemberInfo message. Does not implicitly {@link kritor.guild.MemberInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {kritor.guild.IMemberInfo} message MemberInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tiny_id != null && Object.hasOwnProperty.call(message, "tiny_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tiny_id);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.nickname);
                if (message.role_id != null && Object.hasOwnProperty.call(message, "role_id"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.role_id);
                if (message.role_name != null && Object.hasOwnProperty.call(message, "role_name"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.role_name);
                if (message.role_color != null && Object.hasOwnProperty.call(message, "role_color"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.role_color);
                if (message.join_time != null && Object.hasOwnProperty.call(message, "join_time"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.join_time);
                if (message.robot_type != null && Object.hasOwnProperty.call(message, "robot_type"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.robot_type);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.type);
                if (message.in_black != null && Object.hasOwnProperty.call(message, "in_black"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.in_black);
                if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.platform);
                return writer;
            };

            /**
             * Encodes the specified MemberInfo message, length delimited. Does not implicitly {@link kritor.guild.MemberInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {kritor.guild.IMemberInfo} message MemberInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MemberInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.MemberInfo} MemberInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.MemberInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tiny_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.title = reader.string();
                            break;
                        }
                    case 3: {
                            message.nickname = reader.string();
                            break;
                        }
                    case 4: {
                            message.role_id = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.role_name = reader.string();
                            break;
                        }
                    case 6: {
                            message.role_color = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.join_time = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.robot_type = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.type = reader.uint64();
                            break;
                        }
                    case 10: {
                            message.in_black = reader.bool();
                            break;
                        }
                    case 11: {
                            message.platform = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MemberInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.MemberInfo} MemberInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MemberInfo message.
             * @function verify
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MemberInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tiny_id != null && message.hasOwnProperty("tiny_id"))
                    if (!$util.isInteger(message.tiny_id) && !(message.tiny_id && $util.isInteger(message.tiny_id.low) && $util.isInteger(message.tiny_id.high)))
                        return "tiny_id: integer|Long expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    if (!$util.isString(message.nickname))
                        return "nickname: string expected";
                if (message.role_id != null && message.hasOwnProperty("role_id"))
                    if (!$util.isInteger(message.role_id) && !(message.role_id && $util.isInteger(message.role_id.low) && $util.isInteger(message.role_id.high)))
                        return "role_id: integer|Long expected";
                if (message.role_name != null && message.hasOwnProperty("role_name"))
                    if (!$util.isString(message.role_name))
                        return "role_name: string expected";
                if (message.role_color != null && message.hasOwnProperty("role_color"))
                    if (!$util.isInteger(message.role_color) && !(message.role_color && $util.isInteger(message.role_color.low) && $util.isInteger(message.role_color.high)))
                        return "role_color: integer|Long expected";
                if (message.join_time != null && message.hasOwnProperty("join_time"))
                    if (!$util.isInteger(message.join_time) && !(message.join_time && $util.isInteger(message.join_time.low) && $util.isInteger(message.join_time.high)))
                        return "join_time: integer|Long expected";
                if (message.robot_type != null && message.hasOwnProperty("robot_type"))
                    if (!$util.isInteger(message.robot_type) && !(message.robot_type && $util.isInteger(message.robot_type.low) && $util.isInteger(message.robot_type.high)))
                        return "robot_type: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type) && !(message.type && $util.isInteger(message.type.low) && $util.isInteger(message.type.high)))
                        return "type: integer|Long expected";
                if (message.in_black != null && message.hasOwnProperty("in_black"))
                    if (typeof message.in_black !== "boolean")
                        return "in_black: boolean expected";
                if (message.platform != null && message.hasOwnProperty("platform"))
                    if (!$util.isInteger(message.platform) && !(message.platform && $util.isInteger(message.platform.low) && $util.isInteger(message.platform.high)))
                        return "platform: integer|Long expected";
                return null;
            };

            /**
             * Creates a MemberInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.MemberInfo} MemberInfo
             */
            MemberInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.MemberInfo)
                    return object;
                let message = new $root.kritor.guild.MemberInfo();
                if (object.tiny_id != null)
                    if ($util.Long)
                        (message.tiny_id = $util.Long.fromValue(object.tiny_id)).unsigned = true;
                    else if (typeof object.tiny_id === "string")
                        message.tiny_id = parseInt(object.tiny_id, 10);
                    else if (typeof object.tiny_id === "number")
                        message.tiny_id = object.tiny_id;
                    else if (typeof object.tiny_id === "object")
                        message.tiny_id = new $util.LongBits(object.tiny_id.low >>> 0, object.tiny_id.high >>> 0).toNumber(true);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.nickname != null)
                    message.nickname = String(object.nickname);
                if (object.role_id != null)
                    if ($util.Long)
                        (message.role_id = $util.Long.fromValue(object.role_id)).unsigned = true;
                    else if (typeof object.role_id === "string")
                        message.role_id = parseInt(object.role_id, 10);
                    else if (typeof object.role_id === "number")
                        message.role_id = object.role_id;
                    else if (typeof object.role_id === "object")
                        message.role_id = new $util.LongBits(object.role_id.low >>> 0, object.role_id.high >>> 0).toNumber(true);
                if (object.role_name != null)
                    message.role_name = String(object.role_name);
                if (object.role_color != null)
                    if ($util.Long)
                        (message.role_color = $util.Long.fromValue(object.role_color)).unsigned = true;
                    else if (typeof object.role_color === "string")
                        message.role_color = parseInt(object.role_color, 10);
                    else if (typeof object.role_color === "number")
                        message.role_color = object.role_color;
                    else if (typeof object.role_color === "object")
                        message.role_color = new $util.LongBits(object.role_color.low >>> 0, object.role_color.high >>> 0).toNumber(true);
                if (object.join_time != null)
                    if ($util.Long)
                        (message.join_time = $util.Long.fromValue(object.join_time)).unsigned = true;
                    else if (typeof object.join_time === "string")
                        message.join_time = parseInt(object.join_time, 10);
                    else if (typeof object.join_time === "number")
                        message.join_time = object.join_time;
                    else if (typeof object.join_time === "object")
                        message.join_time = new $util.LongBits(object.join_time.low >>> 0, object.join_time.high >>> 0).toNumber(true);
                if (object.robot_type != null)
                    if ($util.Long)
                        (message.robot_type = $util.Long.fromValue(object.robot_type)).unsigned = true;
                    else if (typeof object.robot_type === "string")
                        message.robot_type = parseInt(object.robot_type, 10);
                    else if (typeof object.robot_type === "number")
                        message.robot_type = object.robot_type;
                    else if (typeof object.robot_type === "object")
                        message.robot_type = new $util.LongBits(object.robot_type.low >>> 0, object.robot_type.high >>> 0).toNumber(true);
                if (object.type != null)
                    if ($util.Long)
                        (message.type = $util.Long.fromValue(object.type)).unsigned = true;
                    else if (typeof object.type === "string")
                        message.type = parseInt(object.type, 10);
                    else if (typeof object.type === "number")
                        message.type = object.type;
                    else if (typeof object.type === "object")
                        message.type = new $util.LongBits(object.type.low >>> 0, object.type.high >>> 0).toNumber(true);
                if (object.in_black != null)
                    message.in_black = Boolean(object.in_black);
                if (object.platform != null)
                    if ($util.Long)
                        (message.platform = $util.Long.fromValue(object.platform)).unsigned = true;
                    else if (typeof object.platform === "string")
                        message.platform = parseInt(object.platform, 10);
                    else if (typeof object.platform === "number")
                        message.platform = object.platform;
                    else if (typeof object.platform === "object")
                        message.platform = new $util.LongBits(object.platform.low >>> 0, object.platform.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a MemberInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {kritor.guild.MemberInfo} message MemberInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MemberInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tiny_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tiny_id = options.longs === String ? "0" : 0;
                    object.title = "";
                    object.nickname = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.role_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.role_id = options.longs === String ? "0" : 0;
                    object.role_name = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.role_color = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.role_color = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.join_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.join_time = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.robot_type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.robot_type = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.type = options.longs === String ? "0" : 0;
                    object.in_black = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.platform = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.platform = options.longs === String ? "0" : 0;
                }
                if (message.tiny_id != null && message.hasOwnProperty("tiny_id"))
                    if (typeof message.tiny_id === "number")
                        object.tiny_id = options.longs === String ? String(message.tiny_id) : message.tiny_id;
                    else
                        object.tiny_id = options.longs === String ? $util.Long.prototype.toString.call(message.tiny_id) : options.longs === Number ? new $util.LongBits(message.tiny_id.low >>> 0, message.tiny_id.high >>> 0).toNumber(true) : message.tiny_id;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    object.nickname = message.nickname;
                if (message.role_id != null && message.hasOwnProperty("role_id"))
                    if (typeof message.role_id === "number")
                        object.role_id = options.longs === String ? String(message.role_id) : message.role_id;
                    else
                        object.role_id = options.longs === String ? $util.Long.prototype.toString.call(message.role_id) : options.longs === Number ? new $util.LongBits(message.role_id.low >>> 0, message.role_id.high >>> 0).toNumber(true) : message.role_id;
                if (message.role_name != null && message.hasOwnProperty("role_name"))
                    object.role_name = message.role_name;
                if (message.role_color != null && message.hasOwnProperty("role_color"))
                    if (typeof message.role_color === "number")
                        object.role_color = options.longs === String ? String(message.role_color) : message.role_color;
                    else
                        object.role_color = options.longs === String ? $util.Long.prototype.toString.call(message.role_color) : options.longs === Number ? new $util.LongBits(message.role_color.low >>> 0, message.role_color.high >>> 0).toNumber(true) : message.role_color;
                if (message.join_time != null && message.hasOwnProperty("join_time"))
                    if (typeof message.join_time === "number")
                        object.join_time = options.longs === String ? String(message.join_time) : message.join_time;
                    else
                        object.join_time = options.longs === String ? $util.Long.prototype.toString.call(message.join_time) : options.longs === Number ? new $util.LongBits(message.join_time.low >>> 0, message.join_time.high >>> 0).toNumber(true) : message.join_time;
                if (message.robot_type != null && message.hasOwnProperty("robot_type"))
                    if (typeof message.robot_type === "number")
                        object.robot_type = options.longs === String ? String(message.robot_type) : message.robot_type;
                    else
                        object.robot_type = options.longs === String ? $util.Long.prototype.toString.call(message.robot_type) : options.longs === Number ? new $util.LongBits(message.robot_type.low >>> 0, message.robot_type.high >>> 0).toNumber(true) : message.robot_type;
                if (message.type != null && message.hasOwnProperty("type"))
                    if (typeof message.type === "number")
                        object.type = options.longs === String ? String(message.type) : message.type;
                    else
                        object.type = options.longs === String ? $util.Long.prototype.toString.call(message.type) : options.longs === Number ? new $util.LongBits(message.type.low >>> 0, message.type.high >>> 0).toNumber(true) : message.type;
                if (message.in_black != null && message.hasOwnProperty("in_black"))
                    object.in_black = message.in_black;
                if (message.platform != null && message.hasOwnProperty("platform"))
                    if (typeof message.platform === "number")
                        object.platform = options.longs === String ? String(message.platform) : message.platform;
                    else
                        object.platform = options.longs === String ? $util.Long.prototype.toString.call(message.platform) : options.longs === Number ? new $util.LongBits(message.platform.low >>> 0, message.platform.high >>> 0).toNumber(true) : message.platform;
                return object;
            };

            /**
             * Converts this MemberInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.MemberInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MemberInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MemberInfo
             * @function getTypeUrl
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MemberInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.MemberInfo";
            };

            return MemberInfo;
        })();

        guild.MemberProfile = (function() {

            /**
             * Properties of a MemberProfile.
             * @memberof kritor.guild
             * @interface IMemberProfile
             * @property {number|Long|null} [tiny_id] MemberProfile tiny_id
             * @property {string|null} [nickname] MemberProfile nickname
             * @property {string|null} [avatar_url] MemberProfile avatar_url
             * @property {number|Long|null} [join_time] MemberProfile join_time
             * @property {Array.<kritor.guild.IMemberRoleInfo>|null} [roles_info] MemberProfile roles_info
             */

            /**
             * Constructs a new MemberProfile.
             * @memberof kritor.guild
             * @classdesc Represents a MemberProfile.
             * @implements IMemberProfile
             * @constructor
             * @param {kritor.guild.IMemberProfile=} [properties] Properties to set
             */
            function MemberProfile(properties) {
                this.roles_info = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MemberProfile tiny_id.
             * @member {number|Long} tiny_id
             * @memberof kritor.guild.MemberProfile
             * @instance
             */
            MemberProfile.prototype.tiny_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberProfile nickname.
             * @member {string} nickname
             * @memberof kritor.guild.MemberProfile
             * @instance
             */
            MemberProfile.prototype.nickname = "";

            /**
             * MemberProfile avatar_url.
             * @member {string} avatar_url
             * @memberof kritor.guild.MemberProfile
             * @instance
             */
            MemberProfile.prototype.avatar_url = "";

            /**
             * MemberProfile join_time.
             * @member {number|Long} join_time
             * @memberof kritor.guild.MemberProfile
             * @instance
             */
            MemberProfile.prototype.join_time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberProfile roles_info.
             * @member {Array.<kritor.guild.IMemberRoleInfo>} roles_info
             * @memberof kritor.guild.MemberProfile
             * @instance
             */
            MemberProfile.prototype.roles_info = $util.emptyArray;

            /**
             * Creates a new MemberProfile instance using the specified properties.
             * @function create
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {kritor.guild.IMemberProfile=} [properties] Properties to set
             * @returns {kritor.guild.MemberProfile} MemberProfile instance
             */
            MemberProfile.create = function create(properties) {
                return new MemberProfile(properties);
            };

            /**
             * Encodes the specified MemberProfile message. Does not implicitly {@link kritor.guild.MemberProfile.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {kritor.guild.IMemberProfile} message MemberProfile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberProfile.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tiny_id != null && Object.hasOwnProperty.call(message, "tiny_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tiny_id);
                if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);
                if (message.avatar_url != null && Object.hasOwnProperty.call(message, "avatar_url"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatar_url);
                if (message.join_time != null && Object.hasOwnProperty.call(message, "join_time"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.join_time);
                if (message.roles_info != null && message.roles_info.length)
                    for (let i = 0; i < message.roles_info.length; ++i)
                        $root.kritor.guild.MemberRoleInfo.encode(message.roles_info[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MemberProfile message, length delimited. Does not implicitly {@link kritor.guild.MemberProfile.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {kritor.guild.IMemberProfile} message MemberProfile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberProfile.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MemberProfile message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.MemberProfile} MemberProfile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberProfile.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.MemberProfile();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tiny_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.nickname = reader.string();
                            break;
                        }
                    case 3: {
                            message.avatar_url = reader.string();
                            break;
                        }
                    case 4: {
                            message.join_time = reader.uint64();
                            break;
                        }
                    case 5: {
                            if (!(message.roles_info && message.roles_info.length))
                                message.roles_info = [];
                            message.roles_info.push($root.kritor.guild.MemberRoleInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MemberProfile message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.MemberProfile} MemberProfile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberProfile.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MemberProfile message.
             * @function verify
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MemberProfile.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tiny_id != null && message.hasOwnProperty("tiny_id"))
                    if (!$util.isInteger(message.tiny_id) && !(message.tiny_id && $util.isInteger(message.tiny_id.low) && $util.isInteger(message.tiny_id.high)))
                        return "tiny_id: integer|Long expected";
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    if (!$util.isString(message.nickname))
                        return "nickname: string expected";
                if (message.avatar_url != null && message.hasOwnProperty("avatar_url"))
                    if (!$util.isString(message.avatar_url))
                        return "avatar_url: string expected";
                if (message.join_time != null && message.hasOwnProperty("join_time"))
                    if (!$util.isInteger(message.join_time) && !(message.join_time && $util.isInteger(message.join_time.low) && $util.isInteger(message.join_time.high)))
                        return "join_time: integer|Long expected";
                if (message.roles_info != null && message.hasOwnProperty("roles_info")) {
                    if (!Array.isArray(message.roles_info))
                        return "roles_info: array expected";
                    for (let i = 0; i < message.roles_info.length; ++i) {
                        let error = $root.kritor.guild.MemberRoleInfo.verify(message.roles_info[i]);
                        if (error)
                            return "roles_info." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MemberProfile message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.MemberProfile} MemberProfile
             */
            MemberProfile.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.MemberProfile)
                    return object;
                let message = new $root.kritor.guild.MemberProfile();
                if (object.tiny_id != null)
                    if ($util.Long)
                        (message.tiny_id = $util.Long.fromValue(object.tiny_id)).unsigned = true;
                    else if (typeof object.tiny_id === "string")
                        message.tiny_id = parseInt(object.tiny_id, 10);
                    else if (typeof object.tiny_id === "number")
                        message.tiny_id = object.tiny_id;
                    else if (typeof object.tiny_id === "object")
                        message.tiny_id = new $util.LongBits(object.tiny_id.low >>> 0, object.tiny_id.high >>> 0).toNumber(true);
                if (object.nickname != null)
                    message.nickname = String(object.nickname);
                if (object.avatar_url != null)
                    message.avatar_url = String(object.avatar_url);
                if (object.join_time != null)
                    if ($util.Long)
                        (message.join_time = $util.Long.fromValue(object.join_time)).unsigned = true;
                    else if (typeof object.join_time === "string")
                        message.join_time = parseInt(object.join_time, 10);
                    else if (typeof object.join_time === "number")
                        message.join_time = object.join_time;
                    else if (typeof object.join_time === "object")
                        message.join_time = new $util.LongBits(object.join_time.low >>> 0, object.join_time.high >>> 0).toNumber(true);
                if (object.roles_info) {
                    if (!Array.isArray(object.roles_info))
                        throw TypeError(".kritor.guild.MemberProfile.roles_info: array expected");
                    message.roles_info = [];
                    for (let i = 0; i < object.roles_info.length; ++i) {
                        if (typeof object.roles_info[i] !== "object")
                            throw TypeError(".kritor.guild.MemberProfile.roles_info: object expected");
                        message.roles_info[i] = $root.kritor.guild.MemberRoleInfo.fromObject(object.roles_info[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MemberProfile message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {kritor.guild.MemberProfile} message MemberProfile
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MemberProfile.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.roles_info = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tiny_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tiny_id = options.longs === String ? "0" : 0;
                    object.nickname = "";
                    object.avatar_url = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.join_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.join_time = options.longs === String ? "0" : 0;
                }
                if (message.tiny_id != null && message.hasOwnProperty("tiny_id"))
                    if (typeof message.tiny_id === "number")
                        object.tiny_id = options.longs === String ? String(message.tiny_id) : message.tiny_id;
                    else
                        object.tiny_id = options.longs === String ? $util.Long.prototype.toString.call(message.tiny_id) : options.longs === Number ? new $util.LongBits(message.tiny_id.low >>> 0, message.tiny_id.high >>> 0).toNumber(true) : message.tiny_id;
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    object.nickname = message.nickname;
                if (message.avatar_url != null && message.hasOwnProperty("avatar_url"))
                    object.avatar_url = message.avatar_url;
                if (message.join_time != null && message.hasOwnProperty("join_time"))
                    if (typeof message.join_time === "number")
                        object.join_time = options.longs === String ? String(message.join_time) : message.join_time;
                    else
                        object.join_time = options.longs === String ? $util.Long.prototype.toString.call(message.join_time) : options.longs === Number ? new $util.LongBits(message.join_time.low >>> 0, message.join_time.high >>> 0).toNumber(true) : message.join_time;
                if (message.roles_info && message.roles_info.length) {
                    object.roles_info = [];
                    for (let j = 0; j < message.roles_info.length; ++j)
                        object.roles_info[j] = $root.kritor.guild.MemberRoleInfo.toObject(message.roles_info[j], options);
                }
                return object;
            };

            /**
             * Converts this MemberProfile to JSON.
             * @function toJSON
             * @memberof kritor.guild.MemberProfile
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MemberProfile.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MemberProfile
             * @function getTypeUrl
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MemberProfile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.MemberProfile";
            };

            return MemberProfile;
        })();

        guild.PermissionInfo = (function() {

            /**
             * Properties of a PermissionInfo.
             * @memberof kritor.guild
             * @interface IPermissionInfo
             * @property {number|Long|null} [root_id] PermissionInfo root_id
             * @property {Array.<number|Long>|null} [child_ids] PermissionInfo child_ids
             */

            /**
             * Constructs a new PermissionInfo.
             * @memberof kritor.guild
             * @classdesc Represents a PermissionInfo.
             * @implements IPermissionInfo
             * @constructor
             * @param {kritor.guild.IPermissionInfo=} [properties] Properties to set
             */
            function PermissionInfo(properties) {
                this.child_ids = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PermissionInfo root_id.
             * @member {number|Long} root_id
             * @memberof kritor.guild.PermissionInfo
             * @instance
             */
            PermissionInfo.prototype.root_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * PermissionInfo child_ids.
             * @member {Array.<number|Long>} child_ids
             * @memberof kritor.guild.PermissionInfo
             * @instance
             */
            PermissionInfo.prototype.child_ids = $util.emptyArray;

            /**
             * Creates a new PermissionInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {kritor.guild.IPermissionInfo=} [properties] Properties to set
             * @returns {kritor.guild.PermissionInfo} PermissionInfo instance
             */
            PermissionInfo.create = function create(properties) {
                return new PermissionInfo(properties);
            };

            /**
             * Encodes the specified PermissionInfo message. Does not implicitly {@link kritor.guild.PermissionInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {kritor.guild.IPermissionInfo} message PermissionInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PermissionInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.root_id != null && Object.hasOwnProperty.call(message, "root_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.root_id);
                if (message.child_ids != null && message.child_ids.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (let i = 0; i < message.child_ids.length; ++i)
                        writer.uint64(message.child_ids[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified PermissionInfo message, length delimited. Does not implicitly {@link kritor.guild.PermissionInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {kritor.guild.IPermissionInfo} message PermissionInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PermissionInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PermissionInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.PermissionInfo} PermissionInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PermissionInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.PermissionInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.root_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            if (!(message.child_ids && message.child_ids.length))
                                message.child_ids = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.child_ids.push(reader.uint64());
                            } else
                                message.child_ids.push(reader.uint64());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PermissionInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.PermissionInfo} PermissionInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PermissionInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PermissionInfo message.
             * @function verify
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PermissionInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.root_id != null && message.hasOwnProperty("root_id"))
                    if (!$util.isInteger(message.root_id) && !(message.root_id && $util.isInteger(message.root_id.low) && $util.isInteger(message.root_id.high)))
                        return "root_id: integer|Long expected";
                if (message.child_ids != null && message.hasOwnProperty("child_ids")) {
                    if (!Array.isArray(message.child_ids))
                        return "child_ids: array expected";
                    for (let i = 0; i < message.child_ids.length; ++i)
                        if (!$util.isInteger(message.child_ids[i]) && !(message.child_ids[i] && $util.isInteger(message.child_ids[i].low) && $util.isInteger(message.child_ids[i].high)))
                            return "child_ids: integer|Long[] expected";
                }
                return null;
            };

            /**
             * Creates a PermissionInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.PermissionInfo} PermissionInfo
             */
            PermissionInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.PermissionInfo)
                    return object;
                let message = new $root.kritor.guild.PermissionInfo();
                if (object.root_id != null)
                    if ($util.Long)
                        (message.root_id = $util.Long.fromValue(object.root_id)).unsigned = true;
                    else if (typeof object.root_id === "string")
                        message.root_id = parseInt(object.root_id, 10);
                    else if (typeof object.root_id === "number")
                        message.root_id = object.root_id;
                    else if (typeof object.root_id === "object")
                        message.root_id = new $util.LongBits(object.root_id.low >>> 0, object.root_id.high >>> 0).toNumber(true);
                if (object.child_ids) {
                    if (!Array.isArray(object.child_ids))
                        throw TypeError(".kritor.guild.PermissionInfo.child_ids: array expected");
                    message.child_ids = [];
                    for (let i = 0; i < object.child_ids.length; ++i)
                        if ($util.Long)
                            (message.child_ids[i] = $util.Long.fromValue(object.child_ids[i])).unsigned = true;
                        else if (typeof object.child_ids[i] === "string")
                            message.child_ids[i] = parseInt(object.child_ids[i], 10);
                        else if (typeof object.child_ids[i] === "number")
                            message.child_ids[i] = object.child_ids[i];
                        else if (typeof object.child_ids[i] === "object")
                            message.child_ids[i] = new $util.LongBits(object.child_ids[i].low >>> 0, object.child_ids[i].high >>> 0).toNumber(true);
                }
                return message;
            };

            /**
             * Creates a plain object from a PermissionInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {kritor.guild.PermissionInfo} message PermissionInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PermissionInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.child_ids = [];
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.root_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.root_id = options.longs === String ? "0" : 0;
                if (message.root_id != null && message.hasOwnProperty("root_id"))
                    if (typeof message.root_id === "number")
                        object.root_id = options.longs === String ? String(message.root_id) : message.root_id;
                    else
                        object.root_id = options.longs === String ? $util.Long.prototype.toString.call(message.root_id) : options.longs === Number ? new $util.LongBits(message.root_id.low >>> 0, message.root_id.high >>> 0).toNumber(true) : message.root_id;
                if (message.child_ids && message.child_ids.length) {
                    object.child_ids = [];
                    for (let j = 0; j < message.child_ids.length; ++j)
                        if (typeof message.child_ids[j] === "number")
                            object.child_ids[j] = options.longs === String ? String(message.child_ids[j]) : message.child_ids[j];
                        else
                            object.child_ids[j] = options.longs === String ? $util.Long.prototype.toString.call(message.child_ids[j]) : options.longs === Number ? new $util.LongBits(message.child_ids[j].low >>> 0, message.child_ids[j].high >>> 0).toNumber(true) : message.child_ids[j];
                }
                return object;
            };

            /**
             * Converts this PermissionInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.PermissionInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PermissionInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PermissionInfo
             * @function getTypeUrl
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PermissionInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.PermissionInfo";
            };

            return PermissionInfo;
        })();

        guild.MemberRoleInfo = (function() {

            /**
             * Properties of a MemberRoleInfo.
             * @memberof kritor.guild
             * @interface IMemberRoleInfo
             * @property {number|Long|null} [role_id] MemberRoleInfo role_id
             * @property {string|null} [role_name] MemberRoleInfo role_name
             * @property {number|Long|null} [color] MemberRoleInfo color
             * @property {Array.<kritor.guild.IPermissionInfo>|null} [permissions] MemberRoleInfo permissions
             * @property {number|Long|null} [type] MemberRoleInfo type
             * @property {string|null} [display_name] MemberRoleInfo display_name
             */

            /**
             * Constructs a new MemberRoleInfo.
             * @memberof kritor.guild
             * @classdesc Represents a MemberRoleInfo.
             * @implements IMemberRoleInfo
             * @constructor
             * @param {kritor.guild.IMemberRoleInfo=} [properties] Properties to set
             */
            function MemberRoleInfo(properties) {
                this.permissions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MemberRoleInfo role_id.
             * @member {number|Long} role_id
             * @memberof kritor.guild.MemberRoleInfo
             * @instance
             */
            MemberRoleInfo.prototype.role_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberRoleInfo role_name.
             * @member {string} role_name
             * @memberof kritor.guild.MemberRoleInfo
             * @instance
             */
            MemberRoleInfo.prototype.role_name = "";

            /**
             * MemberRoleInfo color.
             * @member {number|Long} color
             * @memberof kritor.guild.MemberRoleInfo
             * @instance
             */
            MemberRoleInfo.prototype.color = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberRoleInfo permissions.
             * @member {Array.<kritor.guild.IPermissionInfo>} permissions
             * @memberof kritor.guild.MemberRoleInfo
             * @instance
             */
            MemberRoleInfo.prototype.permissions = $util.emptyArray;

            /**
             * MemberRoleInfo type.
             * @member {number|Long} type
             * @memberof kritor.guild.MemberRoleInfo
             * @instance
             */
            MemberRoleInfo.prototype.type = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberRoleInfo display_name.
             * @member {string} display_name
             * @memberof kritor.guild.MemberRoleInfo
             * @instance
             */
            MemberRoleInfo.prototype.display_name = "";

            /**
             * Creates a new MemberRoleInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {kritor.guild.IMemberRoleInfo=} [properties] Properties to set
             * @returns {kritor.guild.MemberRoleInfo} MemberRoleInfo instance
             */
            MemberRoleInfo.create = function create(properties) {
                return new MemberRoleInfo(properties);
            };

            /**
             * Encodes the specified MemberRoleInfo message. Does not implicitly {@link kritor.guild.MemberRoleInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {kritor.guild.IMemberRoleInfo} message MemberRoleInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberRoleInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.role_id != null && Object.hasOwnProperty.call(message, "role_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.role_id);
                if (message.role_name != null && Object.hasOwnProperty.call(message, "role_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.role_name);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.color);
                if (message.permissions != null && message.permissions.length)
                    for (let i = 0; i < message.permissions.length; ++i)
                        $root.kritor.guild.PermissionInfo.encode(message.permissions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.type);
                if (message.display_name != null && Object.hasOwnProperty.call(message, "display_name"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.display_name);
                return writer;
            };

            /**
             * Encodes the specified MemberRoleInfo message, length delimited. Does not implicitly {@link kritor.guild.MemberRoleInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {kritor.guild.IMemberRoleInfo} message MemberRoleInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberRoleInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MemberRoleInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.MemberRoleInfo} MemberRoleInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberRoleInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.MemberRoleInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.role_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.role_name = reader.string();
                            break;
                        }
                    case 3: {
                            message.color = reader.uint64();
                            break;
                        }
                    case 4: {
                            if (!(message.permissions && message.permissions.length))
                                message.permissions = [];
                            message.permissions.push($root.kritor.guild.PermissionInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            message.type = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.display_name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MemberRoleInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.MemberRoleInfo} MemberRoleInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberRoleInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MemberRoleInfo message.
             * @function verify
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MemberRoleInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.role_id != null && message.hasOwnProperty("role_id"))
                    if (!$util.isInteger(message.role_id) && !(message.role_id && $util.isInteger(message.role_id.low) && $util.isInteger(message.role_id.high)))
                        return "role_id: integer|Long expected";
                if (message.role_name != null && message.hasOwnProperty("role_name"))
                    if (!$util.isString(message.role_name))
                        return "role_name: string expected";
                if (message.color != null && message.hasOwnProperty("color"))
                    if (!$util.isInteger(message.color) && !(message.color && $util.isInteger(message.color.low) && $util.isInteger(message.color.high)))
                        return "color: integer|Long expected";
                if (message.permissions != null && message.hasOwnProperty("permissions")) {
                    if (!Array.isArray(message.permissions))
                        return "permissions: array expected";
                    for (let i = 0; i < message.permissions.length; ++i) {
                        let error = $root.kritor.guild.PermissionInfo.verify(message.permissions[i]);
                        if (error)
                            return "permissions." + error;
                    }
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type) && !(message.type && $util.isInteger(message.type.low) && $util.isInteger(message.type.high)))
                        return "type: integer|Long expected";
                if (message.display_name != null && message.hasOwnProperty("display_name"))
                    if (!$util.isString(message.display_name))
                        return "display_name: string expected";
                return null;
            };

            /**
             * Creates a MemberRoleInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.MemberRoleInfo} MemberRoleInfo
             */
            MemberRoleInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.MemberRoleInfo)
                    return object;
                let message = new $root.kritor.guild.MemberRoleInfo();
                if (object.role_id != null)
                    if ($util.Long)
                        (message.role_id = $util.Long.fromValue(object.role_id)).unsigned = true;
                    else if (typeof object.role_id === "string")
                        message.role_id = parseInt(object.role_id, 10);
                    else if (typeof object.role_id === "number")
                        message.role_id = object.role_id;
                    else if (typeof object.role_id === "object")
                        message.role_id = new $util.LongBits(object.role_id.low >>> 0, object.role_id.high >>> 0).toNumber(true);
                if (object.role_name != null)
                    message.role_name = String(object.role_name);
                if (object.color != null)
                    if ($util.Long)
                        (message.color = $util.Long.fromValue(object.color)).unsigned = true;
                    else if (typeof object.color === "string")
                        message.color = parseInt(object.color, 10);
                    else if (typeof object.color === "number")
                        message.color = object.color;
                    else if (typeof object.color === "object")
                        message.color = new $util.LongBits(object.color.low >>> 0, object.color.high >>> 0).toNumber(true);
                if (object.permissions) {
                    if (!Array.isArray(object.permissions))
                        throw TypeError(".kritor.guild.MemberRoleInfo.permissions: array expected");
                    message.permissions = [];
                    for (let i = 0; i < object.permissions.length; ++i) {
                        if (typeof object.permissions[i] !== "object")
                            throw TypeError(".kritor.guild.MemberRoleInfo.permissions: object expected");
                        message.permissions[i] = $root.kritor.guild.PermissionInfo.fromObject(object.permissions[i]);
                    }
                }
                if (object.type != null)
                    if ($util.Long)
                        (message.type = $util.Long.fromValue(object.type)).unsigned = true;
                    else if (typeof object.type === "string")
                        message.type = parseInt(object.type, 10);
                    else if (typeof object.type === "number")
                        message.type = object.type;
                    else if (typeof object.type === "object")
                        message.type = new $util.LongBits(object.type.low >>> 0, object.type.high >>> 0).toNumber(true);
                if (object.display_name != null)
                    message.display_name = String(object.display_name);
                return message;
            };

            /**
             * Creates a plain object from a MemberRoleInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {kritor.guild.MemberRoleInfo} message MemberRoleInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MemberRoleInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.permissions = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.role_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.role_id = options.longs === String ? "0" : 0;
                    object.role_name = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.color = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.color = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.type = options.longs === String ? "0" : 0;
                    object.display_name = "";
                }
                if (message.role_id != null && message.hasOwnProperty("role_id"))
                    if (typeof message.role_id === "number")
                        object.role_id = options.longs === String ? String(message.role_id) : message.role_id;
                    else
                        object.role_id = options.longs === String ? $util.Long.prototype.toString.call(message.role_id) : options.longs === Number ? new $util.LongBits(message.role_id.low >>> 0, message.role_id.high >>> 0).toNumber(true) : message.role_id;
                if (message.role_name != null && message.hasOwnProperty("role_name"))
                    object.role_name = message.role_name;
                if (message.color != null && message.hasOwnProperty("color"))
                    if (typeof message.color === "number")
                        object.color = options.longs === String ? String(message.color) : message.color;
                    else
                        object.color = options.longs === String ? $util.Long.prototype.toString.call(message.color) : options.longs === Number ? new $util.LongBits(message.color.low >>> 0, message.color.high >>> 0).toNumber(true) : message.color;
                if (message.permissions && message.permissions.length) {
                    object.permissions = [];
                    for (let j = 0; j < message.permissions.length; ++j)
                        object.permissions[j] = $root.kritor.guild.PermissionInfo.toObject(message.permissions[j], options);
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    if (typeof message.type === "number")
                        object.type = options.longs === String ? String(message.type) : message.type;
                    else
                        object.type = options.longs === String ? $util.Long.prototype.toString.call(message.type) : options.longs === Number ? new $util.LongBits(message.type.low >>> 0, message.type.high >>> 0).toNumber(true) : message.type;
                if (message.display_name != null && message.hasOwnProperty("display_name"))
                    object.display_name = message.display_name;
                return object;
            };

            /**
             * Converts this MemberRoleInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.MemberRoleInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MemberRoleInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MemberRoleInfo
             * @function getTypeUrl
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MemberRoleInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.MemberRoleInfo";
            };

            return MemberRoleInfo;
        })();

        guild.RoleInfo = (function() {

            /**
             * Properties of a RoleInfo.
             * @memberof kritor.guild
             * @interface IRoleInfo
             * @property {number|Long|null} [role_id] RoleInfo role_id
             * @property {string|null} [role_name] RoleInfo role_name
             * @property {number|Long|null} [color] RoleInfo color
             * @property {Array.<kritor.guild.IPermissionInfo>|null} [permissions] RoleInfo permissions
             * @property {boolean|null} [disabled] RoleInfo disabled
             * @property {boolean|null} [independent] RoleInfo independent
             * @property {number|Long|null} [max_count] RoleInfo max_count
             * @property {number|Long|null} [member_count] RoleInfo member_count
             * @property {boolean|null} [owned] RoleInfo owned
             */

            /**
             * Constructs a new RoleInfo.
             * @memberof kritor.guild
             * @classdesc Represents a RoleInfo.
             * @implements IRoleInfo
             * @constructor
             * @param {kritor.guild.IRoleInfo=} [properties] Properties to set
             */
            function RoleInfo(properties) {
                this.permissions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RoleInfo role_id.
             * @member {number|Long} role_id
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.role_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RoleInfo role_name.
             * @member {string} role_name
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.role_name = "";

            /**
             * RoleInfo color.
             * @member {number|Long} color
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.color = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RoleInfo permissions.
             * @member {Array.<kritor.guild.IPermissionInfo>} permissions
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.permissions = $util.emptyArray;

            /**
             * RoleInfo disabled.
             * @member {boolean} disabled
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.disabled = false;

            /**
             * RoleInfo independent.
             * @member {boolean} independent
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.independent = false;

            /**
             * RoleInfo max_count.
             * @member {number|Long} max_count
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.max_count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RoleInfo member_count.
             * @member {number|Long} member_count
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.member_count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RoleInfo owned.
             * @member {boolean} owned
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.owned = false;

            /**
             * Creates a new RoleInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {kritor.guild.IRoleInfo=} [properties] Properties to set
             * @returns {kritor.guild.RoleInfo} RoleInfo instance
             */
            RoleInfo.create = function create(properties) {
                return new RoleInfo(properties);
            };

            /**
             * Encodes the specified RoleInfo message. Does not implicitly {@link kritor.guild.RoleInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {kritor.guild.IRoleInfo} message RoleInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.role_id != null && Object.hasOwnProperty.call(message, "role_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.role_id);
                if (message.role_name != null && Object.hasOwnProperty.call(message, "role_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.role_name);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.color);
                if (message.permissions != null && message.permissions.length)
                    for (let i = 0; i < message.permissions.length; ++i)
                        $root.kritor.guild.PermissionInfo.encode(message.permissions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.disabled);
                if (message.independent != null && Object.hasOwnProperty.call(message, "independent"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.independent);
                if (message.max_count != null && Object.hasOwnProperty.call(message, "max_count"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.max_count);
                if (message.member_count != null && Object.hasOwnProperty.call(message, "member_count"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.member_count);
                if (message.owned != null && Object.hasOwnProperty.call(message, "owned"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.owned);
                return writer;
            };

            /**
             * Encodes the specified RoleInfo message, length delimited. Does not implicitly {@link kritor.guild.RoleInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {kritor.guild.IRoleInfo} message RoleInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RoleInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.RoleInfo} RoleInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.RoleInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.role_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.role_name = reader.string();
                            break;
                        }
                    case 3: {
                            message.color = reader.uint64();
                            break;
                        }
                    case 4: {
                            if (!(message.permissions && message.permissions.length))
                                message.permissions = [];
                            message.permissions.push($root.kritor.guild.PermissionInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            message.disabled = reader.bool();
                            break;
                        }
                    case 6: {
                            message.independent = reader.bool();
                            break;
                        }
                    case 7: {
                            message.max_count = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.member_count = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.owned = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RoleInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.RoleInfo} RoleInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RoleInfo message.
             * @function verify
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RoleInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.role_id != null && message.hasOwnProperty("role_id"))
                    if (!$util.isInteger(message.role_id) && !(message.role_id && $util.isInteger(message.role_id.low) && $util.isInteger(message.role_id.high)))
                        return "role_id: integer|Long expected";
                if (message.role_name != null && message.hasOwnProperty("role_name"))
                    if (!$util.isString(message.role_name))
                        return "role_name: string expected";
                if (message.color != null && message.hasOwnProperty("color"))
                    if (!$util.isInteger(message.color) && !(message.color && $util.isInteger(message.color.low) && $util.isInteger(message.color.high)))
                        return "color: integer|Long expected";
                if (message.permissions != null && message.hasOwnProperty("permissions")) {
                    if (!Array.isArray(message.permissions))
                        return "permissions: array expected";
                    for (let i = 0; i < message.permissions.length; ++i) {
                        let error = $root.kritor.guild.PermissionInfo.verify(message.permissions[i]);
                        if (error)
                            return "permissions." + error;
                    }
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    if (typeof message.disabled !== "boolean")
                        return "disabled: boolean expected";
                if (message.independent != null && message.hasOwnProperty("independent"))
                    if (typeof message.independent !== "boolean")
                        return "independent: boolean expected";
                if (message.max_count != null && message.hasOwnProperty("max_count"))
                    if (!$util.isInteger(message.max_count) && !(message.max_count && $util.isInteger(message.max_count.low) && $util.isInteger(message.max_count.high)))
                        return "max_count: integer|Long expected";
                if (message.member_count != null && message.hasOwnProperty("member_count"))
                    if (!$util.isInteger(message.member_count) && !(message.member_count && $util.isInteger(message.member_count.low) && $util.isInteger(message.member_count.high)))
                        return "member_count: integer|Long expected";
                if (message.owned != null && message.hasOwnProperty("owned"))
                    if (typeof message.owned !== "boolean")
                        return "owned: boolean expected";
                return null;
            };

            /**
             * Creates a RoleInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.RoleInfo} RoleInfo
             */
            RoleInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.RoleInfo)
                    return object;
                let message = new $root.kritor.guild.RoleInfo();
                if (object.role_id != null)
                    if ($util.Long)
                        (message.role_id = $util.Long.fromValue(object.role_id)).unsigned = true;
                    else if (typeof object.role_id === "string")
                        message.role_id = parseInt(object.role_id, 10);
                    else if (typeof object.role_id === "number")
                        message.role_id = object.role_id;
                    else if (typeof object.role_id === "object")
                        message.role_id = new $util.LongBits(object.role_id.low >>> 0, object.role_id.high >>> 0).toNumber(true);
                if (object.role_name != null)
                    message.role_name = String(object.role_name);
                if (object.color != null)
                    if ($util.Long)
                        (message.color = $util.Long.fromValue(object.color)).unsigned = true;
                    else if (typeof object.color === "string")
                        message.color = parseInt(object.color, 10);
                    else if (typeof object.color === "number")
                        message.color = object.color;
                    else if (typeof object.color === "object")
                        message.color = new $util.LongBits(object.color.low >>> 0, object.color.high >>> 0).toNumber(true);
                if (object.permissions) {
                    if (!Array.isArray(object.permissions))
                        throw TypeError(".kritor.guild.RoleInfo.permissions: array expected");
                    message.permissions = [];
                    for (let i = 0; i < object.permissions.length; ++i) {
                        if (typeof object.permissions[i] !== "object")
                            throw TypeError(".kritor.guild.RoleInfo.permissions: object expected");
                        message.permissions[i] = $root.kritor.guild.PermissionInfo.fromObject(object.permissions[i]);
                    }
                }
                if (object.disabled != null)
                    message.disabled = Boolean(object.disabled);
                if (object.independent != null)
                    message.independent = Boolean(object.independent);
                if (object.max_count != null)
                    if ($util.Long)
                        (message.max_count = $util.Long.fromValue(object.max_count)).unsigned = true;
                    else if (typeof object.max_count === "string")
                        message.max_count = parseInt(object.max_count, 10);
                    else if (typeof object.max_count === "number")
                        message.max_count = object.max_count;
                    else if (typeof object.max_count === "object")
                        message.max_count = new $util.LongBits(object.max_count.low >>> 0, object.max_count.high >>> 0).toNumber(true);
                if (object.member_count != null)
                    if ($util.Long)
                        (message.member_count = $util.Long.fromValue(object.member_count)).unsigned = true;
                    else if (typeof object.member_count === "string")
                        message.member_count = parseInt(object.member_count, 10);
                    else if (typeof object.member_count === "number")
                        message.member_count = object.member_count;
                    else if (typeof object.member_count === "object")
                        message.member_count = new $util.LongBits(object.member_count.low >>> 0, object.member_count.high >>> 0).toNumber(true);
                if (object.owned != null)
                    message.owned = Boolean(object.owned);
                return message;
            };

            /**
             * Creates a plain object from a RoleInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {kritor.guild.RoleInfo} message RoleInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RoleInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.permissions = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.role_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.role_id = options.longs === String ? "0" : 0;
                    object.role_name = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.color = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.color = options.longs === String ? "0" : 0;
                    object.disabled = false;
                    object.independent = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.max_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.max_count = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.member_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.member_count = options.longs === String ? "0" : 0;
                    object.owned = false;
                }
                if (message.role_id != null && message.hasOwnProperty("role_id"))
                    if (typeof message.role_id === "number")
                        object.role_id = options.longs === String ? String(message.role_id) : message.role_id;
                    else
                        object.role_id = options.longs === String ? $util.Long.prototype.toString.call(message.role_id) : options.longs === Number ? new $util.LongBits(message.role_id.low >>> 0, message.role_id.high >>> 0).toNumber(true) : message.role_id;
                if (message.role_name != null && message.hasOwnProperty("role_name"))
                    object.role_name = message.role_name;
                if (message.color != null && message.hasOwnProperty("color"))
                    if (typeof message.color === "number")
                        object.color = options.longs === String ? String(message.color) : message.color;
                    else
                        object.color = options.longs === String ? $util.Long.prototype.toString.call(message.color) : options.longs === Number ? new $util.LongBits(message.color.low >>> 0, message.color.high >>> 0).toNumber(true) : message.color;
                if (message.permissions && message.permissions.length) {
                    object.permissions = [];
                    for (let j = 0; j < message.permissions.length; ++j)
                        object.permissions[j] = $root.kritor.guild.PermissionInfo.toObject(message.permissions[j], options);
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    object.disabled = message.disabled;
                if (message.independent != null && message.hasOwnProperty("independent"))
                    object.independent = message.independent;
                if (message.max_count != null && message.hasOwnProperty("max_count"))
                    if (typeof message.max_count === "number")
                        object.max_count = options.longs === String ? String(message.max_count) : message.max_count;
                    else
                        object.max_count = options.longs === String ? $util.Long.prototype.toString.call(message.max_count) : options.longs === Number ? new $util.LongBits(message.max_count.low >>> 0, message.max_count.high >>> 0).toNumber(true) : message.max_count;
                if (message.member_count != null && message.hasOwnProperty("member_count"))
                    if (typeof message.member_count === "number")
                        object.member_count = options.longs === String ? String(message.member_count) : message.member_count;
                    else
                        object.member_count = options.longs === String ? $util.Long.prototype.toString.call(message.member_count) : options.longs === Number ? new $util.LongBits(message.member_count.low >>> 0, message.member_count.high >>> 0).toNumber(true) : message.member_count;
                if (message.owned != null && message.hasOwnProperty("owned"))
                    object.owned = message.owned;
                return object;
            };

            /**
             * Converts this RoleInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.RoleInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RoleInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RoleInfo
             * @function getTypeUrl
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RoleInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.RoleInfo";
            };

            return RoleInfo;
        })();

        return guild;
    })();

    kritor.message = (function() {

        /**
         * Namespace message.
         * @memberof kritor
         * @namespace
         */
        const message = {};

        message.MessageService = (function() {

            /**
             * Constructs a new MessageService service.
             * @memberof kritor.message
             * @classdesc Represents a MessageService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function MessageService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (MessageService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MessageService;

            /**
             * Creates new MessageService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.message.MessageService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {MessageService} RPC service. Useful where requests and/or responses are streamed.
             */
            MessageService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.message.MessageService#sendMessage}.
             * @memberof kritor.message.MessageService
             * @typedef SendMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.SendMessageResponse} [response] SendMessageResponse
             */

            /**
             * Calls SendMessage.
             * @function sendMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISendMessageRequest} request SendMessageRequest message or plain object
             * @param {kritor.message.MessageService.SendMessageCallback} callback Node-style callback called with the error, if any, and SendMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.sendMessage = function sendMessage(request, callback) {
                return this.rpcCall(sendMessage, $root.kritor.message.SendMessageRequest, $root.kritor.message.SendMessageResponse, request, callback);
            }, "name", { value: "SendMessage" });

            /**
             * Calls SendMessage.
             * @function sendMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISendMessageRequest} request SendMessageRequest message or plain object
             * @returns {Promise<kritor.message.SendMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#sendMessageByResId}.
             * @memberof kritor.message.MessageService
             * @typedef SendMessageByResIdCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.SendMessageByResIdResponse} [response] SendMessageByResIdResponse
             */

            /**
             * Calls SendMessageByResId.
             * @function sendMessageByResId
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISendMessageByResIdRequest} request SendMessageByResIdRequest message or plain object
             * @param {kritor.message.MessageService.SendMessageByResIdCallback} callback Node-style callback called with the error, if any, and SendMessageByResIdResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.sendMessageByResId = function sendMessageByResId(request, callback) {
                return this.rpcCall(sendMessageByResId, $root.kritor.message.SendMessageByResIdRequest, $root.kritor.message.SendMessageByResIdResponse, request, callback);
            }, "name", { value: "SendMessageByResId" });

            /**
             * Calls SendMessageByResId.
             * @function sendMessageByResId
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISendMessageByResIdRequest} request SendMessageByResIdRequest message or plain object
             * @returns {Promise<kritor.message.SendMessageByResIdResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#setMessageReaded}.
             * @memberof kritor.message.MessageService
             * @typedef SetMessageReadedCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.SetMessageReadResponse} [response] SetMessageReadResponse
             */

            /**
             * Calls SetMessageReaded.
             * @function setMessageReaded
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISetMessageReadRequest} request SetMessageReadRequest message or plain object
             * @param {kritor.message.MessageService.SetMessageReadedCallback} callback Node-style callback called with the error, if any, and SetMessageReadResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.setMessageReaded = function setMessageReaded(request, callback) {
                return this.rpcCall(setMessageReaded, $root.kritor.message.SetMessageReadRequest, $root.kritor.message.SetMessageReadResponse, request, callback);
            }, "name", { value: "SetMessageReaded" });

            /**
             * Calls SetMessageReaded.
             * @function setMessageReaded
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISetMessageReadRequest} request SetMessageReadRequest message or plain object
             * @returns {Promise<kritor.message.SetMessageReadResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#recallMessage}.
             * @memberof kritor.message.MessageService
             * @typedef RecallMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.RecallMessageResponse} [response] RecallMessageResponse
             */

            /**
             * Calls RecallMessage.
             * @function recallMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IRecallMessageRequest} request RecallMessageRequest message or plain object
             * @param {kritor.message.MessageService.RecallMessageCallback} callback Node-style callback called with the error, if any, and RecallMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.recallMessage = function recallMessage(request, callback) {
                return this.rpcCall(recallMessage, $root.kritor.message.RecallMessageRequest, $root.kritor.message.RecallMessageResponse, request, callback);
            }, "name", { value: "RecallMessage" });

            /**
             * Calls RecallMessage.
             * @function recallMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IRecallMessageRequest} request RecallMessageRequest message or plain object
             * @returns {Promise<kritor.message.RecallMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#reactMessageWithEmoji}.
             * @memberof kritor.message.MessageService
             * @typedef ReactMessageWithEmojiCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.ReactMessageWithEmojiResponse} [response] ReactMessageWithEmojiResponse
             */

            /**
             * Calls ReactMessageWithEmoji.
             * @function reactMessageWithEmoji
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IReactMessageWithEmojiRequest} request ReactMessageWithEmojiRequest message or plain object
             * @param {kritor.message.MessageService.ReactMessageWithEmojiCallback} callback Node-style callback called with the error, if any, and ReactMessageWithEmojiResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.reactMessageWithEmoji = function reactMessageWithEmoji(request, callback) {
                return this.rpcCall(reactMessageWithEmoji, $root.kritor.message.ReactMessageWithEmojiRequest, $root.kritor.message.ReactMessageWithEmojiResponse, request, callback);
            }, "name", { value: "ReactMessageWithEmoji" });

            /**
             * Calls ReactMessageWithEmoji.
             * @function reactMessageWithEmoji
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IReactMessageWithEmojiRequest} request ReactMessageWithEmojiRequest message or plain object
             * @returns {Promise<kritor.message.ReactMessageWithEmojiResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#getMessage}.
             * @memberof kritor.message.MessageService
             * @typedef GetMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.GetMessageResponse} [response] GetMessageResponse
             */

            /**
             * Calls GetMessage.
             * @function getMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetMessageRequest} request GetMessageRequest message or plain object
             * @param {kritor.message.MessageService.GetMessageCallback} callback Node-style callback called with the error, if any, and GetMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getMessage = function getMessage(request, callback) {
                return this.rpcCall(getMessage, $root.kritor.message.GetMessageRequest, $root.kritor.message.GetMessageResponse, request, callback);
            }, "name", { value: "GetMessage" });

            /**
             * Calls GetMessage.
             * @function getMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetMessageRequest} request GetMessageRequest message or plain object
             * @returns {Promise<kritor.message.GetMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#getMessageBySeq}.
             * @memberof kritor.message.MessageService
             * @typedef GetMessageBySeqCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.GetMessageBySeqResponse} [response] GetMessageBySeqResponse
             */

            /**
             * Calls GetMessageBySeq.
             * @function getMessageBySeq
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetMessageBySeqRequest} request GetMessageBySeqRequest message or plain object
             * @param {kritor.message.MessageService.GetMessageBySeqCallback} callback Node-style callback called with the error, if any, and GetMessageBySeqResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getMessageBySeq = function getMessageBySeq(request, callback) {
                return this.rpcCall(getMessageBySeq, $root.kritor.message.GetMessageBySeqRequest, $root.kritor.message.GetMessageBySeqResponse, request, callback);
            }, "name", { value: "GetMessageBySeq" });

            /**
             * Calls GetMessageBySeq.
             * @function getMessageBySeq
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetMessageBySeqRequest} request GetMessageBySeqRequest message or plain object
             * @returns {Promise<kritor.message.GetMessageBySeqResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#getHistoryMessage}.
             * @memberof kritor.message.MessageService
             * @typedef GetHistoryMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.GetHistoryMessageResponse} [response] GetHistoryMessageResponse
             */

            /**
             * Calls GetHistoryMessage.
             * @function getHistoryMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetHistoryMessageRequest} request GetHistoryMessageRequest message or plain object
             * @param {kritor.message.MessageService.GetHistoryMessageCallback} callback Node-style callback called with the error, if any, and GetHistoryMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getHistoryMessage = function getHistoryMessage(request, callback) {
                return this.rpcCall(getHistoryMessage, $root.kritor.message.GetHistoryMessageRequest, $root.kritor.message.GetHistoryMessageResponse, request, callback);
            }, "name", { value: "GetHistoryMessage" });

            /**
             * Calls GetHistoryMessage.
             * @function getHistoryMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetHistoryMessageRequest} request GetHistoryMessageRequest message or plain object
             * @returns {Promise<kritor.message.GetHistoryMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#getHistoryMessageBySeq}.
             * @memberof kritor.message.MessageService
             * @typedef GetHistoryMessageBySeqCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.GetHistoryMessageBySeqResponse} [response] GetHistoryMessageBySeqResponse
             */

            /**
             * Calls GetHistoryMessageBySeq.
             * @function getHistoryMessageBySeq
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetHistoryMessageBySeqRequest} request GetHistoryMessageBySeqRequest message or plain object
             * @param {kritor.message.MessageService.GetHistoryMessageBySeqCallback} callback Node-style callback called with the error, if any, and GetHistoryMessageBySeqResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getHistoryMessageBySeq = function getHistoryMessageBySeq(request, callback) {
                return this.rpcCall(getHistoryMessageBySeq, $root.kritor.message.GetHistoryMessageBySeqRequest, $root.kritor.message.GetHistoryMessageBySeqResponse, request, callback);
            }, "name", { value: "GetHistoryMessageBySeq" });

            /**
             * Calls GetHistoryMessageBySeq.
             * @function getHistoryMessageBySeq
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetHistoryMessageBySeqRequest} request GetHistoryMessageBySeqRequest message or plain object
             * @returns {Promise<kritor.message.GetHistoryMessageBySeqResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#uploadForwardMessage}.
             * @memberof kritor.message.MessageService
             * @typedef UploadForwardMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.UploadForwardMessageResponse} [response] UploadForwardMessageResponse
             */

            /**
             * Calls UploadForwardMessage.
             * @function uploadForwardMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IUploadForwardMessageRequest} request UploadForwardMessageRequest message or plain object
             * @param {kritor.message.MessageService.UploadForwardMessageCallback} callback Node-style callback called with the error, if any, and UploadForwardMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.uploadForwardMessage = function uploadForwardMessage(request, callback) {
                return this.rpcCall(uploadForwardMessage, $root.kritor.message.UploadForwardMessageRequest, $root.kritor.message.UploadForwardMessageResponse, request, callback);
            }, "name", { value: "UploadForwardMessage" });

            /**
             * Calls UploadForwardMessage.
             * @function uploadForwardMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IUploadForwardMessageRequest} request UploadForwardMessageRequest message or plain object
             * @returns {Promise<kritor.message.UploadForwardMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#downloadForwardMessage}.
             * @memberof kritor.message.MessageService
             * @typedef DownloadForwardMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.DownloadForwardMessageResponse} [response] DownloadForwardMessageResponse
             */

            /**
             * Calls DownloadForwardMessage.
             * @function downloadForwardMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IDownloadForwardMessageRequest} request DownloadForwardMessageRequest message or plain object
             * @param {kritor.message.MessageService.DownloadForwardMessageCallback} callback Node-style callback called with the error, if any, and DownloadForwardMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.downloadForwardMessage = function downloadForwardMessage(request, callback) {
                return this.rpcCall(downloadForwardMessage, $root.kritor.message.DownloadForwardMessageRequest, $root.kritor.message.DownloadForwardMessageResponse, request, callback);
            }, "name", { value: "DownloadForwardMessage" });

            /**
             * Calls DownloadForwardMessage.
             * @function downloadForwardMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IDownloadForwardMessageRequest} request DownloadForwardMessageRequest message or plain object
             * @returns {Promise<kritor.message.DownloadForwardMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#getEssenceMessageList}.
             * @memberof kritor.message.MessageService
             * @typedef GetEssenceMessageListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.GetEssenceMessageListResponse} [response] GetEssenceMessageListResponse
             */

            /**
             * Calls GetEssenceMessageList.
             * @function getEssenceMessageList
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetEssenceMessageListRequest} request GetEssenceMessageListRequest message or plain object
             * @param {kritor.message.MessageService.GetEssenceMessageListCallback} callback Node-style callback called with the error, if any, and GetEssenceMessageListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getEssenceMessageList = function getEssenceMessageList(request, callback) {
                return this.rpcCall(getEssenceMessageList, $root.kritor.message.GetEssenceMessageListRequest, $root.kritor.message.GetEssenceMessageListResponse, request, callback);
            }, "name", { value: "GetEssenceMessageList" });

            /**
             * Calls GetEssenceMessageList.
             * @function getEssenceMessageList
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetEssenceMessageListRequest} request GetEssenceMessageListRequest message or plain object
             * @returns {Promise<kritor.message.GetEssenceMessageListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#setEssenceMessage}.
             * @memberof kritor.message.MessageService
             * @typedef SetEssenceMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.SetEssenceMessageResponse} [response] SetEssenceMessageResponse
             */

            /**
             * Calls SetEssenceMessage.
             * @function setEssenceMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISetEssenceMessageRequest} request SetEssenceMessageRequest message or plain object
             * @param {kritor.message.MessageService.SetEssenceMessageCallback} callback Node-style callback called with the error, if any, and SetEssenceMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.setEssenceMessage = function setEssenceMessage(request, callback) {
                return this.rpcCall(setEssenceMessage, $root.kritor.message.SetEssenceMessageRequest, $root.kritor.message.SetEssenceMessageResponse, request, callback);
            }, "name", { value: "SetEssenceMessage" });

            /**
             * Calls SetEssenceMessage.
             * @function setEssenceMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISetEssenceMessageRequest} request SetEssenceMessageRequest message or plain object
             * @returns {Promise<kritor.message.SetEssenceMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#deleteEssenceMessage}.
             * @memberof kritor.message.MessageService
             * @typedef DeleteEssenceMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.DeleteEssenceMessageResponse} [response] DeleteEssenceMessageResponse
             */

            /**
             * Calls DeleteEssenceMessage.
             * @function deleteEssenceMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IDeleteEssenceMessageRequest} request DeleteEssenceMessageRequest message or plain object
             * @param {kritor.message.MessageService.DeleteEssenceMessageCallback} callback Node-style callback called with the error, if any, and DeleteEssenceMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.deleteEssenceMessage = function deleteEssenceMessage(request, callback) {
                return this.rpcCall(deleteEssenceMessage, $root.kritor.message.DeleteEssenceMessageRequest, $root.kritor.message.DeleteEssenceMessageResponse, request, callback);
            }, "name", { value: "DeleteEssenceMessage" });

            /**
             * Calls DeleteEssenceMessage.
             * @function deleteEssenceMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IDeleteEssenceMessageRequest} request DeleteEssenceMessageRequest message or plain object
             * @returns {Promise<kritor.message.DeleteEssenceMessageResponse>} Promise
             * @variation 2
             */

            return MessageService;
        })();

        message.SendMessageRequest = (function() {

            /**
             * Properties of a SendMessageRequest.
             * @memberof kritor.message
             * @interface ISendMessageRequest
             * @property {kritor.common.IContact|null} [contact] SendMessageRequest contact
             * @property {Array.<kritor.common.IElement>|null} [elements] SendMessageRequest elements
             * @property {number|null} [retry_count] SendMessageRequest retry_count
             * @property {string|null} [message_id] SendMessageRequest message_id
             * @property {string|null} [notice_id] SendMessageRequest notice_id
             * @property {string|null} [request_id] SendMessageRequest request_id
             */

            /**
             * Constructs a new SendMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a SendMessageRequest.
             * @implements ISendMessageRequest
             * @constructor
             * @param {kritor.message.ISendMessageRequest=} [properties] Properties to set
             */
            function SendMessageRequest(properties) {
                this.elements = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendMessageRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            SendMessageRequest.prototype.contact = null;

            /**
             * SendMessageRequest elements.
             * @member {Array.<kritor.common.IElement>} elements
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            SendMessageRequest.prototype.elements = $util.emptyArray;

            /**
             * SendMessageRequest retry_count.
             * @member {number|null|undefined} retry_count
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            SendMessageRequest.prototype.retry_count = null;

            /**
             * SendMessageRequest message_id.
             * @member {string|null|undefined} message_id
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            SendMessageRequest.prototype.message_id = null;

            /**
             * SendMessageRequest notice_id.
             * @member {string|null|undefined} notice_id
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            SendMessageRequest.prototype.notice_id = null;

            /**
             * SendMessageRequest request_id.
             * @member {string|null|undefined} request_id
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            SendMessageRequest.prototype.request_id = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SendMessageRequest _retry_count.
             * @member {"retry_count"|undefined} _retry_count
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            Object.defineProperty(SendMessageRequest.prototype, "_retry_count", {
                get: $util.oneOfGetter($oneOfFields = ["retry_count"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SendMessageRequest _message_id.
             * @member {"message_id"|undefined} _message_id
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            Object.defineProperty(SendMessageRequest.prototype, "_message_id", {
                get: $util.oneOfGetter($oneOfFields = ["message_id"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SendMessageRequest _notice_id.
             * @member {"notice_id"|undefined} _notice_id
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            Object.defineProperty(SendMessageRequest.prototype, "_notice_id", {
                get: $util.oneOfGetter($oneOfFields = ["notice_id"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SendMessageRequest _request_id.
             * @member {"request_id"|undefined} _request_id
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            Object.defineProperty(SendMessageRequest.prototype, "_request_id", {
                get: $util.oneOfGetter($oneOfFields = ["request_id"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SendMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {kritor.message.ISendMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.SendMessageRequest} SendMessageRequest instance
             */
            SendMessageRequest.create = function create(properties) {
                return new SendMessageRequest(properties);
            };

            /**
             * Encodes the specified SendMessageRequest message. Does not implicitly {@link kritor.message.SendMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {kritor.message.ISendMessageRequest} message SendMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.elements != null && message.elements.length)
                    for (let i = 0; i < message.elements.length; ++i)
                        $root.kritor.common.Element.encode(message.elements[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.retry_count != null && Object.hasOwnProperty.call(message, "retry_count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.retry_count);
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.message_id);
                if (message.notice_id != null && Object.hasOwnProperty.call(message, "notice_id"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.notice_id);
                if (message.request_id != null && Object.hasOwnProperty.call(message, "request_id"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.request_id);
                return writer;
            };

            /**
             * Encodes the specified SendMessageRequest message, length delimited. Does not implicitly {@link kritor.message.SendMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {kritor.message.ISendMessageRequest} message SendMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SendMessageRequest} SendMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SendMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (!(message.elements && message.elements.length))
                                message.elements = [];
                            message.elements.push($root.kritor.common.Element.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.retry_count = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.message_id = reader.string();
                            break;
                        }
                    case 5: {
                            message.notice_id = reader.string();
                            break;
                        }
                    case 6: {
                            message.request_id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SendMessageRequest} SendMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendMessageRequest message.
             * @function verify
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.elements != null && message.hasOwnProperty("elements")) {
                    if (!Array.isArray(message.elements))
                        return "elements: array expected";
                    for (let i = 0; i < message.elements.length; ++i) {
                        let error = $root.kritor.common.Element.verify(message.elements[i]);
                        if (error)
                            return "elements." + error;
                    }
                }
                if (message.retry_count != null && message.hasOwnProperty("retry_count")) {
                    properties._retry_count = 1;
                    if (!$util.isInteger(message.retry_count))
                        return "retry_count: integer expected";
                }
                if (message.message_id != null && message.hasOwnProperty("message_id")) {
                    properties._message_id = 1;
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                }
                if (message.notice_id != null && message.hasOwnProperty("notice_id")) {
                    properties._notice_id = 1;
                    if (!$util.isString(message.notice_id))
                        return "notice_id: string expected";
                }
                if (message.request_id != null && message.hasOwnProperty("request_id")) {
                    properties._request_id = 1;
                    if (!$util.isString(message.request_id))
                        return "request_id: string expected";
                }
                return null;
            };

            /**
             * Creates a SendMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SendMessageRequest} SendMessageRequest
             */
            SendMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SendMessageRequest)
                    return object;
                let message = new $root.kritor.message.SendMessageRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.SendMessageRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.elements) {
                    if (!Array.isArray(object.elements))
                        throw TypeError(".kritor.message.SendMessageRequest.elements: array expected");
                    message.elements = [];
                    for (let i = 0; i < object.elements.length; ++i) {
                        if (typeof object.elements[i] !== "object")
                            throw TypeError(".kritor.message.SendMessageRequest.elements: object expected");
                        message.elements[i] = $root.kritor.common.Element.fromObject(object.elements[i]);
                    }
                }
                if (object.retry_count != null)
                    message.retry_count = object.retry_count >>> 0;
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                if (object.notice_id != null)
                    message.notice_id = String(object.notice_id);
                if (object.request_id != null)
                    message.request_id = String(object.request_id);
                return message;
            };

            /**
             * Creates a plain object from a SendMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {kritor.message.SendMessageRequest} message SendMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.elements = [];
                if (options.defaults)
                    object.contact = null;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.elements && message.elements.length) {
                    object.elements = [];
                    for (let j = 0; j < message.elements.length; ++j)
                        object.elements[j] = $root.kritor.common.Element.toObject(message.elements[j], options);
                }
                if (message.retry_count != null && message.hasOwnProperty("retry_count")) {
                    object.retry_count = message.retry_count;
                    if (options.oneofs)
                        object._retry_count = "retry_count";
                }
                if (message.message_id != null && message.hasOwnProperty("message_id")) {
                    object.message_id = message.message_id;
                    if (options.oneofs)
                        object._message_id = "message_id";
                }
                if (message.notice_id != null && message.hasOwnProperty("notice_id")) {
                    object.notice_id = message.notice_id;
                    if (options.oneofs)
                        object._notice_id = "notice_id";
                }
                if (message.request_id != null && message.hasOwnProperty("request_id")) {
                    object.request_id = message.request_id;
                    if (options.oneofs)
                        object._request_id = "request_id";
                }
                return object;
            };

            /**
             * Converts this SendMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.SendMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SendMessageRequest";
            };

            return SendMessageRequest;
        })();

        message.SendMessageResponse = (function() {

            /**
             * Properties of a SendMessageResponse.
             * @memberof kritor.message
             * @interface ISendMessageResponse
             * @property {string|null} [message_id] SendMessageResponse message_id
             * @property {number|null} [message_time] SendMessageResponse message_time
             */

            /**
             * Constructs a new SendMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a SendMessageResponse.
             * @implements ISendMessageResponse
             * @constructor
             * @param {kritor.message.ISendMessageResponse=} [properties] Properties to set
             */
            function SendMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendMessageResponse message_id.
             * @member {string} message_id
             * @memberof kritor.message.SendMessageResponse
             * @instance
             */
            SendMessageResponse.prototype.message_id = "";

            /**
             * SendMessageResponse message_time.
             * @member {number} message_time
             * @memberof kritor.message.SendMessageResponse
             * @instance
             */
            SendMessageResponse.prototype.message_time = 0;

            /**
             * Creates a new SendMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {kritor.message.ISendMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.SendMessageResponse} SendMessageResponse instance
             */
            SendMessageResponse.create = function create(properties) {
                return new SendMessageResponse(properties);
            };

            /**
             * Encodes the specified SendMessageResponse message. Does not implicitly {@link kritor.message.SendMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {kritor.message.ISendMessageResponse} message SendMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.message_id);
                if (message.message_time != null && Object.hasOwnProperty.call(message, "message_time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.message_time);
                return writer;
            };

            /**
             * Encodes the specified SendMessageResponse message, length delimited. Does not implicitly {@link kritor.message.SendMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {kritor.message.ISendMessageResponse} message SendMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SendMessageResponse} SendMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SendMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.message_id = reader.string();
                            break;
                        }
                    case 2: {
                            message.message_time = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SendMessageResponse} SendMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendMessageResponse message.
             * @function verify
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                if (message.message_time != null && message.hasOwnProperty("message_time"))
                    if (!$util.isInteger(message.message_time))
                        return "message_time: integer expected";
                return null;
            };

            /**
             * Creates a SendMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SendMessageResponse} SendMessageResponse
             */
            SendMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SendMessageResponse)
                    return object;
                let message = new $root.kritor.message.SendMessageResponse();
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                if (object.message_time != null)
                    message.message_time = object.message_time >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SendMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {kritor.message.SendMessageResponse} message SendMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.message_id = "";
                    object.message_time = 0;
                }
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    object.message_id = message.message_id;
                if (message.message_time != null && message.hasOwnProperty("message_time"))
                    object.message_time = message.message_time;
                return object;
            };

            /**
             * Converts this SendMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.SendMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SendMessageResponse";
            };

            return SendMessageResponse;
        })();

        message.SendMessageByResIdRequest = (function() {

            /**
             * Properties of a SendMessageByResIdRequest.
             * @memberof kritor.message
             * @interface ISendMessageByResIdRequest
             * @property {kritor.common.IContact|null} [contact] SendMessageByResIdRequest contact
             * @property {string|null} [res_id] SendMessageByResIdRequest res_id
             * @property {number|null} [retry_count] SendMessageByResIdRequest retry_count
             */

            /**
             * Constructs a new SendMessageByResIdRequest.
             * @memberof kritor.message
             * @classdesc Represents a SendMessageByResIdRequest.
             * @implements ISendMessageByResIdRequest
             * @constructor
             * @param {kritor.message.ISendMessageByResIdRequest=} [properties] Properties to set
             */
            function SendMessageByResIdRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendMessageByResIdRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.SendMessageByResIdRequest
             * @instance
             */
            SendMessageByResIdRequest.prototype.contact = null;

            /**
             * SendMessageByResIdRequest res_id.
             * @member {string} res_id
             * @memberof kritor.message.SendMessageByResIdRequest
             * @instance
             */
            SendMessageByResIdRequest.prototype.res_id = "";

            /**
             * SendMessageByResIdRequest retry_count.
             * @member {number|null|undefined} retry_count
             * @memberof kritor.message.SendMessageByResIdRequest
             * @instance
             */
            SendMessageByResIdRequest.prototype.retry_count = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SendMessageByResIdRequest _retry_count.
             * @member {"retry_count"|undefined} _retry_count
             * @memberof kritor.message.SendMessageByResIdRequest
             * @instance
             */
            Object.defineProperty(SendMessageByResIdRequest.prototype, "_retry_count", {
                get: $util.oneOfGetter($oneOfFields = ["retry_count"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SendMessageByResIdRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {kritor.message.ISendMessageByResIdRequest=} [properties] Properties to set
             * @returns {kritor.message.SendMessageByResIdRequest} SendMessageByResIdRequest instance
             */
            SendMessageByResIdRequest.create = function create(properties) {
                return new SendMessageByResIdRequest(properties);
            };

            /**
             * Encodes the specified SendMessageByResIdRequest message. Does not implicitly {@link kritor.message.SendMessageByResIdRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {kritor.message.ISendMessageByResIdRequest} message SendMessageByResIdRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageByResIdRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.res_id != null && Object.hasOwnProperty.call(message, "res_id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.res_id);
                if (message.retry_count != null && Object.hasOwnProperty.call(message, "retry_count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.retry_count);
                return writer;
            };

            /**
             * Encodes the specified SendMessageByResIdRequest message, length delimited. Does not implicitly {@link kritor.message.SendMessageByResIdRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {kritor.message.ISendMessageByResIdRequest} message SendMessageByResIdRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageByResIdRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendMessageByResIdRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SendMessageByResIdRequest} SendMessageByResIdRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageByResIdRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SendMessageByResIdRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.res_id = reader.string();
                            break;
                        }
                    case 3: {
                            message.retry_count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendMessageByResIdRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SendMessageByResIdRequest} SendMessageByResIdRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageByResIdRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendMessageByResIdRequest message.
             * @function verify
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendMessageByResIdRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.res_id != null && message.hasOwnProperty("res_id"))
                    if (!$util.isString(message.res_id))
                        return "res_id: string expected";
                if (message.retry_count != null && message.hasOwnProperty("retry_count")) {
                    properties._retry_count = 1;
                    if (!$util.isInteger(message.retry_count))
                        return "retry_count: integer expected";
                }
                return null;
            };

            /**
             * Creates a SendMessageByResIdRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SendMessageByResIdRequest} SendMessageByResIdRequest
             */
            SendMessageByResIdRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SendMessageByResIdRequest)
                    return object;
                let message = new $root.kritor.message.SendMessageByResIdRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.SendMessageByResIdRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.res_id != null)
                    message.res_id = String(object.res_id);
                if (object.retry_count != null)
                    message.retry_count = object.retry_count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SendMessageByResIdRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {kritor.message.SendMessageByResIdRequest} message SendMessageByResIdRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendMessageByResIdRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contact = null;
                    object.res_id = "";
                }
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.res_id != null && message.hasOwnProperty("res_id"))
                    object.res_id = message.res_id;
                if (message.retry_count != null && message.hasOwnProperty("retry_count")) {
                    object.retry_count = message.retry_count;
                    if (options.oneofs)
                        object._retry_count = "retry_count";
                }
                return object;
            };

            /**
             * Converts this SendMessageByResIdRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.SendMessageByResIdRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendMessageByResIdRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendMessageByResIdRequest
             * @function getTypeUrl
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendMessageByResIdRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SendMessageByResIdRequest";
            };

            return SendMessageByResIdRequest;
        })();

        message.SendMessageByResIdResponse = (function() {

            /**
             * Properties of a SendMessageByResIdResponse.
             * @memberof kritor.message
             * @interface ISendMessageByResIdResponse
             * @property {string|null} [message_id] SendMessageByResIdResponse message_id
             * @property {number|null} [message_time] SendMessageByResIdResponse message_time
             */

            /**
             * Constructs a new SendMessageByResIdResponse.
             * @memberof kritor.message
             * @classdesc Represents a SendMessageByResIdResponse.
             * @implements ISendMessageByResIdResponse
             * @constructor
             * @param {kritor.message.ISendMessageByResIdResponse=} [properties] Properties to set
             */
            function SendMessageByResIdResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendMessageByResIdResponse message_id.
             * @member {string} message_id
             * @memberof kritor.message.SendMessageByResIdResponse
             * @instance
             */
            SendMessageByResIdResponse.prototype.message_id = "";

            /**
             * SendMessageByResIdResponse message_time.
             * @member {number} message_time
             * @memberof kritor.message.SendMessageByResIdResponse
             * @instance
             */
            SendMessageByResIdResponse.prototype.message_time = 0;

            /**
             * Creates a new SendMessageByResIdResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {kritor.message.ISendMessageByResIdResponse=} [properties] Properties to set
             * @returns {kritor.message.SendMessageByResIdResponse} SendMessageByResIdResponse instance
             */
            SendMessageByResIdResponse.create = function create(properties) {
                return new SendMessageByResIdResponse(properties);
            };

            /**
             * Encodes the specified SendMessageByResIdResponse message. Does not implicitly {@link kritor.message.SendMessageByResIdResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {kritor.message.ISendMessageByResIdResponse} message SendMessageByResIdResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageByResIdResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.message_id);
                if (message.message_time != null && Object.hasOwnProperty.call(message, "message_time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.message_time);
                return writer;
            };

            /**
             * Encodes the specified SendMessageByResIdResponse message, length delimited. Does not implicitly {@link kritor.message.SendMessageByResIdResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {kritor.message.ISendMessageByResIdResponse} message SendMessageByResIdResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageByResIdResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendMessageByResIdResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SendMessageByResIdResponse} SendMessageByResIdResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageByResIdResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SendMessageByResIdResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.message_id = reader.string();
                            break;
                        }
                    case 2: {
                            message.message_time = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendMessageByResIdResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SendMessageByResIdResponse} SendMessageByResIdResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageByResIdResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendMessageByResIdResponse message.
             * @function verify
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendMessageByResIdResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                if (message.message_time != null && message.hasOwnProperty("message_time"))
                    if (!$util.isInteger(message.message_time))
                        return "message_time: integer expected";
                return null;
            };

            /**
             * Creates a SendMessageByResIdResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SendMessageByResIdResponse} SendMessageByResIdResponse
             */
            SendMessageByResIdResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SendMessageByResIdResponse)
                    return object;
                let message = new $root.kritor.message.SendMessageByResIdResponse();
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                if (object.message_time != null)
                    message.message_time = object.message_time >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SendMessageByResIdResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {kritor.message.SendMessageByResIdResponse} message SendMessageByResIdResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendMessageByResIdResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.message_id = "";
                    object.message_time = 0;
                }
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    object.message_id = message.message_id;
                if (message.message_time != null && message.hasOwnProperty("message_time"))
                    object.message_time = message.message_time;
                return object;
            };

            /**
             * Converts this SendMessageByResIdResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.SendMessageByResIdResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendMessageByResIdResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendMessageByResIdResponse
             * @function getTypeUrl
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendMessageByResIdResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SendMessageByResIdResponse";
            };

            return SendMessageByResIdResponse;
        })();

        message.SetMessageReadRequest = (function() {

            /**
             * Properties of a SetMessageReadRequest.
             * @memberof kritor.message
             * @interface ISetMessageReadRequest
             * @property {kritor.common.IContact|null} [contact] SetMessageReadRequest contact
             */

            /**
             * Constructs a new SetMessageReadRequest.
             * @memberof kritor.message
             * @classdesc Represents a SetMessageReadRequest.
             * @implements ISetMessageReadRequest
             * @constructor
             * @param {kritor.message.ISetMessageReadRequest=} [properties] Properties to set
             */
            function SetMessageReadRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetMessageReadRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.SetMessageReadRequest
             * @instance
             */
            SetMessageReadRequest.prototype.contact = null;

            /**
             * Creates a new SetMessageReadRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {kritor.message.ISetMessageReadRequest=} [properties] Properties to set
             * @returns {kritor.message.SetMessageReadRequest} SetMessageReadRequest instance
             */
            SetMessageReadRequest.create = function create(properties) {
                return new SetMessageReadRequest(properties);
            };

            /**
             * Encodes the specified SetMessageReadRequest message. Does not implicitly {@link kritor.message.SetMessageReadRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {kritor.message.ISetMessageReadRequest} message SetMessageReadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetMessageReadRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SetMessageReadRequest message, length delimited. Does not implicitly {@link kritor.message.SetMessageReadRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {kritor.message.ISetMessageReadRequest} message SetMessageReadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetMessageReadRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetMessageReadRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SetMessageReadRequest} SetMessageReadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetMessageReadRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SetMessageReadRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetMessageReadRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SetMessageReadRequest} SetMessageReadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetMessageReadRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetMessageReadRequest message.
             * @function verify
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetMessageReadRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                return null;
            };

            /**
             * Creates a SetMessageReadRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SetMessageReadRequest} SetMessageReadRequest
             */
            SetMessageReadRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SetMessageReadRequest)
                    return object;
                let message = new $root.kritor.message.SetMessageReadRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.SetMessageReadRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                return message;
            };

            /**
             * Creates a plain object from a SetMessageReadRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {kritor.message.SetMessageReadRequest} message SetMessageReadRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetMessageReadRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.contact = null;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                return object;
            };

            /**
             * Converts this SetMessageReadRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.SetMessageReadRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetMessageReadRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetMessageReadRequest
             * @function getTypeUrl
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetMessageReadRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SetMessageReadRequest";
            };

            return SetMessageReadRequest;
        })();

        message.SetMessageReadResponse = (function() {

            /**
             * Properties of a SetMessageReadResponse.
             * @memberof kritor.message
             * @interface ISetMessageReadResponse
             */

            /**
             * Constructs a new SetMessageReadResponse.
             * @memberof kritor.message
             * @classdesc Represents a SetMessageReadResponse.
             * @implements ISetMessageReadResponse
             * @constructor
             * @param {kritor.message.ISetMessageReadResponse=} [properties] Properties to set
             */
            function SetMessageReadResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetMessageReadResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {kritor.message.ISetMessageReadResponse=} [properties] Properties to set
             * @returns {kritor.message.SetMessageReadResponse} SetMessageReadResponse instance
             */
            SetMessageReadResponse.create = function create(properties) {
                return new SetMessageReadResponse(properties);
            };

            /**
             * Encodes the specified SetMessageReadResponse message. Does not implicitly {@link kritor.message.SetMessageReadResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {kritor.message.ISetMessageReadResponse} message SetMessageReadResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetMessageReadResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetMessageReadResponse message, length delimited. Does not implicitly {@link kritor.message.SetMessageReadResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {kritor.message.ISetMessageReadResponse} message SetMessageReadResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetMessageReadResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetMessageReadResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SetMessageReadResponse} SetMessageReadResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetMessageReadResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SetMessageReadResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetMessageReadResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SetMessageReadResponse} SetMessageReadResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetMessageReadResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetMessageReadResponse message.
             * @function verify
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetMessageReadResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetMessageReadResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SetMessageReadResponse} SetMessageReadResponse
             */
            SetMessageReadResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SetMessageReadResponse)
                    return object;
                return new $root.kritor.message.SetMessageReadResponse();
            };

            /**
             * Creates a plain object from a SetMessageReadResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {kritor.message.SetMessageReadResponse} message SetMessageReadResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetMessageReadResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetMessageReadResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.SetMessageReadResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetMessageReadResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetMessageReadResponse
             * @function getTypeUrl
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetMessageReadResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SetMessageReadResponse";
            };

            return SetMessageReadResponse;
        })();

        message.RecallMessageRequest = (function() {

            /**
             * Properties of a RecallMessageRequest.
             * @memberof kritor.message
             * @interface IRecallMessageRequest
             * @property {kritor.common.IContact|null} [contact] RecallMessageRequest contact
             * @property {string|null} [message_id] RecallMessageRequest message_id
             */

            /**
             * Constructs a new RecallMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a RecallMessageRequest.
             * @implements IRecallMessageRequest
             * @constructor
             * @param {kritor.message.IRecallMessageRequest=} [properties] Properties to set
             */
            function RecallMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RecallMessageRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.RecallMessageRequest
             * @instance
             */
            RecallMessageRequest.prototype.contact = null;

            /**
             * RecallMessageRequest message_id.
             * @member {string} message_id
             * @memberof kritor.message.RecallMessageRequest
             * @instance
             */
            RecallMessageRequest.prototype.message_id = "";

            /**
             * Creates a new RecallMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {kritor.message.IRecallMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.RecallMessageRequest} RecallMessageRequest instance
             */
            RecallMessageRequest.create = function create(properties) {
                return new RecallMessageRequest(properties);
            };

            /**
             * Encodes the specified RecallMessageRequest message. Does not implicitly {@link kritor.message.RecallMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {kritor.message.IRecallMessageRequest} message RecallMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecallMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message_id);
                return writer;
            };

            /**
             * Encodes the specified RecallMessageRequest message, length delimited. Does not implicitly {@link kritor.message.RecallMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {kritor.message.IRecallMessageRequest} message RecallMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecallMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RecallMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.RecallMessageRequest} RecallMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecallMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.RecallMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.message_id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RecallMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.RecallMessageRequest} RecallMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecallMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RecallMessageRequest message.
             * @function verify
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RecallMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                return null;
            };

            /**
             * Creates a RecallMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.RecallMessageRequest} RecallMessageRequest
             */
            RecallMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.RecallMessageRequest)
                    return object;
                let message = new $root.kritor.message.RecallMessageRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.RecallMessageRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                return message;
            };

            /**
             * Creates a plain object from a RecallMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {kritor.message.RecallMessageRequest} message RecallMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RecallMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contact = null;
                    object.message_id = "";
                }
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    object.message_id = message.message_id;
                return object;
            };

            /**
             * Converts this RecallMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.RecallMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RecallMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RecallMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RecallMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.RecallMessageRequest";
            };

            return RecallMessageRequest;
        })();

        message.RecallMessageResponse = (function() {

            /**
             * Properties of a RecallMessageResponse.
             * @memberof kritor.message
             * @interface IRecallMessageResponse
             */

            /**
             * Constructs a new RecallMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a RecallMessageResponse.
             * @implements IRecallMessageResponse
             * @constructor
             * @param {kritor.message.IRecallMessageResponse=} [properties] Properties to set
             */
            function RecallMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new RecallMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {kritor.message.IRecallMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.RecallMessageResponse} RecallMessageResponse instance
             */
            RecallMessageResponse.create = function create(properties) {
                return new RecallMessageResponse(properties);
            };

            /**
             * Encodes the specified RecallMessageResponse message. Does not implicitly {@link kritor.message.RecallMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {kritor.message.IRecallMessageResponse} message RecallMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecallMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified RecallMessageResponse message, length delimited. Does not implicitly {@link kritor.message.RecallMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {kritor.message.IRecallMessageResponse} message RecallMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecallMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RecallMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.RecallMessageResponse} RecallMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecallMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.RecallMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RecallMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.RecallMessageResponse} RecallMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecallMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RecallMessageResponse message.
             * @function verify
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RecallMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a RecallMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.RecallMessageResponse} RecallMessageResponse
             */
            RecallMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.RecallMessageResponse)
                    return object;
                return new $root.kritor.message.RecallMessageResponse();
            };

            /**
             * Creates a plain object from a RecallMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {kritor.message.RecallMessageResponse} message RecallMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RecallMessageResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this RecallMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.RecallMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RecallMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RecallMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RecallMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.RecallMessageResponse";
            };

            return RecallMessageResponse;
        })();

        message.ReactMessageWithEmojiRequest = (function() {

            /**
             * Properties of a ReactMessageWithEmojiRequest.
             * @memberof kritor.message
             * @interface IReactMessageWithEmojiRequest
             * @property {kritor.common.IContact|null} [contact] ReactMessageWithEmojiRequest contact
             * @property {string|null} [message_id] ReactMessageWithEmojiRequest message_id
             * @property {number|null} [face_id] ReactMessageWithEmojiRequest face_id
             * @property {boolean|null} [is_set] ReactMessageWithEmojiRequest is_set
             */

            /**
             * Constructs a new ReactMessageWithEmojiRequest.
             * @memberof kritor.message
             * @classdesc Represents a ReactMessageWithEmojiRequest.
             * @implements IReactMessageWithEmojiRequest
             * @constructor
             * @param {kritor.message.IReactMessageWithEmojiRequest=} [properties] Properties to set
             */
            function ReactMessageWithEmojiRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReactMessageWithEmojiRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @instance
             */
            ReactMessageWithEmojiRequest.prototype.contact = null;

            /**
             * ReactMessageWithEmojiRequest message_id.
             * @member {string} message_id
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @instance
             */
            ReactMessageWithEmojiRequest.prototype.message_id = "";

            /**
             * ReactMessageWithEmojiRequest face_id.
             * @member {number} face_id
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @instance
             */
            ReactMessageWithEmojiRequest.prototype.face_id = 0;

            /**
             * ReactMessageWithEmojiRequest is_set.
             * @member {boolean} is_set
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @instance
             */
            ReactMessageWithEmojiRequest.prototype.is_set = false;

            /**
             * Creates a new ReactMessageWithEmojiRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {kritor.message.IReactMessageWithEmojiRequest=} [properties] Properties to set
             * @returns {kritor.message.ReactMessageWithEmojiRequest} ReactMessageWithEmojiRequest instance
             */
            ReactMessageWithEmojiRequest.create = function create(properties) {
                return new ReactMessageWithEmojiRequest(properties);
            };

            /**
             * Encodes the specified ReactMessageWithEmojiRequest message. Does not implicitly {@link kritor.message.ReactMessageWithEmojiRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {kritor.message.IReactMessageWithEmojiRequest} message ReactMessageWithEmojiRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReactMessageWithEmojiRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message_id);
                if (message.face_id != null && Object.hasOwnProperty.call(message, "face_id"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.face_id);
                if (message.is_set != null && Object.hasOwnProperty.call(message, "is_set"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_set);
                return writer;
            };

            /**
             * Encodes the specified ReactMessageWithEmojiRequest message, length delimited. Does not implicitly {@link kritor.message.ReactMessageWithEmojiRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {kritor.message.IReactMessageWithEmojiRequest} message ReactMessageWithEmojiRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReactMessageWithEmojiRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReactMessageWithEmojiRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ReactMessageWithEmojiRequest} ReactMessageWithEmojiRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReactMessageWithEmojiRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ReactMessageWithEmojiRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.message_id = reader.string();
                            break;
                        }
                    case 3: {
                            message.face_id = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.is_set = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReactMessageWithEmojiRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ReactMessageWithEmojiRequest} ReactMessageWithEmojiRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReactMessageWithEmojiRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReactMessageWithEmojiRequest message.
             * @function verify
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReactMessageWithEmojiRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                if (message.face_id != null && message.hasOwnProperty("face_id"))
                    if (!$util.isInteger(message.face_id))
                        return "face_id: integer expected";
                if (message.is_set != null && message.hasOwnProperty("is_set"))
                    if (typeof message.is_set !== "boolean")
                        return "is_set: boolean expected";
                return null;
            };

            /**
             * Creates a ReactMessageWithEmojiRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ReactMessageWithEmojiRequest} ReactMessageWithEmojiRequest
             */
            ReactMessageWithEmojiRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ReactMessageWithEmojiRequest)
                    return object;
                let message = new $root.kritor.message.ReactMessageWithEmojiRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.ReactMessageWithEmojiRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                if (object.face_id != null)
                    message.face_id = object.face_id >>> 0;
                if (object.is_set != null)
                    message.is_set = Boolean(object.is_set);
                return message;
            };

            /**
             * Creates a plain object from a ReactMessageWithEmojiRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {kritor.message.ReactMessageWithEmojiRequest} message ReactMessageWithEmojiRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReactMessageWithEmojiRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contact = null;
                    object.message_id = "";
                    object.face_id = 0;
                    object.is_set = false;
                }
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    object.message_id = message.message_id;
                if (message.face_id != null && message.hasOwnProperty("face_id"))
                    object.face_id = message.face_id;
                if (message.is_set != null && message.hasOwnProperty("is_set"))
                    object.is_set = message.is_set;
                return object;
            };

            /**
             * Converts this ReactMessageWithEmojiRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReactMessageWithEmojiRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReactMessageWithEmojiRequest
             * @function getTypeUrl
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReactMessageWithEmojiRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ReactMessageWithEmojiRequest";
            };

            return ReactMessageWithEmojiRequest;
        })();

        message.ReactMessageWithEmojiResponse = (function() {

            /**
             * Properties of a ReactMessageWithEmojiResponse.
             * @memberof kritor.message
             * @interface IReactMessageWithEmojiResponse
             */

            /**
             * Constructs a new ReactMessageWithEmojiResponse.
             * @memberof kritor.message
             * @classdesc Represents a ReactMessageWithEmojiResponse.
             * @implements IReactMessageWithEmojiResponse
             * @constructor
             * @param {kritor.message.IReactMessageWithEmojiResponse=} [properties] Properties to set
             */
            function ReactMessageWithEmojiResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ReactMessageWithEmojiResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {kritor.message.IReactMessageWithEmojiResponse=} [properties] Properties to set
             * @returns {kritor.message.ReactMessageWithEmojiResponse} ReactMessageWithEmojiResponse instance
             */
            ReactMessageWithEmojiResponse.create = function create(properties) {
                return new ReactMessageWithEmojiResponse(properties);
            };

            /**
             * Encodes the specified ReactMessageWithEmojiResponse message. Does not implicitly {@link kritor.message.ReactMessageWithEmojiResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {kritor.message.IReactMessageWithEmojiResponse} message ReactMessageWithEmojiResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReactMessageWithEmojiResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ReactMessageWithEmojiResponse message, length delimited. Does not implicitly {@link kritor.message.ReactMessageWithEmojiResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {kritor.message.IReactMessageWithEmojiResponse} message ReactMessageWithEmojiResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReactMessageWithEmojiResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReactMessageWithEmojiResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ReactMessageWithEmojiResponse} ReactMessageWithEmojiResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReactMessageWithEmojiResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ReactMessageWithEmojiResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReactMessageWithEmojiResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ReactMessageWithEmojiResponse} ReactMessageWithEmojiResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReactMessageWithEmojiResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReactMessageWithEmojiResponse message.
             * @function verify
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReactMessageWithEmojiResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ReactMessageWithEmojiResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ReactMessageWithEmojiResponse} ReactMessageWithEmojiResponse
             */
            ReactMessageWithEmojiResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ReactMessageWithEmojiResponse)
                    return object;
                return new $root.kritor.message.ReactMessageWithEmojiResponse();
            };

            /**
             * Creates a plain object from a ReactMessageWithEmojiResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {kritor.message.ReactMessageWithEmojiResponse} message ReactMessageWithEmojiResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReactMessageWithEmojiResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ReactMessageWithEmojiResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReactMessageWithEmojiResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReactMessageWithEmojiResponse
             * @function getTypeUrl
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReactMessageWithEmojiResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ReactMessageWithEmojiResponse";
            };

            return ReactMessageWithEmojiResponse;
        })();

        message.GetMessageRequest = (function() {

            /**
             * Properties of a GetMessageRequest.
             * @memberof kritor.message
             * @interface IGetMessageRequest
             * @property {kritor.common.IContact|null} [contact] GetMessageRequest contact
             * @property {string|null} [message_id] GetMessageRequest message_id
             */

            /**
             * Constructs a new GetMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a GetMessageRequest.
             * @implements IGetMessageRequest
             * @constructor
             * @param {kritor.message.IGetMessageRequest=} [properties] Properties to set
             */
            function GetMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMessageRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.GetMessageRequest
             * @instance
             */
            GetMessageRequest.prototype.contact = null;

            /**
             * GetMessageRequest message_id.
             * @member {string} message_id
             * @memberof kritor.message.GetMessageRequest
             * @instance
             */
            GetMessageRequest.prototype.message_id = "";

            /**
             * Creates a new GetMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {kritor.message.IGetMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.GetMessageRequest} GetMessageRequest instance
             */
            GetMessageRequest.create = function create(properties) {
                return new GetMessageRequest(properties);
            };

            /**
             * Encodes the specified GetMessageRequest message. Does not implicitly {@link kritor.message.GetMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {kritor.message.IGetMessageRequest} message GetMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message_id);
                return writer;
            };

            /**
             * Encodes the specified GetMessageRequest message, length delimited. Does not implicitly {@link kritor.message.GetMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {kritor.message.IGetMessageRequest} message GetMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetMessageRequest} GetMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.message_id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetMessageRequest} GetMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMessageRequest message.
             * @function verify
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                return null;
            };

            /**
             * Creates a GetMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetMessageRequest} GetMessageRequest
             */
            GetMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetMessageRequest)
                    return object;
                let message = new $root.kritor.message.GetMessageRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.GetMessageRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                return message;
            };

            /**
             * Creates a plain object from a GetMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {kritor.message.GetMessageRequest} message GetMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contact = null;
                    object.message_id = "";
                }
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    object.message_id = message.message_id;
                return object;
            };

            /**
             * Converts this GetMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.GetMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetMessageRequest";
            };

            return GetMessageRequest;
        })();

        message.GetMessageResponse = (function() {

            /**
             * Properties of a GetMessageResponse.
             * @memberof kritor.message
             * @interface IGetMessageResponse
             * @property {kritor.common.IPushMessageBody|null} [message] GetMessageResponse message
             */

            /**
             * Constructs a new GetMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a GetMessageResponse.
             * @implements IGetMessageResponse
             * @constructor
             * @param {kritor.message.IGetMessageResponse=} [properties] Properties to set
             */
            function GetMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMessageResponse message.
             * @member {kritor.common.IPushMessageBody|null|undefined} message
             * @memberof kritor.message.GetMessageResponse
             * @instance
             */
            GetMessageResponse.prototype.message = null;

            /**
             * Creates a new GetMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {kritor.message.IGetMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.GetMessageResponse} GetMessageResponse instance
             */
            GetMessageResponse.create = function create(properties) {
                return new GetMessageResponse(properties);
            };

            /**
             * Encodes the specified GetMessageResponse message. Does not implicitly {@link kritor.message.GetMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {kritor.message.IGetMessageResponse} message GetMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.kritor.common.PushMessageBody.encode(message.message, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetMessageResponse message, length delimited. Does not implicitly {@link kritor.message.GetMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {kritor.message.IGetMessageResponse} message GetMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetMessageResponse} GetMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.message = $root.kritor.common.PushMessageBody.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetMessageResponse} GetMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMessageResponse message.
             * @function verify
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message != null && message.hasOwnProperty("message")) {
                    let error = $root.kritor.common.PushMessageBody.verify(message.message);
                    if (error)
                        return "message." + error;
                }
                return null;
            };

            /**
             * Creates a GetMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetMessageResponse} GetMessageResponse
             */
            GetMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetMessageResponse)
                    return object;
                let message = new $root.kritor.message.GetMessageResponse();
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".kritor.message.GetMessageResponse.message: object expected");
                    message.message = $root.kritor.common.PushMessageBody.fromObject(object.message);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {kritor.message.GetMessageResponse} message GetMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.message = null;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = $root.kritor.common.PushMessageBody.toObject(message.message, options);
                return object;
            };

            /**
             * Converts this GetMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.GetMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetMessageResponse";
            };

            return GetMessageResponse;
        })();

        message.GetMessageBySeqRequest = (function() {

            /**
             * Properties of a GetMessageBySeqRequest.
             * @memberof kritor.message
             * @interface IGetMessageBySeqRequest
             * @property {kritor.common.IContact|null} [contact] GetMessageBySeqRequest contact
             * @property {number|Long|null} [message_seq] GetMessageBySeqRequest message_seq
             */

            /**
             * Constructs a new GetMessageBySeqRequest.
             * @memberof kritor.message
             * @classdesc Represents a GetMessageBySeqRequest.
             * @implements IGetMessageBySeqRequest
             * @constructor
             * @param {kritor.message.IGetMessageBySeqRequest=} [properties] Properties to set
             */
            function GetMessageBySeqRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMessageBySeqRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.GetMessageBySeqRequest
             * @instance
             */
            GetMessageBySeqRequest.prototype.contact = null;

            /**
             * GetMessageBySeqRequest message_seq.
             * @member {number|Long} message_seq
             * @memberof kritor.message.GetMessageBySeqRequest
             * @instance
             */
            GetMessageBySeqRequest.prototype.message_seq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetMessageBySeqRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {kritor.message.IGetMessageBySeqRequest=} [properties] Properties to set
             * @returns {kritor.message.GetMessageBySeqRequest} GetMessageBySeqRequest instance
             */
            GetMessageBySeqRequest.create = function create(properties) {
                return new GetMessageBySeqRequest(properties);
            };

            /**
             * Encodes the specified GetMessageBySeqRequest message. Does not implicitly {@link kritor.message.GetMessageBySeqRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {kritor.message.IGetMessageBySeqRequest} message GetMessageBySeqRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageBySeqRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.message_seq != null && Object.hasOwnProperty.call(message, "message_seq"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.message_seq);
                return writer;
            };

            /**
             * Encodes the specified GetMessageBySeqRequest message, length delimited. Does not implicitly {@link kritor.message.GetMessageBySeqRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {kritor.message.IGetMessageBySeqRequest} message GetMessageBySeqRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageBySeqRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMessageBySeqRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetMessageBySeqRequest} GetMessageBySeqRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageBySeqRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetMessageBySeqRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.message_seq = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMessageBySeqRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetMessageBySeqRequest} GetMessageBySeqRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageBySeqRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMessageBySeqRequest message.
             * @function verify
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMessageBySeqRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.message_seq != null && message.hasOwnProperty("message_seq"))
                    if (!$util.isInteger(message.message_seq) && !(message.message_seq && $util.isInteger(message.message_seq.low) && $util.isInteger(message.message_seq.high)))
                        return "message_seq: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetMessageBySeqRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetMessageBySeqRequest} GetMessageBySeqRequest
             */
            GetMessageBySeqRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetMessageBySeqRequest)
                    return object;
                let message = new $root.kritor.message.GetMessageBySeqRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.GetMessageBySeqRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.message_seq != null)
                    if ($util.Long)
                        (message.message_seq = $util.Long.fromValue(object.message_seq)).unsigned = true;
                    else if (typeof object.message_seq === "string")
                        message.message_seq = parseInt(object.message_seq, 10);
                    else if (typeof object.message_seq === "number")
                        message.message_seq = object.message_seq;
                    else if (typeof object.message_seq === "object")
                        message.message_seq = new $util.LongBits(object.message_seq.low >>> 0, object.message_seq.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetMessageBySeqRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {kritor.message.GetMessageBySeqRequest} message GetMessageBySeqRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMessageBySeqRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contact = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.message_seq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.message_seq = options.longs === String ? "0" : 0;
                }
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.message_seq != null && message.hasOwnProperty("message_seq"))
                    if (typeof message.message_seq === "number")
                        object.message_seq = options.longs === String ? String(message.message_seq) : message.message_seq;
                    else
                        object.message_seq = options.longs === String ? $util.Long.prototype.toString.call(message.message_seq) : options.longs === Number ? new $util.LongBits(message.message_seq.low >>> 0, message.message_seq.high >>> 0).toNumber(true) : message.message_seq;
                return object;
            };

            /**
             * Converts this GetMessageBySeqRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.GetMessageBySeqRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMessageBySeqRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMessageBySeqRequest
             * @function getTypeUrl
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMessageBySeqRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetMessageBySeqRequest";
            };

            return GetMessageBySeqRequest;
        })();

        message.GetMessageBySeqResponse = (function() {

            /**
             * Properties of a GetMessageBySeqResponse.
             * @memberof kritor.message
             * @interface IGetMessageBySeqResponse
             * @property {kritor.common.IPushMessageBody|null} [message] GetMessageBySeqResponse message
             */

            /**
             * Constructs a new GetMessageBySeqResponse.
             * @memberof kritor.message
             * @classdesc Represents a GetMessageBySeqResponse.
             * @implements IGetMessageBySeqResponse
             * @constructor
             * @param {kritor.message.IGetMessageBySeqResponse=} [properties] Properties to set
             */
            function GetMessageBySeqResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMessageBySeqResponse message.
             * @member {kritor.common.IPushMessageBody|null|undefined} message
             * @memberof kritor.message.GetMessageBySeqResponse
             * @instance
             */
            GetMessageBySeqResponse.prototype.message = null;

            /**
             * Creates a new GetMessageBySeqResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {kritor.message.IGetMessageBySeqResponse=} [properties] Properties to set
             * @returns {kritor.message.GetMessageBySeqResponse} GetMessageBySeqResponse instance
             */
            GetMessageBySeqResponse.create = function create(properties) {
                return new GetMessageBySeqResponse(properties);
            };

            /**
             * Encodes the specified GetMessageBySeqResponse message. Does not implicitly {@link kritor.message.GetMessageBySeqResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {kritor.message.IGetMessageBySeqResponse} message GetMessageBySeqResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageBySeqResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.kritor.common.PushMessageBody.encode(message.message, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetMessageBySeqResponse message, length delimited. Does not implicitly {@link kritor.message.GetMessageBySeqResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {kritor.message.IGetMessageBySeqResponse} message GetMessageBySeqResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageBySeqResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMessageBySeqResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetMessageBySeqResponse} GetMessageBySeqResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageBySeqResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetMessageBySeqResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.message = $root.kritor.common.PushMessageBody.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMessageBySeqResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetMessageBySeqResponse} GetMessageBySeqResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageBySeqResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMessageBySeqResponse message.
             * @function verify
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMessageBySeqResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message != null && message.hasOwnProperty("message")) {
                    let error = $root.kritor.common.PushMessageBody.verify(message.message);
                    if (error)
                        return "message." + error;
                }
                return null;
            };

            /**
             * Creates a GetMessageBySeqResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetMessageBySeqResponse} GetMessageBySeqResponse
             */
            GetMessageBySeqResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetMessageBySeqResponse)
                    return object;
                let message = new $root.kritor.message.GetMessageBySeqResponse();
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".kritor.message.GetMessageBySeqResponse.message: object expected");
                    message.message = $root.kritor.common.PushMessageBody.fromObject(object.message);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetMessageBySeqResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {kritor.message.GetMessageBySeqResponse} message GetMessageBySeqResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMessageBySeqResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.message = null;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = $root.kritor.common.PushMessageBody.toObject(message.message, options);
                return object;
            };

            /**
             * Converts this GetMessageBySeqResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.GetMessageBySeqResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMessageBySeqResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMessageBySeqResponse
             * @function getTypeUrl
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMessageBySeqResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetMessageBySeqResponse";
            };

            return GetMessageBySeqResponse;
        })();

        message.GetHistoryMessageRequest = (function() {

            /**
             * Properties of a GetHistoryMessageRequest.
             * @memberof kritor.message
             * @interface IGetHistoryMessageRequest
             * @property {kritor.common.IContact|null} [contact] GetHistoryMessageRequest contact
             * @property {string|null} [start_message_id] GetHistoryMessageRequest start_message_id
             * @property {number|null} [count] GetHistoryMessageRequest count
             */

            /**
             * Constructs a new GetHistoryMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a GetHistoryMessageRequest.
             * @implements IGetHistoryMessageRequest
             * @constructor
             * @param {kritor.message.IGetHistoryMessageRequest=} [properties] Properties to set
             */
            function GetHistoryMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHistoryMessageRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             */
            GetHistoryMessageRequest.prototype.contact = null;

            /**
             * GetHistoryMessageRequest start_message_id.
             * @member {string|null|undefined} start_message_id
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             */
            GetHistoryMessageRequest.prototype.start_message_id = null;

            /**
             * GetHistoryMessageRequest count.
             * @member {number|null|undefined} count
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             */
            GetHistoryMessageRequest.prototype.count = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetHistoryMessageRequest _start_message_id.
             * @member {"start_message_id"|undefined} _start_message_id
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             */
            Object.defineProperty(GetHistoryMessageRequest.prototype, "_start_message_id", {
                get: $util.oneOfGetter($oneOfFields = ["start_message_id"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GetHistoryMessageRequest _count.
             * @member {"count"|undefined} _count
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             */
            Object.defineProperty(GetHistoryMessageRequest.prototype, "_count", {
                get: $util.oneOfGetter($oneOfFields = ["count"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetHistoryMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {kritor.message.IGetHistoryMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.GetHistoryMessageRequest} GetHistoryMessageRequest instance
             */
            GetHistoryMessageRequest.create = function create(properties) {
                return new GetHistoryMessageRequest(properties);
            };

            /**
             * Encodes the specified GetHistoryMessageRequest message. Does not implicitly {@link kritor.message.GetHistoryMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {kritor.message.IGetHistoryMessageRequest} message GetHistoryMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.start_message_id != null && Object.hasOwnProperty.call(message, "start_message_id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.start_message_id);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified GetHistoryMessageRequest message, length delimited. Does not implicitly {@link kritor.message.GetHistoryMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {kritor.message.IGetHistoryMessageRequest} message GetHistoryMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHistoryMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetHistoryMessageRequest} GetHistoryMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetHistoryMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.start_message_id = reader.string();
                            break;
                        }
                    case 3: {
                            message.count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHistoryMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetHistoryMessageRequest} GetHistoryMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHistoryMessageRequest message.
             * @function verify
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHistoryMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.start_message_id != null && message.hasOwnProperty("start_message_id")) {
                    properties._start_message_id = 1;
                    if (!$util.isString(message.start_message_id))
                        return "start_message_id: string expected";
                }
                if (message.count != null && message.hasOwnProperty("count")) {
                    properties._count = 1;
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                }
                return null;
            };

            /**
             * Creates a GetHistoryMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetHistoryMessageRequest} GetHistoryMessageRequest
             */
            GetHistoryMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetHistoryMessageRequest)
                    return object;
                let message = new $root.kritor.message.GetHistoryMessageRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.GetHistoryMessageRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.start_message_id != null)
                    message.start_message_id = String(object.start_message_id);
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetHistoryMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {kritor.message.GetHistoryMessageRequest} message GetHistoryMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHistoryMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.contact = null;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.start_message_id != null && message.hasOwnProperty("start_message_id")) {
                    object.start_message_id = message.start_message_id;
                    if (options.oneofs)
                        object._start_message_id = "start_message_id";
                }
                if (message.count != null && message.hasOwnProperty("count")) {
                    object.count = message.count;
                    if (options.oneofs)
                        object._count = "count";
                }
                return object;
            };

            /**
             * Converts this GetHistoryMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHistoryMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHistoryMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHistoryMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetHistoryMessageRequest";
            };

            return GetHistoryMessageRequest;
        })();

        message.GetHistoryMessageResponse = (function() {

            /**
             * Properties of a GetHistoryMessageResponse.
             * @memberof kritor.message
             * @interface IGetHistoryMessageResponse
             * @property {Array.<kritor.common.IPushMessageBody>|null} [messages] GetHistoryMessageResponse messages
             */

            /**
             * Constructs a new GetHistoryMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a GetHistoryMessageResponse.
             * @implements IGetHistoryMessageResponse
             * @constructor
             * @param {kritor.message.IGetHistoryMessageResponse=} [properties] Properties to set
             */
            function GetHistoryMessageResponse(properties) {
                this.messages = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHistoryMessageResponse messages.
             * @member {Array.<kritor.common.IPushMessageBody>} messages
             * @memberof kritor.message.GetHistoryMessageResponse
             * @instance
             */
            GetHistoryMessageResponse.prototype.messages = $util.emptyArray;

            /**
             * Creates a new GetHistoryMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {kritor.message.IGetHistoryMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.GetHistoryMessageResponse} GetHistoryMessageResponse instance
             */
            GetHistoryMessageResponse.create = function create(properties) {
                return new GetHistoryMessageResponse(properties);
            };

            /**
             * Encodes the specified GetHistoryMessageResponse message. Does not implicitly {@link kritor.message.GetHistoryMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {kritor.message.IGetHistoryMessageResponse} message GetHistoryMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messages != null && message.messages.length)
                    for (let i = 0; i < message.messages.length; ++i)
                        $root.kritor.common.PushMessageBody.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetHistoryMessageResponse message, length delimited. Does not implicitly {@link kritor.message.GetHistoryMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {kritor.message.IGetHistoryMessageResponse} message GetHistoryMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHistoryMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetHistoryMessageResponse} GetHistoryMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetHistoryMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.kritor.common.PushMessageBody.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHistoryMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetHistoryMessageResponse} GetHistoryMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHistoryMessageResponse message.
             * @function verify
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHistoryMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (let i = 0; i < message.messages.length; ++i) {
                        let error = $root.kritor.common.PushMessageBody.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetHistoryMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetHistoryMessageResponse} GetHistoryMessageResponse
             */
            GetHistoryMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetHistoryMessageResponse)
                    return object;
                let message = new $root.kritor.message.GetHistoryMessageResponse();
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".kritor.message.GetHistoryMessageResponse.messages: array expected");
                    message.messages = [];
                    for (let i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".kritor.message.GetHistoryMessageResponse.messages: object expected");
                        message.messages[i] = $root.kritor.common.PushMessageBody.fromObject(object.messages[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetHistoryMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {kritor.message.GetHistoryMessageResponse} message GetHistoryMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHistoryMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (let j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.kritor.common.PushMessageBody.toObject(message.messages[j], options);
                }
                return object;
            };

            /**
             * Converts this GetHistoryMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.GetHistoryMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHistoryMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHistoryMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHistoryMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetHistoryMessageResponse";
            };

            return GetHistoryMessageResponse;
        })();

        message.GetHistoryMessageBySeqRequest = (function() {

            /**
             * Properties of a GetHistoryMessageBySeqRequest.
             * @memberof kritor.message
             * @interface IGetHistoryMessageBySeqRequest
             * @property {kritor.common.IContact|null} [contact] GetHistoryMessageBySeqRequest contact
             * @property {number|Long|null} [start_message_seq] GetHistoryMessageBySeqRequest start_message_seq
             * @property {number|null} [count] GetHistoryMessageBySeqRequest count
             */

            /**
             * Constructs a new GetHistoryMessageBySeqRequest.
             * @memberof kritor.message
             * @classdesc Represents a GetHistoryMessageBySeqRequest.
             * @implements IGetHistoryMessageBySeqRequest
             * @constructor
             * @param {kritor.message.IGetHistoryMessageBySeqRequest=} [properties] Properties to set
             */
            function GetHistoryMessageBySeqRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHistoryMessageBySeqRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @instance
             */
            GetHistoryMessageBySeqRequest.prototype.contact = null;

            /**
             * GetHistoryMessageBySeqRequest start_message_seq.
             * @member {number|Long|null|undefined} start_message_seq
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @instance
             */
            GetHistoryMessageBySeqRequest.prototype.start_message_seq = null;

            /**
             * GetHistoryMessageBySeqRequest count.
             * @member {number|null|undefined} count
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @instance
             */
            GetHistoryMessageBySeqRequest.prototype.count = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetHistoryMessageBySeqRequest _start_message_seq.
             * @member {"start_message_seq"|undefined} _start_message_seq
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @instance
             */
            Object.defineProperty(GetHistoryMessageBySeqRequest.prototype, "_start_message_seq", {
                get: $util.oneOfGetter($oneOfFields = ["start_message_seq"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GetHistoryMessageBySeqRequest _count.
             * @member {"count"|undefined} _count
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @instance
             */
            Object.defineProperty(GetHistoryMessageBySeqRequest.prototype, "_count", {
                get: $util.oneOfGetter($oneOfFields = ["count"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetHistoryMessageBySeqRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {kritor.message.IGetHistoryMessageBySeqRequest=} [properties] Properties to set
             * @returns {kritor.message.GetHistoryMessageBySeqRequest} GetHistoryMessageBySeqRequest instance
             */
            GetHistoryMessageBySeqRequest.create = function create(properties) {
                return new GetHistoryMessageBySeqRequest(properties);
            };

            /**
             * Encodes the specified GetHistoryMessageBySeqRequest message. Does not implicitly {@link kritor.message.GetHistoryMessageBySeqRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {kritor.message.IGetHistoryMessageBySeqRequest} message GetHistoryMessageBySeqRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageBySeqRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.start_message_seq != null && Object.hasOwnProperty.call(message, "start_message_seq"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.start_message_seq);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified GetHistoryMessageBySeqRequest message, length delimited. Does not implicitly {@link kritor.message.GetHistoryMessageBySeqRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {kritor.message.IGetHistoryMessageBySeqRequest} message GetHistoryMessageBySeqRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageBySeqRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHistoryMessageBySeqRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetHistoryMessageBySeqRequest} GetHistoryMessageBySeqRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageBySeqRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetHistoryMessageBySeqRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.start_message_seq = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHistoryMessageBySeqRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetHistoryMessageBySeqRequest} GetHistoryMessageBySeqRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageBySeqRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHistoryMessageBySeqRequest message.
             * @function verify
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHistoryMessageBySeqRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.start_message_seq != null && message.hasOwnProperty("start_message_seq")) {
                    properties._start_message_seq = 1;
                    if (!$util.isInteger(message.start_message_seq) && !(message.start_message_seq && $util.isInteger(message.start_message_seq.low) && $util.isInteger(message.start_message_seq.high)))
                        return "start_message_seq: integer|Long expected";
                }
                if (message.count != null && message.hasOwnProperty("count")) {
                    properties._count = 1;
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                }
                return null;
            };

            /**
             * Creates a GetHistoryMessageBySeqRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetHistoryMessageBySeqRequest} GetHistoryMessageBySeqRequest
             */
            GetHistoryMessageBySeqRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetHistoryMessageBySeqRequest)
                    return object;
                let message = new $root.kritor.message.GetHistoryMessageBySeqRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.GetHistoryMessageBySeqRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.start_message_seq != null)
                    if ($util.Long)
                        (message.start_message_seq = $util.Long.fromValue(object.start_message_seq)).unsigned = true;
                    else if (typeof object.start_message_seq === "string")
                        message.start_message_seq = parseInt(object.start_message_seq, 10);
                    else if (typeof object.start_message_seq === "number")
                        message.start_message_seq = object.start_message_seq;
                    else if (typeof object.start_message_seq === "object")
                        message.start_message_seq = new $util.LongBits(object.start_message_seq.low >>> 0, object.start_message_seq.high >>> 0).toNumber(true);
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetHistoryMessageBySeqRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {kritor.message.GetHistoryMessageBySeqRequest} message GetHistoryMessageBySeqRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHistoryMessageBySeqRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.contact = null;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.start_message_seq != null && message.hasOwnProperty("start_message_seq")) {
                    if (typeof message.start_message_seq === "number")
                        object.start_message_seq = options.longs === String ? String(message.start_message_seq) : message.start_message_seq;
                    else
                        object.start_message_seq = options.longs === String ? $util.Long.prototype.toString.call(message.start_message_seq) : options.longs === Number ? new $util.LongBits(message.start_message_seq.low >>> 0, message.start_message_seq.high >>> 0).toNumber(true) : message.start_message_seq;
                    if (options.oneofs)
                        object._start_message_seq = "start_message_seq";
                }
                if (message.count != null && message.hasOwnProperty("count")) {
                    object.count = message.count;
                    if (options.oneofs)
                        object._count = "count";
                }
                return object;
            };

            /**
             * Converts this GetHistoryMessageBySeqRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHistoryMessageBySeqRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHistoryMessageBySeqRequest
             * @function getTypeUrl
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHistoryMessageBySeqRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetHistoryMessageBySeqRequest";
            };

            return GetHistoryMessageBySeqRequest;
        })();

        message.GetHistoryMessageBySeqResponse = (function() {

            /**
             * Properties of a GetHistoryMessageBySeqResponse.
             * @memberof kritor.message
             * @interface IGetHistoryMessageBySeqResponse
             * @property {Array.<kritor.common.IPushMessageBody>|null} [messages] GetHistoryMessageBySeqResponse messages
             */

            /**
             * Constructs a new GetHistoryMessageBySeqResponse.
             * @memberof kritor.message
             * @classdesc Represents a GetHistoryMessageBySeqResponse.
             * @implements IGetHistoryMessageBySeqResponse
             * @constructor
             * @param {kritor.message.IGetHistoryMessageBySeqResponse=} [properties] Properties to set
             */
            function GetHistoryMessageBySeqResponse(properties) {
                this.messages = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHistoryMessageBySeqResponse messages.
             * @member {Array.<kritor.common.IPushMessageBody>} messages
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @instance
             */
            GetHistoryMessageBySeqResponse.prototype.messages = $util.emptyArray;

            /**
             * Creates a new GetHistoryMessageBySeqResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {kritor.message.IGetHistoryMessageBySeqResponse=} [properties] Properties to set
             * @returns {kritor.message.GetHistoryMessageBySeqResponse} GetHistoryMessageBySeqResponse instance
             */
            GetHistoryMessageBySeqResponse.create = function create(properties) {
                return new GetHistoryMessageBySeqResponse(properties);
            };

            /**
             * Encodes the specified GetHistoryMessageBySeqResponse message. Does not implicitly {@link kritor.message.GetHistoryMessageBySeqResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {kritor.message.IGetHistoryMessageBySeqResponse} message GetHistoryMessageBySeqResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageBySeqResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messages != null && message.messages.length)
                    for (let i = 0; i < message.messages.length; ++i)
                        $root.kritor.common.PushMessageBody.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetHistoryMessageBySeqResponse message, length delimited. Does not implicitly {@link kritor.message.GetHistoryMessageBySeqResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {kritor.message.IGetHistoryMessageBySeqResponse} message GetHistoryMessageBySeqResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageBySeqResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHistoryMessageBySeqResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetHistoryMessageBySeqResponse} GetHistoryMessageBySeqResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageBySeqResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetHistoryMessageBySeqResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.kritor.common.PushMessageBody.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHistoryMessageBySeqResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetHistoryMessageBySeqResponse} GetHistoryMessageBySeqResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageBySeqResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHistoryMessageBySeqResponse message.
             * @function verify
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHistoryMessageBySeqResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (let i = 0; i < message.messages.length; ++i) {
                        let error = $root.kritor.common.PushMessageBody.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetHistoryMessageBySeqResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetHistoryMessageBySeqResponse} GetHistoryMessageBySeqResponse
             */
            GetHistoryMessageBySeqResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetHistoryMessageBySeqResponse)
                    return object;
                let message = new $root.kritor.message.GetHistoryMessageBySeqResponse();
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".kritor.message.GetHistoryMessageBySeqResponse.messages: array expected");
                    message.messages = [];
                    for (let i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".kritor.message.GetHistoryMessageBySeqResponse.messages: object expected");
                        message.messages[i] = $root.kritor.common.PushMessageBody.fromObject(object.messages[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetHistoryMessageBySeqResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {kritor.message.GetHistoryMessageBySeqResponse} message GetHistoryMessageBySeqResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHistoryMessageBySeqResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (let j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.kritor.common.PushMessageBody.toObject(message.messages[j], options);
                }
                return object;
            };

            /**
             * Converts this GetHistoryMessageBySeqResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHistoryMessageBySeqResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHistoryMessageBySeqResponse
             * @function getTypeUrl
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHistoryMessageBySeqResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetHistoryMessageBySeqResponse";
            };

            return GetHistoryMessageBySeqResponse;
        })();

        message.UploadForwardMessageRequest = (function() {

            /**
             * Properties of an UploadForwardMessageRequest.
             * @memberof kritor.message
             * @interface IUploadForwardMessageRequest
             * @property {kritor.common.IContact|null} [contact] UploadForwardMessageRequest contact
             * @property {Array.<kritor.common.IForwardMessageBody>|null} [messages] UploadForwardMessageRequest messages
             * @property {number|null} [retry_count] UploadForwardMessageRequest retry_count
             */

            /**
             * Constructs a new UploadForwardMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents an UploadForwardMessageRequest.
             * @implements IUploadForwardMessageRequest
             * @constructor
             * @param {kritor.message.IUploadForwardMessageRequest=} [properties] Properties to set
             */
            function UploadForwardMessageRequest(properties) {
                this.messages = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UploadForwardMessageRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.UploadForwardMessageRequest
             * @instance
             */
            UploadForwardMessageRequest.prototype.contact = null;

            /**
             * UploadForwardMessageRequest messages.
             * @member {Array.<kritor.common.IForwardMessageBody>} messages
             * @memberof kritor.message.UploadForwardMessageRequest
             * @instance
             */
            UploadForwardMessageRequest.prototype.messages = $util.emptyArray;

            /**
             * UploadForwardMessageRequest retry_count.
             * @member {number|null|undefined} retry_count
             * @memberof kritor.message.UploadForwardMessageRequest
             * @instance
             */
            UploadForwardMessageRequest.prototype.retry_count = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * UploadForwardMessageRequest _retry_count.
             * @member {"retry_count"|undefined} _retry_count
             * @memberof kritor.message.UploadForwardMessageRequest
             * @instance
             */
            Object.defineProperty(UploadForwardMessageRequest.prototype, "_retry_count", {
                get: $util.oneOfGetter($oneOfFields = ["retry_count"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new UploadForwardMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {kritor.message.IUploadForwardMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.UploadForwardMessageRequest} UploadForwardMessageRequest instance
             */
            UploadForwardMessageRequest.create = function create(properties) {
                return new UploadForwardMessageRequest(properties);
            };

            /**
             * Encodes the specified UploadForwardMessageRequest message. Does not implicitly {@link kritor.message.UploadForwardMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {kritor.message.IUploadForwardMessageRequest} message UploadForwardMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadForwardMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.messages != null && message.messages.length)
                    for (let i = 0; i < message.messages.length; ++i)
                        $root.kritor.common.ForwardMessageBody.encode(message.messages[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.retry_count != null && Object.hasOwnProperty.call(message, "retry_count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.retry_count);
                return writer;
            };

            /**
             * Encodes the specified UploadForwardMessageRequest message, length delimited. Does not implicitly {@link kritor.message.UploadForwardMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {kritor.message.IUploadForwardMessageRequest} message UploadForwardMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadForwardMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UploadForwardMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.UploadForwardMessageRequest} UploadForwardMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadForwardMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.UploadForwardMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.kritor.common.ForwardMessageBody.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.retry_count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UploadForwardMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.UploadForwardMessageRequest} UploadForwardMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadForwardMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UploadForwardMessageRequest message.
             * @function verify
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UploadForwardMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (let i = 0; i < message.messages.length; ++i) {
                        let error = $root.kritor.common.ForwardMessageBody.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                if (message.retry_count != null && message.hasOwnProperty("retry_count")) {
                    properties._retry_count = 1;
                    if (!$util.isInteger(message.retry_count))
                        return "retry_count: integer expected";
                }
                return null;
            };

            /**
             * Creates an UploadForwardMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.UploadForwardMessageRequest} UploadForwardMessageRequest
             */
            UploadForwardMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.UploadForwardMessageRequest)
                    return object;
                let message = new $root.kritor.message.UploadForwardMessageRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.UploadForwardMessageRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".kritor.message.UploadForwardMessageRequest.messages: array expected");
                    message.messages = [];
                    for (let i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".kritor.message.UploadForwardMessageRequest.messages: object expected");
                        message.messages[i] = $root.kritor.common.ForwardMessageBody.fromObject(object.messages[i]);
                    }
                }
                if (object.retry_count != null)
                    message.retry_count = object.retry_count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an UploadForwardMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {kritor.message.UploadForwardMessageRequest} message UploadForwardMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UploadForwardMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (options.defaults)
                    object.contact = null;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (let j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.kritor.common.ForwardMessageBody.toObject(message.messages[j], options);
                }
                if (message.retry_count != null && message.hasOwnProperty("retry_count")) {
                    object.retry_count = message.retry_count;
                    if (options.oneofs)
                        object._retry_count = "retry_count";
                }
                return object;
            };

            /**
             * Converts this UploadForwardMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.UploadForwardMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UploadForwardMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UploadForwardMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UploadForwardMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.UploadForwardMessageRequest";
            };

            return UploadForwardMessageRequest;
        })();

        message.UploadForwardMessageResponse = (function() {

            /**
             * Properties of an UploadForwardMessageResponse.
             * @memberof kritor.message
             * @interface IUploadForwardMessageResponse
             * @property {string|null} [res_id] UploadForwardMessageResponse res_id
             */

            /**
             * Constructs a new UploadForwardMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents an UploadForwardMessageResponse.
             * @implements IUploadForwardMessageResponse
             * @constructor
             * @param {kritor.message.IUploadForwardMessageResponse=} [properties] Properties to set
             */
            function UploadForwardMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UploadForwardMessageResponse res_id.
             * @member {string} res_id
             * @memberof kritor.message.UploadForwardMessageResponse
             * @instance
             */
            UploadForwardMessageResponse.prototype.res_id = "";

            /**
             * Creates a new UploadForwardMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {kritor.message.IUploadForwardMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.UploadForwardMessageResponse} UploadForwardMessageResponse instance
             */
            UploadForwardMessageResponse.create = function create(properties) {
                return new UploadForwardMessageResponse(properties);
            };

            /**
             * Encodes the specified UploadForwardMessageResponse message. Does not implicitly {@link kritor.message.UploadForwardMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {kritor.message.IUploadForwardMessageResponse} message UploadForwardMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadForwardMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.res_id != null && Object.hasOwnProperty.call(message, "res_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.res_id);
                return writer;
            };

            /**
             * Encodes the specified UploadForwardMessageResponse message, length delimited. Does not implicitly {@link kritor.message.UploadForwardMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {kritor.message.IUploadForwardMessageResponse} message UploadForwardMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadForwardMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UploadForwardMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.UploadForwardMessageResponse} UploadForwardMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadForwardMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.UploadForwardMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.res_id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UploadForwardMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.UploadForwardMessageResponse} UploadForwardMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadForwardMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UploadForwardMessageResponse message.
             * @function verify
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UploadForwardMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.res_id != null && message.hasOwnProperty("res_id"))
                    if (!$util.isString(message.res_id))
                        return "res_id: string expected";
                return null;
            };

            /**
             * Creates an UploadForwardMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.UploadForwardMessageResponse} UploadForwardMessageResponse
             */
            UploadForwardMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.UploadForwardMessageResponse)
                    return object;
                let message = new $root.kritor.message.UploadForwardMessageResponse();
                if (object.res_id != null)
                    message.res_id = String(object.res_id);
                return message;
            };

            /**
             * Creates a plain object from an UploadForwardMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {kritor.message.UploadForwardMessageResponse} message UploadForwardMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UploadForwardMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.res_id = "";
                if (message.res_id != null && message.hasOwnProperty("res_id"))
                    object.res_id = message.res_id;
                return object;
            };

            /**
             * Converts this UploadForwardMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.UploadForwardMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UploadForwardMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UploadForwardMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UploadForwardMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.UploadForwardMessageResponse";
            };

            return UploadForwardMessageResponse;
        })();

        message.DownloadForwardMessageRequest = (function() {

            /**
             * Properties of a DownloadForwardMessageRequest.
             * @memberof kritor.message
             * @interface IDownloadForwardMessageRequest
             * @property {string|null} [res_id] DownloadForwardMessageRequest res_id
             */

            /**
             * Constructs a new DownloadForwardMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a DownloadForwardMessageRequest.
             * @implements IDownloadForwardMessageRequest
             * @constructor
             * @param {kritor.message.IDownloadForwardMessageRequest=} [properties] Properties to set
             */
            function DownloadForwardMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DownloadForwardMessageRequest res_id.
             * @member {string} res_id
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @instance
             */
            DownloadForwardMessageRequest.prototype.res_id = "";

            /**
             * Creates a new DownloadForwardMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {kritor.message.IDownloadForwardMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.DownloadForwardMessageRequest} DownloadForwardMessageRequest instance
             */
            DownloadForwardMessageRequest.create = function create(properties) {
                return new DownloadForwardMessageRequest(properties);
            };

            /**
             * Encodes the specified DownloadForwardMessageRequest message. Does not implicitly {@link kritor.message.DownloadForwardMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {kritor.message.IDownloadForwardMessageRequest} message DownloadForwardMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadForwardMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.res_id != null && Object.hasOwnProperty.call(message, "res_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.res_id);
                return writer;
            };

            /**
             * Encodes the specified DownloadForwardMessageRequest message, length delimited. Does not implicitly {@link kritor.message.DownloadForwardMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {kritor.message.IDownloadForwardMessageRequest} message DownloadForwardMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadForwardMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DownloadForwardMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.DownloadForwardMessageRequest} DownloadForwardMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadForwardMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.DownloadForwardMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.res_id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DownloadForwardMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.DownloadForwardMessageRequest} DownloadForwardMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadForwardMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DownloadForwardMessageRequest message.
             * @function verify
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DownloadForwardMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.res_id != null && message.hasOwnProperty("res_id"))
                    if (!$util.isString(message.res_id))
                        return "res_id: string expected";
                return null;
            };

            /**
             * Creates a DownloadForwardMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.DownloadForwardMessageRequest} DownloadForwardMessageRequest
             */
            DownloadForwardMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.DownloadForwardMessageRequest)
                    return object;
                let message = new $root.kritor.message.DownloadForwardMessageRequest();
                if (object.res_id != null)
                    message.res_id = String(object.res_id);
                return message;
            };

            /**
             * Creates a plain object from a DownloadForwardMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {kritor.message.DownloadForwardMessageRequest} message DownloadForwardMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DownloadForwardMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.res_id = "";
                if (message.res_id != null && message.hasOwnProperty("res_id"))
                    object.res_id = message.res_id;
                return object;
            };

            /**
             * Converts this DownloadForwardMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DownloadForwardMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DownloadForwardMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DownloadForwardMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.DownloadForwardMessageRequest";
            };

            return DownloadForwardMessageRequest;
        })();

        message.DownloadForwardMessageResponse = (function() {

            /**
             * Properties of a DownloadForwardMessageResponse.
             * @memberof kritor.message
             * @interface IDownloadForwardMessageResponse
             * @property {Array.<kritor.common.IPushMessageBody>|null} [messages] DownloadForwardMessageResponse messages
             */

            /**
             * Constructs a new DownloadForwardMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a DownloadForwardMessageResponse.
             * @implements IDownloadForwardMessageResponse
             * @constructor
             * @param {kritor.message.IDownloadForwardMessageResponse=} [properties] Properties to set
             */
            function DownloadForwardMessageResponse(properties) {
                this.messages = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DownloadForwardMessageResponse messages.
             * @member {Array.<kritor.common.IPushMessageBody>} messages
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @instance
             */
            DownloadForwardMessageResponse.prototype.messages = $util.emptyArray;

            /**
             * Creates a new DownloadForwardMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {kritor.message.IDownloadForwardMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.DownloadForwardMessageResponse} DownloadForwardMessageResponse instance
             */
            DownloadForwardMessageResponse.create = function create(properties) {
                return new DownloadForwardMessageResponse(properties);
            };

            /**
             * Encodes the specified DownloadForwardMessageResponse message. Does not implicitly {@link kritor.message.DownloadForwardMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {kritor.message.IDownloadForwardMessageResponse} message DownloadForwardMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadForwardMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messages != null && message.messages.length)
                    for (let i = 0; i < message.messages.length; ++i)
                        $root.kritor.common.PushMessageBody.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DownloadForwardMessageResponse message, length delimited. Does not implicitly {@link kritor.message.DownloadForwardMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {kritor.message.IDownloadForwardMessageResponse} message DownloadForwardMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadForwardMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DownloadForwardMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.DownloadForwardMessageResponse} DownloadForwardMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadForwardMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.DownloadForwardMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.kritor.common.PushMessageBody.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DownloadForwardMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.DownloadForwardMessageResponse} DownloadForwardMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadForwardMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DownloadForwardMessageResponse message.
             * @function verify
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DownloadForwardMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (let i = 0; i < message.messages.length; ++i) {
                        let error = $root.kritor.common.PushMessageBody.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a DownloadForwardMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.DownloadForwardMessageResponse} DownloadForwardMessageResponse
             */
            DownloadForwardMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.DownloadForwardMessageResponse)
                    return object;
                let message = new $root.kritor.message.DownloadForwardMessageResponse();
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".kritor.message.DownloadForwardMessageResponse.messages: array expected");
                    message.messages = [];
                    for (let i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".kritor.message.DownloadForwardMessageResponse.messages: object expected");
                        message.messages[i] = $root.kritor.common.PushMessageBody.fromObject(object.messages[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a DownloadForwardMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {kritor.message.DownloadForwardMessageResponse} message DownloadForwardMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DownloadForwardMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (let j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.kritor.common.PushMessageBody.toObject(message.messages[j], options);
                }
                return object;
            };

            /**
             * Converts this DownloadForwardMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DownloadForwardMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DownloadForwardMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DownloadForwardMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.DownloadForwardMessageResponse";
            };

            return DownloadForwardMessageResponse;
        })();

        message.GetEssenceMessageListRequest = (function() {

            /**
             * Properties of a GetEssenceMessageListRequest.
             * @memberof kritor.message
             * @interface IGetEssenceMessageListRequest
             * @property {number|Long|null} [group_id] GetEssenceMessageListRequest group_id
             * @property {number|null} [page] GetEssenceMessageListRequest page
             * @property {number|null} [page_size] GetEssenceMessageListRequest page_size
             */

            /**
             * Constructs a new GetEssenceMessageListRequest.
             * @memberof kritor.message
             * @classdesc Represents a GetEssenceMessageListRequest.
             * @implements IGetEssenceMessageListRequest
             * @constructor
             * @param {kritor.message.IGetEssenceMessageListRequest=} [properties] Properties to set
             */
            function GetEssenceMessageListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetEssenceMessageListRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @instance
             */
            GetEssenceMessageListRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetEssenceMessageListRequest page.
             * @member {number} page
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @instance
             */
            GetEssenceMessageListRequest.prototype.page = 0;

            /**
             * GetEssenceMessageListRequest page_size.
             * @member {number} page_size
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @instance
             */
            GetEssenceMessageListRequest.prototype.page_size = 0;

            /**
             * Creates a new GetEssenceMessageListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {kritor.message.IGetEssenceMessageListRequest=} [properties] Properties to set
             * @returns {kritor.message.GetEssenceMessageListRequest} GetEssenceMessageListRequest instance
             */
            GetEssenceMessageListRequest.create = function create(properties) {
                return new GetEssenceMessageListRequest(properties);
            };

            /**
             * Encodes the specified GetEssenceMessageListRequest message. Does not implicitly {@link kritor.message.GetEssenceMessageListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {kritor.message.IGetEssenceMessageListRequest} message GetEssenceMessageListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEssenceMessageListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.page != null && Object.hasOwnProperty.call(message, "page"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.page);
                if (message.page_size != null && Object.hasOwnProperty.call(message, "page_size"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.page_size);
                return writer;
            };

            /**
             * Encodes the specified GetEssenceMessageListRequest message, length delimited. Does not implicitly {@link kritor.message.GetEssenceMessageListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {kritor.message.IGetEssenceMessageListRequest} message GetEssenceMessageListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEssenceMessageListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetEssenceMessageListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetEssenceMessageListRequest} GetEssenceMessageListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEssenceMessageListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetEssenceMessageListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.page = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.page_size = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetEssenceMessageListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetEssenceMessageListRequest} GetEssenceMessageListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEssenceMessageListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetEssenceMessageListRequest message.
             * @function verify
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetEssenceMessageListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.page != null && message.hasOwnProperty("page"))
                    if (!$util.isInteger(message.page))
                        return "page: integer expected";
                if (message.page_size != null && message.hasOwnProperty("page_size"))
                    if (!$util.isInteger(message.page_size))
                        return "page_size: integer expected";
                return null;
            };

            /**
             * Creates a GetEssenceMessageListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetEssenceMessageListRequest} GetEssenceMessageListRequest
             */
            GetEssenceMessageListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetEssenceMessageListRequest)
                    return object;
                let message = new $root.kritor.message.GetEssenceMessageListRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.page != null)
                    message.page = object.page >>> 0;
                if (object.page_size != null)
                    message.page_size = object.page_size >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetEssenceMessageListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {kritor.message.GetEssenceMessageListRequest} message GetEssenceMessageListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetEssenceMessageListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.page = 0;
                    object.page_size = 0;
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.page != null && message.hasOwnProperty("page"))
                    object.page = message.page;
                if (message.page_size != null && message.hasOwnProperty("page_size"))
                    object.page_size = message.page_size;
                return object;
            };

            /**
             * Converts this GetEssenceMessageListRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetEssenceMessageListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetEssenceMessageListRequest
             * @function getTypeUrl
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetEssenceMessageListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetEssenceMessageListRequest";
            };

            return GetEssenceMessageListRequest;
        })();

        message.GetEssenceMessageListResponse = (function() {

            /**
             * Properties of a GetEssenceMessageListResponse.
             * @memberof kritor.message
             * @interface IGetEssenceMessageListResponse
             * @property {Array.<kritor.common.IEssenceMessageBody>|null} [messages] GetEssenceMessageListResponse messages
             */

            /**
             * Constructs a new GetEssenceMessageListResponse.
             * @memberof kritor.message
             * @classdesc Represents a GetEssenceMessageListResponse.
             * @implements IGetEssenceMessageListResponse
             * @constructor
             * @param {kritor.message.IGetEssenceMessageListResponse=} [properties] Properties to set
             */
            function GetEssenceMessageListResponse(properties) {
                this.messages = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetEssenceMessageListResponse messages.
             * @member {Array.<kritor.common.IEssenceMessageBody>} messages
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @instance
             */
            GetEssenceMessageListResponse.prototype.messages = $util.emptyArray;

            /**
             * Creates a new GetEssenceMessageListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {kritor.message.IGetEssenceMessageListResponse=} [properties] Properties to set
             * @returns {kritor.message.GetEssenceMessageListResponse} GetEssenceMessageListResponse instance
             */
            GetEssenceMessageListResponse.create = function create(properties) {
                return new GetEssenceMessageListResponse(properties);
            };

            /**
             * Encodes the specified GetEssenceMessageListResponse message. Does not implicitly {@link kritor.message.GetEssenceMessageListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {kritor.message.IGetEssenceMessageListResponse} message GetEssenceMessageListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEssenceMessageListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messages != null && message.messages.length)
                    for (let i = 0; i < message.messages.length; ++i)
                        $root.kritor.common.EssenceMessageBody.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetEssenceMessageListResponse message, length delimited. Does not implicitly {@link kritor.message.GetEssenceMessageListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {kritor.message.IGetEssenceMessageListResponse} message GetEssenceMessageListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEssenceMessageListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetEssenceMessageListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetEssenceMessageListResponse} GetEssenceMessageListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEssenceMessageListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetEssenceMessageListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.kritor.common.EssenceMessageBody.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetEssenceMessageListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetEssenceMessageListResponse} GetEssenceMessageListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEssenceMessageListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetEssenceMessageListResponse message.
             * @function verify
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetEssenceMessageListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (let i = 0; i < message.messages.length; ++i) {
                        let error = $root.kritor.common.EssenceMessageBody.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetEssenceMessageListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetEssenceMessageListResponse} GetEssenceMessageListResponse
             */
            GetEssenceMessageListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetEssenceMessageListResponse)
                    return object;
                let message = new $root.kritor.message.GetEssenceMessageListResponse();
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".kritor.message.GetEssenceMessageListResponse.messages: array expected");
                    message.messages = [];
                    for (let i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".kritor.message.GetEssenceMessageListResponse.messages: object expected");
                        message.messages[i] = $root.kritor.common.EssenceMessageBody.fromObject(object.messages[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetEssenceMessageListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {kritor.message.GetEssenceMessageListResponse} message GetEssenceMessageListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetEssenceMessageListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (let j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.kritor.common.EssenceMessageBody.toObject(message.messages[j], options);
                }
                return object;
            };

            /**
             * Converts this GetEssenceMessageListResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetEssenceMessageListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetEssenceMessageListResponse
             * @function getTypeUrl
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetEssenceMessageListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetEssenceMessageListResponse";
            };

            return GetEssenceMessageListResponse;
        })();

        message.SetEssenceMessageRequest = (function() {

            /**
             * Properties of a SetEssenceMessageRequest.
             * @memberof kritor.message
             * @interface ISetEssenceMessageRequest
             * @property {number|Long|null} [group_id] SetEssenceMessageRequest group_id
             * @property {string|null} [message_id] SetEssenceMessageRequest message_id
             */

            /**
             * Constructs a new SetEssenceMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a SetEssenceMessageRequest.
             * @implements ISetEssenceMessageRequest
             * @constructor
             * @param {kritor.message.ISetEssenceMessageRequest=} [properties] Properties to set
             */
            function SetEssenceMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetEssenceMessageRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.message.SetEssenceMessageRequest
             * @instance
             */
            SetEssenceMessageRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetEssenceMessageRequest message_id.
             * @member {string} message_id
             * @memberof kritor.message.SetEssenceMessageRequest
             * @instance
             */
            SetEssenceMessageRequest.prototype.message_id = "";

            /**
             * Creates a new SetEssenceMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {kritor.message.ISetEssenceMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.SetEssenceMessageRequest} SetEssenceMessageRequest instance
             */
            SetEssenceMessageRequest.create = function create(properties) {
                return new SetEssenceMessageRequest(properties);
            };

            /**
             * Encodes the specified SetEssenceMessageRequest message. Does not implicitly {@link kritor.message.SetEssenceMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {kritor.message.ISetEssenceMessageRequest} message SetEssenceMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEssenceMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message_id);
                return writer;
            };

            /**
             * Encodes the specified SetEssenceMessageRequest message, length delimited. Does not implicitly {@link kritor.message.SetEssenceMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {kritor.message.ISetEssenceMessageRequest} message SetEssenceMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEssenceMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetEssenceMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SetEssenceMessageRequest} SetEssenceMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEssenceMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SetEssenceMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.message_id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetEssenceMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SetEssenceMessageRequest} SetEssenceMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEssenceMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetEssenceMessageRequest message.
             * @function verify
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetEssenceMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                return null;
            };

            /**
             * Creates a SetEssenceMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SetEssenceMessageRequest} SetEssenceMessageRequest
             */
            SetEssenceMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SetEssenceMessageRequest)
                    return object;
                let message = new $root.kritor.message.SetEssenceMessageRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                return message;
            };

            /**
             * Creates a plain object from a SetEssenceMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {kritor.message.SetEssenceMessageRequest} message SetEssenceMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetEssenceMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.message_id = "";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    object.message_id = message.message_id;
                return object;
            };

            /**
             * Converts this SetEssenceMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.SetEssenceMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetEssenceMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetEssenceMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetEssenceMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SetEssenceMessageRequest";
            };

            return SetEssenceMessageRequest;
        })();

        message.SetEssenceMessageResponse = (function() {

            /**
             * Properties of a SetEssenceMessageResponse.
             * @memberof kritor.message
             * @interface ISetEssenceMessageResponse
             */

            /**
             * Constructs a new SetEssenceMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a SetEssenceMessageResponse.
             * @implements ISetEssenceMessageResponse
             * @constructor
             * @param {kritor.message.ISetEssenceMessageResponse=} [properties] Properties to set
             */
            function SetEssenceMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetEssenceMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {kritor.message.ISetEssenceMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.SetEssenceMessageResponse} SetEssenceMessageResponse instance
             */
            SetEssenceMessageResponse.create = function create(properties) {
                return new SetEssenceMessageResponse(properties);
            };

            /**
             * Encodes the specified SetEssenceMessageResponse message. Does not implicitly {@link kritor.message.SetEssenceMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {kritor.message.ISetEssenceMessageResponse} message SetEssenceMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEssenceMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetEssenceMessageResponse message, length delimited. Does not implicitly {@link kritor.message.SetEssenceMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {kritor.message.ISetEssenceMessageResponse} message SetEssenceMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEssenceMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetEssenceMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SetEssenceMessageResponse} SetEssenceMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEssenceMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SetEssenceMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetEssenceMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SetEssenceMessageResponse} SetEssenceMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEssenceMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetEssenceMessageResponse message.
             * @function verify
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetEssenceMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetEssenceMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SetEssenceMessageResponse} SetEssenceMessageResponse
             */
            SetEssenceMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SetEssenceMessageResponse)
                    return object;
                return new $root.kritor.message.SetEssenceMessageResponse();
            };

            /**
             * Creates a plain object from a SetEssenceMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {kritor.message.SetEssenceMessageResponse} message SetEssenceMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetEssenceMessageResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetEssenceMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.SetEssenceMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetEssenceMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetEssenceMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetEssenceMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SetEssenceMessageResponse";
            };

            return SetEssenceMessageResponse;
        })();

        message.DeleteEssenceMessageRequest = (function() {

            /**
             * Properties of a DeleteEssenceMessageRequest.
             * @memberof kritor.message
             * @interface IDeleteEssenceMessageRequest
             * @property {number|Long|null} [group_id] DeleteEssenceMessageRequest group_id
             * @property {string|null} [message_id] DeleteEssenceMessageRequest message_id
             */

            /**
             * Constructs a new DeleteEssenceMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a DeleteEssenceMessageRequest.
             * @implements IDeleteEssenceMessageRequest
             * @constructor
             * @param {kritor.message.IDeleteEssenceMessageRequest=} [properties] Properties to set
             */
            function DeleteEssenceMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteEssenceMessageRequest group_id.
             * @member {number|Long} group_id
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @instance
             */
            DeleteEssenceMessageRequest.prototype.group_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * DeleteEssenceMessageRequest message_id.
             * @member {string} message_id
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @instance
             */
            DeleteEssenceMessageRequest.prototype.message_id = "";

            /**
             * Creates a new DeleteEssenceMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {kritor.message.IDeleteEssenceMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.DeleteEssenceMessageRequest} DeleteEssenceMessageRequest instance
             */
            DeleteEssenceMessageRequest.create = function create(properties) {
                return new DeleteEssenceMessageRequest(properties);
            };

            /**
             * Encodes the specified DeleteEssenceMessageRequest message. Does not implicitly {@link kritor.message.DeleteEssenceMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {kritor.message.IDeleteEssenceMessageRequest} message DeleteEssenceMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteEssenceMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.group_id != null && Object.hasOwnProperty.call(message, "group_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.group_id);
                if (message.message_id != null && Object.hasOwnProperty.call(message, "message_id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message_id);
                return writer;
            };

            /**
             * Encodes the specified DeleteEssenceMessageRequest message, length delimited. Does not implicitly {@link kritor.message.DeleteEssenceMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {kritor.message.IDeleteEssenceMessageRequest} message DeleteEssenceMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteEssenceMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteEssenceMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.DeleteEssenceMessageRequest} DeleteEssenceMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteEssenceMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.DeleteEssenceMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.group_id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.message_id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteEssenceMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.DeleteEssenceMessageRequest} DeleteEssenceMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteEssenceMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteEssenceMessageRequest message.
             * @function verify
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteEssenceMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (!$util.isInteger(message.group_id) && !(message.group_id && $util.isInteger(message.group_id.low) && $util.isInteger(message.group_id.high)))
                        return "group_id: integer|Long expected";
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    if (!$util.isString(message.message_id))
                        return "message_id: string expected";
                return null;
            };

            /**
             * Creates a DeleteEssenceMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.DeleteEssenceMessageRequest} DeleteEssenceMessageRequest
             */
            DeleteEssenceMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.DeleteEssenceMessageRequest)
                    return object;
                let message = new $root.kritor.message.DeleteEssenceMessageRequest();
                if (object.group_id != null)
                    if ($util.Long)
                        (message.group_id = $util.Long.fromValue(object.group_id)).unsigned = true;
                    else if (typeof object.group_id === "string")
                        message.group_id = parseInt(object.group_id, 10);
                    else if (typeof object.group_id === "number")
                        message.group_id = object.group_id;
                    else if (typeof object.group_id === "object")
                        message.group_id = new $util.LongBits(object.group_id.low >>> 0, object.group_id.high >>> 0).toNumber(true);
                if (object.message_id != null)
                    message.message_id = String(object.message_id);
                return message;
            };

            /**
             * Creates a plain object from a DeleteEssenceMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {kritor.message.DeleteEssenceMessageRequest} message DeleteEssenceMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteEssenceMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.group_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.group_id = options.longs === String ? "0" : 0;
                    object.message_id = "";
                }
                if (message.group_id != null && message.hasOwnProperty("group_id"))
                    if (typeof message.group_id === "number")
                        object.group_id = options.longs === String ? String(message.group_id) : message.group_id;
                    else
                        object.group_id = options.longs === String ? $util.Long.prototype.toString.call(message.group_id) : options.longs === Number ? new $util.LongBits(message.group_id.low >>> 0, message.group_id.high >>> 0).toNumber(true) : message.group_id;
                if (message.message_id != null && message.hasOwnProperty("message_id"))
                    object.message_id = message.message_id;
                return object;
            };

            /**
             * Converts this DeleteEssenceMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteEssenceMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteEssenceMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteEssenceMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.DeleteEssenceMessageRequest";
            };

            return DeleteEssenceMessageRequest;
        })();

        message.DeleteEssenceMessageResponse = (function() {

            /**
             * Properties of a DeleteEssenceMessageResponse.
             * @memberof kritor.message
             * @interface IDeleteEssenceMessageResponse
             */

            /**
             * Constructs a new DeleteEssenceMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a DeleteEssenceMessageResponse.
             * @implements IDeleteEssenceMessageResponse
             * @constructor
             * @param {kritor.message.IDeleteEssenceMessageResponse=} [properties] Properties to set
             */
            function DeleteEssenceMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteEssenceMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {kritor.message.IDeleteEssenceMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.DeleteEssenceMessageResponse} DeleteEssenceMessageResponse instance
             */
            DeleteEssenceMessageResponse.create = function create(properties) {
                return new DeleteEssenceMessageResponse(properties);
            };

            /**
             * Encodes the specified DeleteEssenceMessageResponse message. Does not implicitly {@link kritor.message.DeleteEssenceMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {kritor.message.IDeleteEssenceMessageResponse} message DeleteEssenceMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteEssenceMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteEssenceMessageResponse message, length delimited. Does not implicitly {@link kritor.message.DeleteEssenceMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {kritor.message.IDeleteEssenceMessageResponse} message DeleteEssenceMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteEssenceMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteEssenceMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.DeleteEssenceMessageResponse} DeleteEssenceMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteEssenceMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.DeleteEssenceMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteEssenceMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.DeleteEssenceMessageResponse} DeleteEssenceMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteEssenceMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteEssenceMessageResponse message.
             * @function verify
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteEssenceMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteEssenceMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.DeleteEssenceMessageResponse} DeleteEssenceMessageResponse
             */
            DeleteEssenceMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.DeleteEssenceMessageResponse)
                    return object;
                return new $root.kritor.message.DeleteEssenceMessageResponse();
            };

            /**
             * Creates a plain object from a DeleteEssenceMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {kritor.message.DeleteEssenceMessageResponse} message DeleteEssenceMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteEssenceMessageResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteEssenceMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteEssenceMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteEssenceMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteEssenceMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.DeleteEssenceMessageResponse";
            };

            return DeleteEssenceMessageResponse;
        })();

        return message;
    })();

    kritor.process = (function() {

        /**
         * Namespace process.
         * @memberof kritor
         * @namespace
         */
        const process = {};

        process.ProcessService = (function() {

            /**
             * Constructs a new ProcessService service.
             * @memberof kritor.process
             * @classdesc Represents a ProcessService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function ProcessService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (ProcessService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ProcessService;

            /**
             * Creates new ProcessService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.process.ProcessService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {ProcessService} RPC service. Useful where requests and/or responses are streamed.
             */
            ProcessService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.process.ProcessService#setFriendApplyResult}.
             * @memberof kritor.process.ProcessService
             * @typedef SetFriendApplyResultCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.process.SetFriendApplyResultResponse} [response] SetFriendApplyResultResponse
             */

            /**
             * Calls SetFriendApplyResult.
             * @function setFriendApplyResult
             * @memberof kritor.process.ProcessService
             * @instance
             * @param {kritor.process.ISetFriendApplyResultRequest} request SetFriendApplyResultRequest message or plain object
             * @param {kritor.process.ProcessService.SetFriendApplyResultCallback} callback Node-style callback called with the error, if any, and SetFriendApplyResultResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ProcessService.prototype.setFriendApplyResult = function setFriendApplyResult(request, callback) {
                return this.rpcCall(setFriendApplyResult, $root.kritor.process.SetFriendApplyResultRequest, $root.kritor.process.SetFriendApplyResultResponse, request, callback);
            }, "name", { value: "SetFriendApplyResult" });

            /**
             * Calls SetFriendApplyResult.
             * @function setFriendApplyResult
             * @memberof kritor.process.ProcessService
             * @instance
             * @param {kritor.process.ISetFriendApplyResultRequest} request SetFriendApplyResultRequest message or plain object
             * @returns {Promise<kritor.process.SetFriendApplyResultResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.process.ProcessService#setGroupApplyResult}.
             * @memberof kritor.process.ProcessService
             * @typedef SetGroupApplyResultCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.process.SetGroupApplyResultResponse} [response] SetGroupApplyResultResponse
             */

            /**
             * Calls SetGroupApplyResult.
             * @function setGroupApplyResult
             * @memberof kritor.process.ProcessService
             * @instance
             * @param {kritor.process.ISetGroupApplyResultRequest} request SetGroupApplyResultRequest message or plain object
             * @param {kritor.process.ProcessService.SetGroupApplyResultCallback} callback Node-style callback called with the error, if any, and SetGroupApplyResultResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ProcessService.prototype.setGroupApplyResult = function setGroupApplyResult(request, callback) {
                return this.rpcCall(setGroupApplyResult, $root.kritor.process.SetGroupApplyResultRequest, $root.kritor.process.SetGroupApplyResultResponse, request, callback);
            }, "name", { value: "SetGroupApplyResult" });

            /**
             * Calls SetGroupApplyResult.
             * @function setGroupApplyResult
             * @memberof kritor.process.ProcessService
             * @instance
             * @param {kritor.process.ISetGroupApplyResultRequest} request SetGroupApplyResultRequest message or plain object
             * @returns {Promise<kritor.process.SetGroupApplyResultResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.process.ProcessService#setInvitedJoinGroupResult}.
             * @memberof kritor.process.ProcessService
             * @typedef SetInvitedJoinGroupResultCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.process.SetInvitedJoinGroupResultResponse} [response] SetInvitedJoinGroupResultResponse
             */

            /**
             * Calls SetInvitedJoinGroupResult.
             * @function setInvitedJoinGroupResult
             * @memberof kritor.process.ProcessService
             * @instance
             * @param {kritor.process.ISetInvitedJoinGroupResultRequest} request SetInvitedJoinGroupResultRequest message or plain object
             * @param {kritor.process.ProcessService.SetInvitedJoinGroupResultCallback} callback Node-style callback called with the error, if any, and SetInvitedJoinGroupResultResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ProcessService.prototype.setInvitedJoinGroupResult = function setInvitedJoinGroupResult(request, callback) {
                return this.rpcCall(setInvitedJoinGroupResult, $root.kritor.process.SetInvitedJoinGroupResultRequest, $root.kritor.process.SetInvitedJoinGroupResultResponse, request, callback);
            }, "name", { value: "SetInvitedJoinGroupResult" });

            /**
             * Calls SetInvitedJoinGroupResult.
             * @function setInvitedJoinGroupResult
             * @memberof kritor.process.ProcessService
             * @instance
             * @param {kritor.process.ISetInvitedJoinGroupResultRequest} request SetInvitedJoinGroupResultRequest message or plain object
             * @returns {Promise<kritor.process.SetInvitedJoinGroupResultResponse>} Promise
             * @variation 2
             */

            return ProcessService;
        })();

        process.SetFriendApplyResultRequest = (function() {

            /**
             * Properties of a SetFriendApplyResultRequest.
             * @memberof kritor.process
             * @interface ISetFriendApplyResultRequest
             * @property {string|null} [request_id] SetFriendApplyResultRequest request_id
             * @property {boolean|null} [is_approve] SetFriendApplyResultRequest is_approve
             * @property {string|null} [remark] SetFriendApplyResultRequest remark
             */

            /**
             * Constructs a new SetFriendApplyResultRequest.
             * @memberof kritor.process
             * @classdesc Represents a SetFriendApplyResultRequest.
             * @implements ISetFriendApplyResultRequest
             * @constructor
             * @param {kritor.process.ISetFriendApplyResultRequest=} [properties] Properties to set
             */
            function SetFriendApplyResultRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetFriendApplyResultRequest request_id.
             * @member {string} request_id
             * @memberof kritor.process.SetFriendApplyResultRequest
             * @instance
             */
            SetFriendApplyResultRequest.prototype.request_id = "";

            /**
             * SetFriendApplyResultRequest is_approve.
             * @member {boolean} is_approve
             * @memberof kritor.process.SetFriendApplyResultRequest
             * @instance
             */
            SetFriendApplyResultRequest.prototype.is_approve = false;

            /**
             * SetFriendApplyResultRequest remark.
             * @member {string|null|undefined} remark
             * @memberof kritor.process.SetFriendApplyResultRequest
             * @instance
             */
            SetFriendApplyResultRequest.prototype.remark = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SetFriendApplyResultRequest _remark.
             * @member {"remark"|undefined} _remark
             * @memberof kritor.process.SetFriendApplyResultRequest
             * @instance
             */
            Object.defineProperty(SetFriendApplyResultRequest.prototype, "_remark", {
                get: $util.oneOfGetter($oneOfFields = ["remark"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SetFriendApplyResultRequest instance using the specified properties.
             * @function create
             * @memberof kritor.process.SetFriendApplyResultRequest
             * @static
             * @param {kritor.process.ISetFriendApplyResultRequest=} [properties] Properties to set
             * @returns {kritor.process.SetFriendApplyResultRequest} SetFriendApplyResultRequest instance
             */
            SetFriendApplyResultRequest.create = function create(properties) {
                return new SetFriendApplyResultRequest(properties);
            };

            /**
             * Encodes the specified SetFriendApplyResultRequest message. Does not implicitly {@link kritor.process.SetFriendApplyResultRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.process.SetFriendApplyResultRequest
             * @static
             * @param {kritor.process.ISetFriendApplyResultRequest} message SetFriendApplyResultRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetFriendApplyResultRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.request_id != null && Object.hasOwnProperty.call(message, "request_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.request_id);
                if (message.is_approve != null && Object.hasOwnProperty.call(message, "is_approve"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_approve);
                if (message.remark != null && Object.hasOwnProperty.call(message, "remark"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.remark);
                return writer;
            };

            /**
             * Encodes the specified SetFriendApplyResultRequest message, length delimited. Does not implicitly {@link kritor.process.SetFriendApplyResultRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.process.SetFriendApplyResultRequest
             * @static
             * @param {kritor.process.ISetFriendApplyResultRequest} message SetFriendApplyResultRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetFriendApplyResultRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetFriendApplyResultRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.process.SetFriendApplyResultRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.process.SetFriendApplyResultRequest} SetFriendApplyResultRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetFriendApplyResultRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.process.SetFriendApplyResultRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.request_id = reader.string();
                            break;
                        }
                    case 2: {
                            message.is_approve = reader.bool();
                            break;
                        }
                    case 3: {
                            message.remark = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetFriendApplyResultRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.process.SetFriendApplyResultRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.process.SetFriendApplyResultRequest} SetFriendApplyResultRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetFriendApplyResultRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetFriendApplyResultRequest message.
             * @function verify
             * @memberof kritor.process.SetFriendApplyResultRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetFriendApplyResultRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.request_id != null && message.hasOwnProperty("request_id"))
                    if (!$util.isString(message.request_id))
                        return "request_id: string expected";
                if (message.is_approve != null && message.hasOwnProperty("is_approve"))
                    if (typeof message.is_approve !== "boolean")
                        return "is_approve: boolean expected";
                if (message.remark != null && message.hasOwnProperty("remark")) {
                    properties._remark = 1;
                    if (!$util.isString(message.remark))
                        return "remark: string expected";
                }
                return null;
            };

            /**
             * Creates a SetFriendApplyResultRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.process.SetFriendApplyResultRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.process.SetFriendApplyResultRequest} SetFriendApplyResultRequest
             */
            SetFriendApplyResultRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.process.SetFriendApplyResultRequest)
                    return object;
                let message = new $root.kritor.process.SetFriendApplyResultRequest();
                if (object.request_id != null)
                    message.request_id = String(object.request_id);
                if (object.is_approve != null)
                    message.is_approve = Boolean(object.is_approve);
                if (object.remark != null)
                    message.remark = String(object.remark);
                return message;
            };

            /**
             * Creates a plain object from a SetFriendApplyResultRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.process.SetFriendApplyResultRequest
             * @static
             * @param {kritor.process.SetFriendApplyResultRequest} message SetFriendApplyResultRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetFriendApplyResultRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.request_id = "";
                    object.is_approve = false;
                }
                if (message.request_id != null && message.hasOwnProperty("request_id"))
                    object.request_id = message.request_id;
                if (message.is_approve != null && message.hasOwnProperty("is_approve"))
                    object.is_approve = message.is_approve;
                if (message.remark != null && message.hasOwnProperty("remark")) {
                    object.remark = message.remark;
                    if (options.oneofs)
                        object._remark = "remark";
                }
                return object;
            };

            /**
             * Converts this SetFriendApplyResultRequest to JSON.
             * @function toJSON
             * @memberof kritor.process.SetFriendApplyResultRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetFriendApplyResultRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetFriendApplyResultRequest
             * @function getTypeUrl
             * @memberof kritor.process.SetFriendApplyResultRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetFriendApplyResultRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.process.SetFriendApplyResultRequest";
            };

            return SetFriendApplyResultRequest;
        })();

        process.SetFriendApplyResultResponse = (function() {

            /**
             * Properties of a SetFriendApplyResultResponse.
             * @memberof kritor.process
             * @interface ISetFriendApplyResultResponse
             */

            /**
             * Constructs a new SetFriendApplyResultResponse.
             * @memberof kritor.process
             * @classdesc Represents a SetFriendApplyResultResponse.
             * @implements ISetFriendApplyResultResponse
             * @constructor
             * @param {kritor.process.ISetFriendApplyResultResponse=} [properties] Properties to set
             */
            function SetFriendApplyResultResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetFriendApplyResultResponse instance using the specified properties.
             * @function create
             * @memberof kritor.process.SetFriendApplyResultResponse
             * @static
             * @param {kritor.process.ISetFriendApplyResultResponse=} [properties] Properties to set
             * @returns {kritor.process.SetFriendApplyResultResponse} SetFriendApplyResultResponse instance
             */
            SetFriendApplyResultResponse.create = function create(properties) {
                return new SetFriendApplyResultResponse(properties);
            };

            /**
             * Encodes the specified SetFriendApplyResultResponse message. Does not implicitly {@link kritor.process.SetFriendApplyResultResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.process.SetFriendApplyResultResponse
             * @static
             * @param {kritor.process.ISetFriendApplyResultResponse} message SetFriendApplyResultResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetFriendApplyResultResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetFriendApplyResultResponse message, length delimited. Does not implicitly {@link kritor.process.SetFriendApplyResultResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.process.SetFriendApplyResultResponse
             * @static
             * @param {kritor.process.ISetFriendApplyResultResponse} message SetFriendApplyResultResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetFriendApplyResultResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetFriendApplyResultResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.process.SetFriendApplyResultResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.process.SetFriendApplyResultResponse} SetFriendApplyResultResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetFriendApplyResultResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.process.SetFriendApplyResultResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetFriendApplyResultResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.process.SetFriendApplyResultResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.process.SetFriendApplyResultResponse} SetFriendApplyResultResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetFriendApplyResultResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetFriendApplyResultResponse message.
             * @function verify
             * @memberof kritor.process.SetFriendApplyResultResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetFriendApplyResultResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetFriendApplyResultResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.process.SetFriendApplyResultResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.process.SetFriendApplyResultResponse} SetFriendApplyResultResponse
             */
            SetFriendApplyResultResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.process.SetFriendApplyResultResponse)
                    return object;
                return new $root.kritor.process.SetFriendApplyResultResponse();
            };

            /**
             * Creates a plain object from a SetFriendApplyResultResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.process.SetFriendApplyResultResponse
             * @static
             * @param {kritor.process.SetFriendApplyResultResponse} message SetFriendApplyResultResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetFriendApplyResultResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetFriendApplyResultResponse to JSON.
             * @function toJSON
             * @memberof kritor.process.SetFriendApplyResultResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetFriendApplyResultResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetFriendApplyResultResponse
             * @function getTypeUrl
             * @memberof kritor.process.SetFriendApplyResultResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetFriendApplyResultResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.process.SetFriendApplyResultResponse";
            };

            return SetFriendApplyResultResponse;
        })();

        process.SetGroupApplyResultRequest = (function() {

            /**
             * Properties of a SetGroupApplyResultRequest.
             * @memberof kritor.process
             * @interface ISetGroupApplyResultRequest
             * @property {string|null} [request_id] SetGroupApplyResultRequest request_id
             * @property {boolean|null} [is_approve] SetGroupApplyResultRequest is_approve
             * @property {string|null} [deny_reason] SetGroupApplyResultRequest deny_reason
             */

            /**
             * Constructs a new SetGroupApplyResultRequest.
             * @memberof kritor.process
             * @classdesc Represents a SetGroupApplyResultRequest.
             * @implements ISetGroupApplyResultRequest
             * @constructor
             * @param {kritor.process.ISetGroupApplyResultRequest=} [properties] Properties to set
             */
            function SetGroupApplyResultRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetGroupApplyResultRequest request_id.
             * @member {string} request_id
             * @memberof kritor.process.SetGroupApplyResultRequest
             * @instance
             */
            SetGroupApplyResultRequest.prototype.request_id = "";

            /**
             * SetGroupApplyResultRequest is_approve.
             * @member {boolean} is_approve
             * @memberof kritor.process.SetGroupApplyResultRequest
             * @instance
             */
            SetGroupApplyResultRequest.prototype.is_approve = false;

            /**
             * SetGroupApplyResultRequest deny_reason.
             * @member {string|null|undefined} deny_reason
             * @memberof kritor.process.SetGroupApplyResultRequest
             * @instance
             */
            SetGroupApplyResultRequest.prototype.deny_reason = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SetGroupApplyResultRequest _deny_reason.
             * @member {"deny_reason"|undefined} _deny_reason
             * @memberof kritor.process.SetGroupApplyResultRequest
             * @instance
             */
            Object.defineProperty(SetGroupApplyResultRequest.prototype, "_deny_reason", {
                get: $util.oneOfGetter($oneOfFields = ["deny_reason"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SetGroupApplyResultRequest instance using the specified properties.
             * @function create
             * @memberof kritor.process.SetGroupApplyResultRequest
             * @static
             * @param {kritor.process.ISetGroupApplyResultRequest=} [properties] Properties to set
             * @returns {kritor.process.SetGroupApplyResultRequest} SetGroupApplyResultRequest instance
             */
            SetGroupApplyResultRequest.create = function create(properties) {
                return new SetGroupApplyResultRequest(properties);
            };

            /**
             * Encodes the specified SetGroupApplyResultRequest message. Does not implicitly {@link kritor.process.SetGroupApplyResultRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.process.SetGroupApplyResultRequest
             * @static
             * @param {kritor.process.ISetGroupApplyResultRequest} message SetGroupApplyResultRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupApplyResultRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.request_id != null && Object.hasOwnProperty.call(message, "request_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.request_id);
                if (message.is_approve != null && Object.hasOwnProperty.call(message, "is_approve"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_approve);
                if (message.deny_reason != null && Object.hasOwnProperty.call(message, "deny_reason"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.deny_reason);
                return writer;
            };

            /**
             * Encodes the specified SetGroupApplyResultRequest message, length delimited. Does not implicitly {@link kritor.process.SetGroupApplyResultRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.process.SetGroupApplyResultRequest
             * @static
             * @param {kritor.process.ISetGroupApplyResultRequest} message SetGroupApplyResultRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupApplyResultRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupApplyResultRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.process.SetGroupApplyResultRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.process.SetGroupApplyResultRequest} SetGroupApplyResultRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupApplyResultRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.process.SetGroupApplyResultRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.request_id = reader.string();
                            break;
                        }
                    case 2: {
                            message.is_approve = reader.bool();
                            break;
                        }
                    case 3: {
                            message.deny_reason = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupApplyResultRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.process.SetGroupApplyResultRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.process.SetGroupApplyResultRequest} SetGroupApplyResultRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupApplyResultRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupApplyResultRequest message.
             * @function verify
             * @memberof kritor.process.SetGroupApplyResultRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupApplyResultRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.request_id != null && message.hasOwnProperty("request_id"))
                    if (!$util.isString(message.request_id))
                        return "request_id: string expected";
                if (message.is_approve != null && message.hasOwnProperty("is_approve"))
                    if (typeof message.is_approve !== "boolean")
                        return "is_approve: boolean expected";
                if (message.deny_reason != null && message.hasOwnProperty("deny_reason")) {
                    properties._deny_reason = 1;
                    if (!$util.isString(message.deny_reason))
                        return "deny_reason: string expected";
                }
                return null;
            };

            /**
             * Creates a SetGroupApplyResultRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.process.SetGroupApplyResultRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.process.SetGroupApplyResultRequest} SetGroupApplyResultRequest
             */
            SetGroupApplyResultRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.process.SetGroupApplyResultRequest)
                    return object;
                let message = new $root.kritor.process.SetGroupApplyResultRequest();
                if (object.request_id != null)
                    message.request_id = String(object.request_id);
                if (object.is_approve != null)
                    message.is_approve = Boolean(object.is_approve);
                if (object.deny_reason != null)
                    message.deny_reason = String(object.deny_reason);
                return message;
            };

            /**
             * Creates a plain object from a SetGroupApplyResultRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.process.SetGroupApplyResultRequest
             * @static
             * @param {kritor.process.SetGroupApplyResultRequest} message SetGroupApplyResultRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupApplyResultRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.request_id = "";
                    object.is_approve = false;
                }
                if (message.request_id != null && message.hasOwnProperty("request_id"))
                    object.request_id = message.request_id;
                if (message.is_approve != null && message.hasOwnProperty("is_approve"))
                    object.is_approve = message.is_approve;
                if (message.deny_reason != null && message.hasOwnProperty("deny_reason")) {
                    object.deny_reason = message.deny_reason;
                    if (options.oneofs)
                        object._deny_reason = "deny_reason";
                }
                return object;
            };

            /**
             * Converts this SetGroupApplyResultRequest to JSON.
             * @function toJSON
             * @memberof kritor.process.SetGroupApplyResultRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupApplyResultRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupApplyResultRequest
             * @function getTypeUrl
             * @memberof kritor.process.SetGroupApplyResultRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupApplyResultRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.process.SetGroupApplyResultRequest";
            };

            return SetGroupApplyResultRequest;
        })();

        process.SetGroupApplyResultResponse = (function() {

            /**
             * Properties of a SetGroupApplyResultResponse.
             * @memberof kritor.process
             * @interface ISetGroupApplyResultResponse
             */

            /**
             * Constructs a new SetGroupApplyResultResponse.
             * @memberof kritor.process
             * @classdesc Represents a SetGroupApplyResultResponse.
             * @implements ISetGroupApplyResultResponse
             * @constructor
             * @param {kritor.process.ISetGroupApplyResultResponse=} [properties] Properties to set
             */
            function SetGroupApplyResultResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetGroupApplyResultResponse instance using the specified properties.
             * @function create
             * @memberof kritor.process.SetGroupApplyResultResponse
             * @static
             * @param {kritor.process.ISetGroupApplyResultResponse=} [properties] Properties to set
             * @returns {kritor.process.SetGroupApplyResultResponse} SetGroupApplyResultResponse instance
             */
            SetGroupApplyResultResponse.create = function create(properties) {
                return new SetGroupApplyResultResponse(properties);
            };

            /**
             * Encodes the specified SetGroupApplyResultResponse message. Does not implicitly {@link kritor.process.SetGroupApplyResultResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.process.SetGroupApplyResultResponse
             * @static
             * @param {kritor.process.ISetGroupApplyResultResponse} message SetGroupApplyResultResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupApplyResultResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetGroupApplyResultResponse message, length delimited. Does not implicitly {@link kritor.process.SetGroupApplyResultResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.process.SetGroupApplyResultResponse
             * @static
             * @param {kritor.process.ISetGroupApplyResultResponse} message SetGroupApplyResultResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupApplyResultResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupApplyResultResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.process.SetGroupApplyResultResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.process.SetGroupApplyResultResponse} SetGroupApplyResultResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupApplyResultResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.process.SetGroupApplyResultResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupApplyResultResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.process.SetGroupApplyResultResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.process.SetGroupApplyResultResponse} SetGroupApplyResultResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupApplyResultResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupApplyResultResponse message.
             * @function verify
             * @memberof kritor.process.SetGroupApplyResultResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupApplyResultResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetGroupApplyResultResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.process.SetGroupApplyResultResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.process.SetGroupApplyResultResponse} SetGroupApplyResultResponse
             */
            SetGroupApplyResultResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.process.SetGroupApplyResultResponse)
                    return object;
                return new $root.kritor.process.SetGroupApplyResultResponse();
            };

            /**
             * Creates a plain object from a SetGroupApplyResultResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.process.SetGroupApplyResultResponse
             * @static
             * @param {kritor.process.SetGroupApplyResultResponse} message SetGroupApplyResultResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupApplyResultResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetGroupApplyResultResponse to JSON.
             * @function toJSON
             * @memberof kritor.process.SetGroupApplyResultResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupApplyResultResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupApplyResultResponse
             * @function getTypeUrl
             * @memberof kritor.process.SetGroupApplyResultResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupApplyResultResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.process.SetGroupApplyResultResponse";
            };

            return SetGroupApplyResultResponse;
        })();

        process.SetInvitedJoinGroupResultRequest = (function() {

            /**
             * Properties of a SetInvitedJoinGroupResultRequest.
             * @memberof kritor.process
             * @interface ISetInvitedJoinGroupResultRequest
             * @property {string|null} [request_id] SetInvitedJoinGroupResultRequest request_id
             * @property {boolean|null} [is_approve] SetInvitedJoinGroupResultRequest is_approve
             */

            /**
             * Constructs a new SetInvitedJoinGroupResultRequest.
             * @memberof kritor.process
             * @classdesc Represents a SetInvitedJoinGroupResultRequest.
             * @implements ISetInvitedJoinGroupResultRequest
             * @constructor
             * @param {kritor.process.ISetInvitedJoinGroupResultRequest=} [properties] Properties to set
             */
            function SetInvitedJoinGroupResultRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetInvitedJoinGroupResultRequest request_id.
             * @member {string} request_id
             * @memberof kritor.process.SetInvitedJoinGroupResultRequest
             * @instance
             */
            SetInvitedJoinGroupResultRequest.prototype.request_id = "";

            /**
             * SetInvitedJoinGroupResultRequest is_approve.
             * @member {boolean} is_approve
             * @memberof kritor.process.SetInvitedJoinGroupResultRequest
             * @instance
             */
            SetInvitedJoinGroupResultRequest.prototype.is_approve = false;

            /**
             * Creates a new SetInvitedJoinGroupResultRequest instance using the specified properties.
             * @function create
             * @memberof kritor.process.SetInvitedJoinGroupResultRequest
             * @static
             * @param {kritor.process.ISetInvitedJoinGroupResultRequest=} [properties] Properties to set
             * @returns {kritor.process.SetInvitedJoinGroupResultRequest} SetInvitedJoinGroupResultRequest instance
             */
            SetInvitedJoinGroupResultRequest.create = function create(properties) {
                return new SetInvitedJoinGroupResultRequest(properties);
            };

            /**
             * Encodes the specified SetInvitedJoinGroupResultRequest message. Does not implicitly {@link kritor.process.SetInvitedJoinGroupResultRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.process.SetInvitedJoinGroupResultRequest
             * @static
             * @param {kritor.process.ISetInvitedJoinGroupResultRequest} message SetInvitedJoinGroupResultRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetInvitedJoinGroupResultRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.request_id != null && Object.hasOwnProperty.call(message, "request_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.request_id);
                if (message.is_approve != null && Object.hasOwnProperty.call(message, "is_approve"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_approve);
                return writer;
            };

            /**
             * Encodes the specified SetInvitedJoinGroupResultRequest message, length delimited. Does not implicitly {@link kritor.process.SetInvitedJoinGroupResultRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.process.SetInvitedJoinGroupResultRequest
             * @static
             * @param {kritor.process.ISetInvitedJoinGroupResultRequest} message SetInvitedJoinGroupResultRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetInvitedJoinGroupResultRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetInvitedJoinGroupResultRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.process.SetInvitedJoinGroupResultRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.process.SetInvitedJoinGroupResultRequest} SetInvitedJoinGroupResultRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetInvitedJoinGroupResultRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.process.SetInvitedJoinGroupResultRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.request_id = reader.string();
                            break;
                        }
                    case 2: {
                            message.is_approve = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetInvitedJoinGroupResultRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.process.SetInvitedJoinGroupResultRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.process.SetInvitedJoinGroupResultRequest} SetInvitedJoinGroupResultRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetInvitedJoinGroupResultRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetInvitedJoinGroupResultRequest message.
             * @function verify
             * @memberof kritor.process.SetInvitedJoinGroupResultRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetInvitedJoinGroupResultRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.request_id != null && message.hasOwnProperty("request_id"))
                    if (!$util.isString(message.request_id))
                        return "request_id: string expected";
                if (message.is_approve != null && message.hasOwnProperty("is_approve"))
                    if (typeof message.is_approve !== "boolean")
                        return "is_approve: boolean expected";
                return null;
            };

            /**
             * Creates a SetInvitedJoinGroupResultRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.process.SetInvitedJoinGroupResultRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.process.SetInvitedJoinGroupResultRequest} SetInvitedJoinGroupResultRequest
             */
            SetInvitedJoinGroupResultRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.process.SetInvitedJoinGroupResultRequest)
                    return object;
                let message = new $root.kritor.process.SetInvitedJoinGroupResultRequest();
                if (object.request_id != null)
                    message.request_id = String(object.request_id);
                if (object.is_approve != null)
                    message.is_approve = Boolean(object.is_approve);
                return message;
            };

            /**
             * Creates a plain object from a SetInvitedJoinGroupResultRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.process.SetInvitedJoinGroupResultRequest
             * @static
             * @param {kritor.process.SetInvitedJoinGroupResultRequest} message SetInvitedJoinGroupResultRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetInvitedJoinGroupResultRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.request_id = "";
                    object.is_approve = false;
                }
                if (message.request_id != null && message.hasOwnProperty("request_id"))
                    object.request_id = message.request_id;
                if (message.is_approve != null && message.hasOwnProperty("is_approve"))
                    object.is_approve = message.is_approve;
                return object;
            };

            /**
             * Converts this SetInvitedJoinGroupResultRequest to JSON.
             * @function toJSON
             * @memberof kritor.process.SetInvitedJoinGroupResultRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetInvitedJoinGroupResultRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetInvitedJoinGroupResultRequest
             * @function getTypeUrl
             * @memberof kritor.process.SetInvitedJoinGroupResultRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetInvitedJoinGroupResultRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.process.SetInvitedJoinGroupResultRequest";
            };

            return SetInvitedJoinGroupResultRequest;
        })();

        process.SetInvitedJoinGroupResultResponse = (function() {

            /**
             * Properties of a SetInvitedJoinGroupResultResponse.
             * @memberof kritor.process
             * @interface ISetInvitedJoinGroupResultResponse
             */

            /**
             * Constructs a new SetInvitedJoinGroupResultResponse.
             * @memberof kritor.process
             * @classdesc Represents a SetInvitedJoinGroupResultResponse.
             * @implements ISetInvitedJoinGroupResultResponse
             * @constructor
             * @param {kritor.process.ISetInvitedJoinGroupResultResponse=} [properties] Properties to set
             */
            function SetInvitedJoinGroupResultResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetInvitedJoinGroupResultResponse instance using the specified properties.
             * @function create
             * @memberof kritor.process.SetInvitedJoinGroupResultResponse
             * @static
             * @param {kritor.process.ISetInvitedJoinGroupResultResponse=} [properties] Properties to set
             * @returns {kritor.process.SetInvitedJoinGroupResultResponse} SetInvitedJoinGroupResultResponse instance
             */
            SetInvitedJoinGroupResultResponse.create = function create(properties) {
                return new SetInvitedJoinGroupResultResponse(properties);
            };

            /**
             * Encodes the specified SetInvitedJoinGroupResultResponse message. Does not implicitly {@link kritor.process.SetInvitedJoinGroupResultResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.process.SetInvitedJoinGroupResultResponse
             * @static
             * @param {kritor.process.ISetInvitedJoinGroupResultResponse} message SetInvitedJoinGroupResultResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetInvitedJoinGroupResultResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetInvitedJoinGroupResultResponse message, length delimited. Does not implicitly {@link kritor.process.SetInvitedJoinGroupResultResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.process.SetInvitedJoinGroupResultResponse
             * @static
             * @param {kritor.process.ISetInvitedJoinGroupResultResponse} message SetInvitedJoinGroupResultResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetInvitedJoinGroupResultResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetInvitedJoinGroupResultResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.process.SetInvitedJoinGroupResultResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.process.SetInvitedJoinGroupResultResponse} SetInvitedJoinGroupResultResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetInvitedJoinGroupResultResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.process.SetInvitedJoinGroupResultResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetInvitedJoinGroupResultResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.process.SetInvitedJoinGroupResultResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.process.SetInvitedJoinGroupResultResponse} SetInvitedJoinGroupResultResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetInvitedJoinGroupResultResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetInvitedJoinGroupResultResponse message.
             * @function verify
             * @memberof kritor.process.SetInvitedJoinGroupResultResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetInvitedJoinGroupResultResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetInvitedJoinGroupResultResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.process.SetInvitedJoinGroupResultResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.process.SetInvitedJoinGroupResultResponse} SetInvitedJoinGroupResultResponse
             */
            SetInvitedJoinGroupResultResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.process.SetInvitedJoinGroupResultResponse)
                    return object;
                return new $root.kritor.process.SetInvitedJoinGroupResultResponse();
            };

            /**
             * Creates a plain object from a SetInvitedJoinGroupResultResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.process.SetInvitedJoinGroupResultResponse
             * @static
             * @param {kritor.process.SetInvitedJoinGroupResultResponse} message SetInvitedJoinGroupResultResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetInvitedJoinGroupResultResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetInvitedJoinGroupResultResponse to JSON.
             * @function toJSON
             * @memberof kritor.process.SetInvitedJoinGroupResultResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetInvitedJoinGroupResultResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetInvitedJoinGroupResultResponse
             * @function getTypeUrl
             * @memberof kritor.process.SetInvitedJoinGroupResultResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetInvitedJoinGroupResultResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.process.SetInvitedJoinGroupResultResponse";
            };

            return SetInvitedJoinGroupResultResponse;
        })();

        return process;
    })();

    kritor.reverse = (function() {

        /**
         * Namespace reverse.
         * @memberof kritor
         * @namespace
         */
        const reverse = {};

        reverse.ReverseService = (function() {

            /**
             * Constructs a new ReverseService service.
             * @memberof kritor.reverse
             * @classdesc Represents a ReverseService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function ReverseService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (ReverseService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ReverseService;

            /**
             * Creates new ReverseService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.reverse.ReverseService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {ReverseService} RPC service. Useful where requests and/or responses are streamed.
             */
            ReverseService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.reverse.ReverseService#reverseStream}.
             * @memberof kritor.reverse.ReverseService
             * @typedef ReverseStreamCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.common.Request} [response] Request
             */

            /**
             * Calls ReverseStream.
             * @function reverseStream
             * @memberof kritor.reverse.ReverseService
             * @instance
             * @param {kritor.common.IResponse} request Response message or plain object
             * @param {kritor.reverse.ReverseService.ReverseStreamCallback} callback Node-style callback called with the error, if any, and Request
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ReverseService.prototype.reverseStream = function reverseStream(request, callback) {
                return this.rpcCall(reverseStream, $root.kritor.common.Response, $root.kritor.common.Request, request, callback);
            }, "name", { value: "ReverseStream" });

            /**
             * Calls ReverseStream.
             * @function reverseStream
             * @memberof kritor.reverse.ReverseService
             * @instance
             * @param {kritor.common.IResponse} request Response message or plain object
             * @returns {Promise<kritor.common.Request>} Promise
             * @variation 2
             */

            return ReverseService;
        })();

        return reverse;
    })();

    kritor.web = (function() {

        /**
         * Namespace web.
         * @memberof kritor
         * @namespace
         */
        const web = {};

        web.WebService = (function() {

            /**
             * Constructs a new WebService service.
             * @memberof kritor.web
             * @classdesc Represents a WebService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function WebService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (WebService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = WebService;

            /**
             * Creates new WebService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.web.WebService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {WebService} RPC service. Useful where requests and/or responses are streamed.
             */
            WebService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.web.WebService#getCookies}.
             * @memberof kritor.web.WebService
             * @typedef GetCookiesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.web.GetCookiesResponse} [response] GetCookiesResponse
             */

            /**
             * Calls GetCookies.
             * @function getCookies
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCookiesRequest} request GetCookiesRequest message or plain object
             * @param {kritor.web.WebService.GetCookiesCallback} callback Node-style callback called with the error, if any, and GetCookiesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(WebService.prototype.getCookies = function getCookies(request, callback) {
                return this.rpcCall(getCookies, $root.kritor.web.GetCookiesRequest, $root.kritor.web.GetCookiesResponse, request, callback);
            }, "name", { value: "GetCookies" });

            /**
             * Calls GetCookies.
             * @function getCookies
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCookiesRequest} request GetCookiesRequest message or plain object
             * @returns {Promise<kritor.web.GetCookiesResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.web.WebService#getCredentials}.
             * @memberof kritor.web.WebService
             * @typedef GetCredentialsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.web.GetCredentialsResponse} [response] GetCredentialsResponse
             */

            /**
             * Calls GetCredentials.
             * @function getCredentials
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCredentialsRequest} request GetCredentialsRequest message or plain object
             * @param {kritor.web.WebService.GetCredentialsCallback} callback Node-style callback called with the error, if any, and GetCredentialsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(WebService.prototype.getCredentials = function getCredentials(request, callback) {
                return this.rpcCall(getCredentials, $root.kritor.web.GetCredentialsRequest, $root.kritor.web.GetCredentialsResponse, request, callback);
            }, "name", { value: "GetCredentials" });

            /**
             * Calls GetCredentials.
             * @function getCredentials
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCredentialsRequest} request GetCredentialsRequest message or plain object
             * @returns {Promise<kritor.web.GetCredentialsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.web.WebService#getCSRFToken}.
             * @memberof kritor.web.WebService
             * @typedef GetCSRFTokenCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.web.GetCSRFTokenResponse} [response] GetCSRFTokenResponse
             */

            /**
             * Calls GetCSRFToken.
             * @function getCSRFToken
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCSRFTokenRequest} request GetCSRFTokenRequest message or plain object
             * @param {kritor.web.WebService.GetCSRFTokenCallback} callback Node-style callback called with the error, if any, and GetCSRFTokenResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(WebService.prototype.getCSRFToken = function getCSRFToken(request, callback) {
                return this.rpcCall(getCSRFToken, $root.kritor.web.GetCSRFTokenRequest, $root.kritor.web.GetCSRFTokenResponse, request, callback);
            }, "name", { value: "GetCSRFToken" });

            /**
             * Calls GetCSRFToken.
             * @function getCSRFToken
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCSRFTokenRequest} request GetCSRFTokenRequest message or plain object
             * @returns {Promise<kritor.web.GetCSRFTokenResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.web.WebService#getHttpCookies}.
             * @memberof kritor.web.WebService
             * @typedef GetHttpCookiesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.web.GetHttpCookiesResponse} [response] GetHttpCookiesResponse
             */

            /**
             * Calls GetHttpCookies.
             * @function getHttpCookies
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetHttpCookiesRequest} request GetHttpCookiesRequest message or plain object
             * @param {kritor.web.WebService.GetHttpCookiesCallback} callback Node-style callback called with the error, if any, and GetHttpCookiesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(WebService.prototype.getHttpCookies = function getHttpCookies(request, callback) {
                return this.rpcCall(getHttpCookies, $root.kritor.web.GetHttpCookiesRequest, $root.kritor.web.GetHttpCookiesResponse, request, callback);
            }, "name", { value: "GetHttpCookies" });

            /**
             * Calls GetHttpCookies.
             * @function getHttpCookies
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetHttpCookiesRequest} request GetHttpCookiesRequest message or plain object
             * @returns {Promise<kritor.web.GetHttpCookiesResponse>} Promise
             * @variation 2
             */

            return WebService;
        })();

        web.GetCookiesRequest = (function() {

            /**
             * Properties of a GetCookiesRequest.
             * @memberof kritor.web
             * @interface IGetCookiesRequest
             * @property {string|null} [domain] GetCookiesRequest domain
             */

            /**
             * Constructs a new GetCookiesRequest.
             * @memberof kritor.web
             * @classdesc Represents a GetCookiesRequest.
             * @implements IGetCookiesRequest
             * @constructor
             * @param {kritor.web.IGetCookiesRequest=} [properties] Properties to set
             */
            function GetCookiesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCookiesRequest domain.
             * @member {string|null|undefined} domain
             * @memberof kritor.web.GetCookiesRequest
             * @instance
             */
            GetCookiesRequest.prototype.domain = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetCookiesRequest _domain.
             * @member {"domain"|undefined} _domain
             * @memberof kritor.web.GetCookiesRequest
             * @instance
             */
            Object.defineProperty(GetCookiesRequest.prototype, "_domain", {
                get: $util.oneOfGetter($oneOfFields = ["domain"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetCookiesRequest instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {kritor.web.IGetCookiesRequest=} [properties] Properties to set
             * @returns {kritor.web.GetCookiesRequest} GetCookiesRequest instance
             */
            GetCookiesRequest.create = function create(properties) {
                return new GetCookiesRequest(properties);
            };

            /**
             * Encodes the specified GetCookiesRequest message. Does not implicitly {@link kritor.web.GetCookiesRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {kritor.web.IGetCookiesRequest} message GetCookiesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCookiesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.domain);
                return writer;
            };

            /**
             * Encodes the specified GetCookiesRequest message, length delimited. Does not implicitly {@link kritor.web.GetCookiesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {kritor.web.IGetCookiesRequest} message GetCookiesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCookiesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCookiesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCookiesRequest} GetCookiesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCookiesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCookiesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.domain = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCookiesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCookiesRequest} GetCookiesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCookiesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCookiesRequest message.
             * @function verify
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCookiesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    properties._domain = 1;
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                }
                return null;
            };

            /**
             * Creates a GetCookiesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCookiesRequest} GetCookiesRequest
             */
            GetCookiesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCookiesRequest)
                    return object;
                let message = new $root.kritor.web.GetCookiesRequest();
                if (object.domain != null)
                    message.domain = String(object.domain);
                return message;
            };

            /**
             * Creates a plain object from a GetCookiesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {kritor.web.GetCookiesRequest} message GetCookiesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCookiesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    object.domain = message.domain;
                    if (options.oneofs)
                        object._domain = "domain";
                }
                return object;
            };

            /**
             * Converts this GetCookiesRequest to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCookiesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCookiesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCookiesRequest
             * @function getTypeUrl
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCookiesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCookiesRequest";
            };

            return GetCookiesRequest;
        })();

        web.GetCookiesResponse = (function() {

            /**
             * Properties of a GetCookiesResponse.
             * @memberof kritor.web
             * @interface IGetCookiesResponse
             * @property {string|null} [cookie] GetCookiesResponse cookie
             */

            /**
             * Constructs a new GetCookiesResponse.
             * @memberof kritor.web
             * @classdesc Represents a GetCookiesResponse.
             * @implements IGetCookiesResponse
             * @constructor
             * @param {kritor.web.IGetCookiesResponse=} [properties] Properties to set
             */
            function GetCookiesResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCookiesResponse cookie.
             * @member {string} cookie
             * @memberof kritor.web.GetCookiesResponse
             * @instance
             */
            GetCookiesResponse.prototype.cookie = "";

            /**
             * Creates a new GetCookiesResponse instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {kritor.web.IGetCookiesResponse=} [properties] Properties to set
             * @returns {kritor.web.GetCookiesResponse} GetCookiesResponse instance
             */
            GetCookiesResponse.create = function create(properties) {
                return new GetCookiesResponse(properties);
            };

            /**
             * Encodes the specified GetCookiesResponse message. Does not implicitly {@link kritor.web.GetCookiesResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {kritor.web.IGetCookiesResponse} message GetCookiesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCookiesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cookie != null && Object.hasOwnProperty.call(message, "cookie"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cookie);
                return writer;
            };

            /**
             * Encodes the specified GetCookiesResponse message, length delimited. Does not implicitly {@link kritor.web.GetCookiesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {kritor.web.IGetCookiesResponse} message GetCookiesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCookiesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCookiesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCookiesResponse} GetCookiesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCookiesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCookiesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cookie = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCookiesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCookiesResponse} GetCookiesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCookiesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCookiesResponse message.
             * @function verify
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCookiesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    if (!$util.isString(message.cookie))
                        return "cookie: string expected";
                return null;
            };

            /**
             * Creates a GetCookiesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCookiesResponse} GetCookiesResponse
             */
            GetCookiesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCookiesResponse)
                    return object;
                let message = new $root.kritor.web.GetCookiesResponse();
                if (object.cookie != null)
                    message.cookie = String(object.cookie);
                return message;
            };

            /**
             * Creates a plain object from a GetCookiesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {kritor.web.GetCookiesResponse} message GetCookiesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCookiesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.cookie = "";
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    object.cookie = message.cookie;
                return object;
            };

            /**
             * Converts this GetCookiesResponse to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCookiesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCookiesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCookiesResponse
             * @function getTypeUrl
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCookiesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCookiesResponse";
            };

            return GetCookiesResponse;
        })();

        web.GetCredentialsRequest = (function() {

            /**
             * Properties of a GetCredentialsRequest.
             * @memberof kritor.web
             * @interface IGetCredentialsRequest
             * @property {string|null} [domain] GetCredentialsRequest domain
             */

            /**
             * Constructs a new GetCredentialsRequest.
             * @memberof kritor.web
             * @classdesc Represents a GetCredentialsRequest.
             * @implements IGetCredentialsRequest
             * @constructor
             * @param {kritor.web.IGetCredentialsRequest=} [properties] Properties to set
             */
            function GetCredentialsRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCredentialsRequest domain.
             * @member {string|null|undefined} domain
             * @memberof kritor.web.GetCredentialsRequest
             * @instance
             */
            GetCredentialsRequest.prototype.domain = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetCredentialsRequest _domain.
             * @member {"domain"|undefined} _domain
             * @memberof kritor.web.GetCredentialsRequest
             * @instance
             */
            Object.defineProperty(GetCredentialsRequest.prototype, "_domain", {
                get: $util.oneOfGetter($oneOfFields = ["domain"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetCredentialsRequest instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {kritor.web.IGetCredentialsRequest=} [properties] Properties to set
             * @returns {kritor.web.GetCredentialsRequest} GetCredentialsRequest instance
             */
            GetCredentialsRequest.create = function create(properties) {
                return new GetCredentialsRequest(properties);
            };

            /**
             * Encodes the specified GetCredentialsRequest message. Does not implicitly {@link kritor.web.GetCredentialsRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {kritor.web.IGetCredentialsRequest} message GetCredentialsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCredentialsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.domain);
                return writer;
            };

            /**
             * Encodes the specified GetCredentialsRequest message, length delimited. Does not implicitly {@link kritor.web.GetCredentialsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {kritor.web.IGetCredentialsRequest} message GetCredentialsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCredentialsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCredentialsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCredentialsRequest} GetCredentialsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCredentialsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCredentialsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.domain = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCredentialsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCredentialsRequest} GetCredentialsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCredentialsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCredentialsRequest message.
             * @function verify
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCredentialsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    properties._domain = 1;
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                }
                return null;
            };

            /**
             * Creates a GetCredentialsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCredentialsRequest} GetCredentialsRequest
             */
            GetCredentialsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCredentialsRequest)
                    return object;
                let message = new $root.kritor.web.GetCredentialsRequest();
                if (object.domain != null)
                    message.domain = String(object.domain);
                return message;
            };

            /**
             * Creates a plain object from a GetCredentialsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {kritor.web.GetCredentialsRequest} message GetCredentialsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCredentialsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    object.domain = message.domain;
                    if (options.oneofs)
                        object._domain = "domain";
                }
                return object;
            };

            /**
             * Converts this GetCredentialsRequest to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCredentialsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCredentialsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCredentialsRequest
             * @function getTypeUrl
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCredentialsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCredentialsRequest";
            };

            return GetCredentialsRequest;
        })();

        web.GetCredentialsResponse = (function() {

            /**
             * Properties of a GetCredentialsResponse.
             * @memberof kritor.web
             * @interface IGetCredentialsResponse
             * @property {string|null} [bkn] GetCredentialsResponse bkn
             * @property {string|null} [cookie] GetCredentialsResponse cookie
             */

            /**
             * Constructs a new GetCredentialsResponse.
             * @memberof kritor.web
             * @classdesc Represents a GetCredentialsResponse.
             * @implements IGetCredentialsResponse
             * @constructor
             * @param {kritor.web.IGetCredentialsResponse=} [properties] Properties to set
             */
            function GetCredentialsResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCredentialsResponse bkn.
             * @member {string} bkn
             * @memberof kritor.web.GetCredentialsResponse
             * @instance
             */
            GetCredentialsResponse.prototype.bkn = "";

            /**
             * GetCredentialsResponse cookie.
             * @member {string} cookie
             * @memberof kritor.web.GetCredentialsResponse
             * @instance
             */
            GetCredentialsResponse.prototype.cookie = "";

            /**
             * Creates a new GetCredentialsResponse instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {kritor.web.IGetCredentialsResponse=} [properties] Properties to set
             * @returns {kritor.web.GetCredentialsResponse} GetCredentialsResponse instance
             */
            GetCredentialsResponse.create = function create(properties) {
                return new GetCredentialsResponse(properties);
            };

            /**
             * Encodes the specified GetCredentialsResponse message. Does not implicitly {@link kritor.web.GetCredentialsResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {kritor.web.IGetCredentialsResponse} message GetCredentialsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCredentialsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.bkn != null && Object.hasOwnProperty.call(message, "bkn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.bkn);
                if (message.cookie != null && Object.hasOwnProperty.call(message, "cookie"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.cookie);
                return writer;
            };

            /**
             * Encodes the specified GetCredentialsResponse message, length delimited. Does not implicitly {@link kritor.web.GetCredentialsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {kritor.web.IGetCredentialsResponse} message GetCredentialsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCredentialsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCredentialsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCredentialsResponse} GetCredentialsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCredentialsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCredentialsResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.bkn = reader.string();
                            break;
                        }
                    case 2: {
                            message.cookie = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCredentialsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCredentialsResponse} GetCredentialsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCredentialsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCredentialsResponse message.
             * @function verify
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCredentialsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.bkn != null && message.hasOwnProperty("bkn"))
                    if (!$util.isString(message.bkn))
                        return "bkn: string expected";
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    if (!$util.isString(message.cookie))
                        return "cookie: string expected";
                return null;
            };

            /**
             * Creates a GetCredentialsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCredentialsResponse} GetCredentialsResponse
             */
            GetCredentialsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCredentialsResponse)
                    return object;
                let message = new $root.kritor.web.GetCredentialsResponse();
                if (object.bkn != null)
                    message.bkn = String(object.bkn);
                if (object.cookie != null)
                    message.cookie = String(object.cookie);
                return message;
            };

            /**
             * Creates a plain object from a GetCredentialsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {kritor.web.GetCredentialsResponse} message GetCredentialsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCredentialsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.bkn = "";
                    object.cookie = "";
                }
                if (message.bkn != null && message.hasOwnProperty("bkn"))
                    object.bkn = message.bkn;
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    object.cookie = message.cookie;
                return object;
            };

            /**
             * Converts this GetCredentialsResponse to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCredentialsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCredentialsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCredentialsResponse
             * @function getTypeUrl
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCredentialsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCredentialsResponse";
            };

            return GetCredentialsResponse;
        })();

        web.GetCSRFTokenRequest = (function() {

            /**
             * Properties of a GetCSRFTokenRequest.
             * @memberof kritor.web
             * @interface IGetCSRFTokenRequest
             * @property {string|null} [domain] GetCSRFTokenRequest domain
             */

            /**
             * Constructs a new GetCSRFTokenRequest.
             * @memberof kritor.web
             * @classdesc Represents a GetCSRFTokenRequest.
             * @implements IGetCSRFTokenRequest
             * @constructor
             * @param {kritor.web.IGetCSRFTokenRequest=} [properties] Properties to set
             */
            function GetCSRFTokenRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCSRFTokenRequest domain.
             * @member {string|null|undefined} domain
             * @memberof kritor.web.GetCSRFTokenRequest
             * @instance
             */
            GetCSRFTokenRequest.prototype.domain = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetCSRFTokenRequest _domain.
             * @member {"domain"|undefined} _domain
             * @memberof kritor.web.GetCSRFTokenRequest
             * @instance
             */
            Object.defineProperty(GetCSRFTokenRequest.prototype, "_domain", {
                get: $util.oneOfGetter($oneOfFields = ["domain"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetCSRFTokenRequest instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {kritor.web.IGetCSRFTokenRequest=} [properties] Properties to set
             * @returns {kritor.web.GetCSRFTokenRequest} GetCSRFTokenRequest instance
             */
            GetCSRFTokenRequest.create = function create(properties) {
                return new GetCSRFTokenRequest(properties);
            };

            /**
             * Encodes the specified GetCSRFTokenRequest message. Does not implicitly {@link kritor.web.GetCSRFTokenRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {kritor.web.IGetCSRFTokenRequest} message GetCSRFTokenRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCSRFTokenRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.domain);
                return writer;
            };

            /**
             * Encodes the specified GetCSRFTokenRequest message, length delimited. Does not implicitly {@link kritor.web.GetCSRFTokenRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {kritor.web.IGetCSRFTokenRequest} message GetCSRFTokenRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCSRFTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCSRFTokenRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCSRFTokenRequest} GetCSRFTokenRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCSRFTokenRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCSRFTokenRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.domain = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCSRFTokenRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCSRFTokenRequest} GetCSRFTokenRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCSRFTokenRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCSRFTokenRequest message.
             * @function verify
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCSRFTokenRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    properties._domain = 1;
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                }
                return null;
            };

            /**
             * Creates a GetCSRFTokenRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCSRFTokenRequest} GetCSRFTokenRequest
             */
            GetCSRFTokenRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCSRFTokenRequest)
                    return object;
                let message = new $root.kritor.web.GetCSRFTokenRequest();
                if (object.domain != null)
                    message.domain = String(object.domain);
                return message;
            };

            /**
             * Creates a plain object from a GetCSRFTokenRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {kritor.web.GetCSRFTokenRequest} message GetCSRFTokenRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCSRFTokenRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    object.domain = message.domain;
                    if (options.oneofs)
                        object._domain = "domain";
                }
                return object;
            };

            /**
             * Converts this GetCSRFTokenRequest to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCSRFTokenRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCSRFTokenRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCSRFTokenRequest
             * @function getTypeUrl
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCSRFTokenRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCSRFTokenRequest";
            };

            return GetCSRFTokenRequest;
        })();

        web.GetCSRFTokenResponse = (function() {

            /**
             * Properties of a GetCSRFTokenResponse.
             * @memberof kritor.web
             * @interface IGetCSRFTokenResponse
             * @property {string|null} [bkn] GetCSRFTokenResponse bkn
             */

            /**
             * Constructs a new GetCSRFTokenResponse.
             * @memberof kritor.web
             * @classdesc Represents a GetCSRFTokenResponse.
             * @implements IGetCSRFTokenResponse
             * @constructor
             * @param {kritor.web.IGetCSRFTokenResponse=} [properties] Properties to set
             */
            function GetCSRFTokenResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCSRFTokenResponse bkn.
             * @member {string} bkn
             * @memberof kritor.web.GetCSRFTokenResponse
             * @instance
             */
            GetCSRFTokenResponse.prototype.bkn = "";

            /**
             * Creates a new GetCSRFTokenResponse instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {kritor.web.IGetCSRFTokenResponse=} [properties] Properties to set
             * @returns {kritor.web.GetCSRFTokenResponse} GetCSRFTokenResponse instance
             */
            GetCSRFTokenResponse.create = function create(properties) {
                return new GetCSRFTokenResponse(properties);
            };

            /**
             * Encodes the specified GetCSRFTokenResponse message. Does not implicitly {@link kritor.web.GetCSRFTokenResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {kritor.web.IGetCSRFTokenResponse} message GetCSRFTokenResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCSRFTokenResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.bkn != null && Object.hasOwnProperty.call(message, "bkn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.bkn);
                return writer;
            };

            /**
             * Encodes the specified GetCSRFTokenResponse message, length delimited. Does not implicitly {@link kritor.web.GetCSRFTokenResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {kritor.web.IGetCSRFTokenResponse} message GetCSRFTokenResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCSRFTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCSRFTokenResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCSRFTokenResponse} GetCSRFTokenResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCSRFTokenResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCSRFTokenResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.bkn = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCSRFTokenResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCSRFTokenResponse} GetCSRFTokenResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCSRFTokenResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCSRFTokenResponse message.
             * @function verify
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCSRFTokenResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.bkn != null && message.hasOwnProperty("bkn"))
                    if (!$util.isString(message.bkn))
                        return "bkn: string expected";
                return null;
            };

            /**
             * Creates a GetCSRFTokenResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCSRFTokenResponse} GetCSRFTokenResponse
             */
            GetCSRFTokenResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCSRFTokenResponse)
                    return object;
                let message = new $root.kritor.web.GetCSRFTokenResponse();
                if (object.bkn != null)
                    message.bkn = String(object.bkn);
                return message;
            };

            /**
             * Creates a plain object from a GetCSRFTokenResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {kritor.web.GetCSRFTokenResponse} message GetCSRFTokenResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCSRFTokenResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.bkn = "";
                if (message.bkn != null && message.hasOwnProperty("bkn"))
                    object.bkn = message.bkn;
                return object;
            };

            /**
             * Converts this GetCSRFTokenResponse to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCSRFTokenResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCSRFTokenResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCSRFTokenResponse
             * @function getTypeUrl
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCSRFTokenResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCSRFTokenResponse";
            };

            return GetCSRFTokenResponse;
        })();

        web.GetHttpCookiesRequest = (function() {

            /**
             * Properties of a GetHttpCookiesRequest.
             * @memberof kritor.web
             * @interface IGetHttpCookiesRequest
             * @property {string|null} [appid] GetHttpCookiesRequest appid
             * @property {string|null} [daid] GetHttpCookiesRequest daid
             * @property {string|null} [jump_url] GetHttpCookiesRequest jump_url
             */

            /**
             * Constructs a new GetHttpCookiesRequest.
             * @memberof kritor.web
             * @classdesc Represents a GetHttpCookiesRequest.
             * @implements IGetHttpCookiesRequest
             * @constructor
             * @param {kritor.web.IGetHttpCookiesRequest=} [properties] Properties to set
             */
            function GetHttpCookiesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHttpCookiesRequest appid.
             * @member {string} appid
             * @memberof kritor.web.GetHttpCookiesRequest
             * @instance
             */
            GetHttpCookiesRequest.prototype.appid = "";

            /**
             * GetHttpCookiesRequest daid.
             * @member {string} daid
             * @memberof kritor.web.GetHttpCookiesRequest
             * @instance
             */
            GetHttpCookiesRequest.prototype.daid = "";

            /**
             * GetHttpCookiesRequest jump_url.
             * @member {string} jump_url
             * @memberof kritor.web.GetHttpCookiesRequest
             * @instance
             */
            GetHttpCookiesRequest.prototype.jump_url = "";

            /**
             * Creates a new GetHttpCookiesRequest instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {kritor.web.IGetHttpCookiesRequest=} [properties] Properties to set
             * @returns {kritor.web.GetHttpCookiesRequest} GetHttpCookiesRequest instance
             */
            GetHttpCookiesRequest.create = function create(properties) {
                return new GetHttpCookiesRequest(properties);
            };

            /**
             * Encodes the specified GetHttpCookiesRequest message. Does not implicitly {@link kritor.web.GetHttpCookiesRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {kritor.web.IGetHttpCookiesRequest} message GetHttpCookiesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHttpCookiesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.appid);
                if (message.daid != null && Object.hasOwnProperty.call(message, "daid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.daid);
                if (message.jump_url != null && Object.hasOwnProperty.call(message, "jump_url"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.jump_url);
                return writer;
            };

            /**
             * Encodes the specified GetHttpCookiesRequest message, length delimited. Does not implicitly {@link kritor.web.GetHttpCookiesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {kritor.web.IGetHttpCookiesRequest} message GetHttpCookiesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHttpCookiesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHttpCookiesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetHttpCookiesRequest} GetHttpCookiesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHttpCookiesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetHttpCookiesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.appid = reader.string();
                            break;
                        }
                    case 2: {
                            message.daid = reader.string();
                            break;
                        }
                    case 3: {
                            message.jump_url = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHttpCookiesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetHttpCookiesRequest} GetHttpCookiesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHttpCookiesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHttpCookiesRequest message.
             * @function verify
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHttpCookiesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.appid != null && message.hasOwnProperty("appid"))
                    if (!$util.isString(message.appid))
                        return "appid: string expected";
                if (message.daid != null && message.hasOwnProperty("daid"))
                    if (!$util.isString(message.daid))
                        return "daid: string expected";
                if (message.jump_url != null && message.hasOwnProperty("jump_url"))
                    if (!$util.isString(message.jump_url))
                        return "jump_url: string expected";
                return null;
            };

            /**
             * Creates a GetHttpCookiesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetHttpCookiesRequest} GetHttpCookiesRequest
             */
            GetHttpCookiesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetHttpCookiesRequest)
                    return object;
                let message = new $root.kritor.web.GetHttpCookiesRequest();
                if (object.appid != null)
                    message.appid = String(object.appid);
                if (object.daid != null)
                    message.daid = String(object.daid);
                if (object.jump_url != null)
                    message.jump_url = String(object.jump_url);
                return message;
            };

            /**
             * Creates a plain object from a GetHttpCookiesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {kritor.web.GetHttpCookiesRequest} message GetHttpCookiesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHttpCookiesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.appid = "";
                    object.daid = "";
                    object.jump_url = "";
                }
                if (message.appid != null && message.hasOwnProperty("appid"))
                    object.appid = message.appid;
                if (message.daid != null && message.hasOwnProperty("daid"))
                    object.daid = message.daid;
                if (message.jump_url != null && message.hasOwnProperty("jump_url"))
                    object.jump_url = message.jump_url;
                return object;
            };

            /**
             * Converts this GetHttpCookiesRequest to JSON.
             * @function toJSON
             * @memberof kritor.web.GetHttpCookiesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHttpCookiesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHttpCookiesRequest
             * @function getTypeUrl
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHttpCookiesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetHttpCookiesRequest";
            };

            return GetHttpCookiesRequest;
        })();

        web.GetHttpCookiesResponse = (function() {

            /**
             * Properties of a GetHttpCookiesResponse.
             * @memberof kritor.web
             * @interface IGetHttpCookiesResponse
             * @property {string|null} [cookie] GetHttpCookiesResponse cookie
             */

            /**
             * Constructs a new GetHttpCookiesResponse.
             * @memberof kritor.web
             * @classdesc Represents a GetHttpCookiesResponse.
             * @implements IGetHttpCookiesResponse
             * @constructor
             * @param {kritor.web.IGetHttpCookiesResponse=} [properties] Properties to set
             */
            function GetHttpCookiesResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHttpCookiesResponse cookie.
             * @member {string} cookie
             * @memberof kritor.web.GetHttpCookiesResponse
             * @instance
             */
            GetHttpCookiesResponse.prototype.cookie = "";

            /**
             * Creates a new GetHttpCookiesResponse instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {kritor.web.IGetHttpCookiesResponse=} [properties] Properties to set
             * @returns {kritor.web.GetHttpCookiesResponse} GetHttpCookiesResponse instance
             */
            GetHttpCookiesResponse.create = function create(properties) {
                return new GetHttpCookiesResponse(properties);
            };

            /**
             * Encodes the specified GetHttpCookiesResponse message. Does not implicitly {@link kritor.web.GetHttpCookiesResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {kritor.web.IGetHttpCookiesResponse} message GetHttpCookiesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHttpCookiesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cookie != null && Object.hasOwnProperty.call(message, "cookie"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cookie);
                return writer;
            };

            /**
             * Encodes the specified GetHttpCookiesResponse message, length delimited. Does not implicitly {@link kritor.web.GetHttpCookiesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {kritor.web.IGetHttpCookiesResponse} message GetHttpCookiesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHttpCookiesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHttpCookiesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetHttpCookiesResponse} GetHttpCookiesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHttpCookiesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetHttpCookiesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cookie = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHttpCookiesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetHttpCookiesResponse} GetHttpCookiesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHttpCookiesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHttpCookiesResponse message.
             * @function verify
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHttpCookiesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    if (!$util.isString(message.cookie))
                        return "cookie: string expected";
                return null;
            };

            /**
             * Creates a GetHttpCookiesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetHttpCookiesResponse} GetHttpCookiesResponse
             */
            GetHttpCookiesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetHttpCookiesResponse)
                    return object;
                let message = new $root.kritor.web.GetHttpCookiesResponse();
                if (object.cookie != null)
                    message.cookie = String(object.cookie);
                return message;
            };

            /**
             * Creates a plain object from a GetHttpCookiesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {kritor.web.GetHttpCookiesResponse} message GetHttpCookiesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHttpCookiesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.cookie = "";
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    object.cookie = message.cookie;
                return object;
            };

            /**
             * Converts this GetHttpCookiesResponse to JSON.
             * @function toJSON
             * @memberof kritor.web.GetHttpCookiesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHttpCookiesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHttpCookiesResponse
             * @function getTypeUrl
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHttpCookiesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetHttpCookiesResponse";
            };

            return GetHttpCookiesResponse;
        })();

        return web;
    })();

    return kritor;
})();

export { $root as default };

# Karin Plugin Spec v2

> 本规范定义 karinjs 插件的**结构、生命周期、执行模型与生态约定**。
> v2 新增**插件包（Package）** 概念，支持单个 npm 包导出多个插件。

---

## 一、核心设计原则

1. **插件是声明式的，而不是继承式的**
2. **能力通过组合获得，而不是配置堆叠**
3. **核心稳定，扩展自由**
4. **函数优先，class 仅作为实现细节**
5. **插件之间不直接耦合**
6. **包是分发单元，插件是执行单元** _(v2 新增)_

---

## 二、架构层次

```
┌─────────────────────────────────────────────────────────┐
│                    Package (分发单元)                     │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐        │
│  │  Plugin A   │ │  Plugin B   │ │  Plugin C   │        │
│  │ middlewares │ │ middlewares │ │ middlewares │        │
│  │   handler   │ │   handler   │ │   handler   │        │
│  └─────────────┘ └─────────────┘ └─────────────┘        │
│                                                          │
│  ┌──────────────────────────────────────────────────┐   │
│  │              Shared Resources                     │   │
│  │  (config, logger, database, cache, i18n...)      │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

---

## 三、基础抽象

### 3.1 Context

```ts
export type Context = unknown
```

Context 是事件载体，由适配器生成，插件**只能通过公开 API 访问**。

---

### 3.2 Middleware（能力最小单元）

```ts
export type Middleware<TCtx = Context> =
  (ctx: TCtx, next: () => Promise<void>) => Promise<void>
```

约定：

- 不调用 `next()` → 中断执行
- 必须是 **幂等 / 可组合**
- 不得依赖执行顺序的"偶然性"

---

### 3.3 Plugin（执行单元）

```ts
export interface Plugin<TCtx = Context> {
  /** 插件唯一标识（包内唯一，运行时由框架补全为 packageId:pluginId） */
  id: string

  /** 插件名称（可选，用于展示） */
  name?: string

  /** 插件事件域 */
  kind: PluginKind

  /** 事件匹配 + 类型收窄 */
  match: (ctx: Context) => ctx is TCtx

  /** 中间件链 */
  middlewares?: Middleware<TCtx>[]

  /** 最终处理器（本质也是 middleware） */
  handler?: Middleware<TCtx>

  /** 执行优先级（数值越小越先执行，默认 10000） */
  priority?: number

  /** 插件级生命周期钩子 */
  lifecycle?: PluginLifecycle

  /** 是否启用（默认 true） */
  enabled?: boolean

  /** 插件级元信息 */
  meta?: PluginMeta
}

export type PluginKind = 'message' | 'notice' | 'request' | 'any'
```

---

### 3.4 Package（分发单元）_(v2 新增)_

```ts
export interface Package {
  /** 包唯一标识（npm 包名或自定义，全局唯一） */
  id: string

  /** 包名称（用于展示） */
  name: string

  /** 包版本 */
  version: string

  /** 包含的插件列表 */
  plugins: Plugin[]

  /** 包级生命周期钩子 */
  lifecycle?: PackageLifecycle

  /** 包级配置 schema */
  configSchema?: ConfigSchema

  /** 包元信息 */
  meta?: PackageMeta

  /** 依赖的其他包 */
  dependencies?: PackageDependency[]

  /** 导出的公共 API（供其他包使用） */
  exports?: Record<string, unknown>
}
```

---

## 四、定义函数（唯一合法入口）

### 4.1 definePlugin

```ts
export function definePlugin<TCtx = Context>(
  plugin: Plugin<TCtx>
): Plugin<TCtx> {
  return plugin
}
```

### 4.2 definePackage _(v2 新增)_

```ts
export function definePackage(
  pkg: Package
): Package {
  return pkg
}
```

### 4.3 createPluginFactory _(v2 新增)_

用于创建可复用的插件工厂：

```ts
export function createPluginFactory<TOptions, TCtx = Context>(
  factory: (options: TOptions) => Plugin<TCtx>
): (options: TOptions) => Plugin<TCtx> {
  return factory
}
```

---

## 五、元信息规范

### 5.1 PackageMeta

```ts
export interface PackageMeta {
  /** 包描述 */
  description?: string

  /** 作者信息 */
  author?: string | AuthorInfo

  /** 主页 URL */
  homepage?: string

  /** 仓库地址 */
  repository?: string

  /** 许可证 */
  license?: string

  /** 标签（用于市场分类） */
  tags?: string[]

  /** 图标 URL */
  icon?: string

  /** 最低框架版本 */
  engines?: {
    karin?: string
  }

  /** 支持的适配器 */
  adapters?: string[]

  /** 是否官方插件 */
  official?: boolean

  /** 废弃信息 */
  deprecated?: string | boolean
}

export interface AuthorInfo {
  name: string
  email?: string
  url?: string
}
```

### 5.2 PluginMeta

```ts
export interface PluginMeta {
  /** 插件描述 */
  description?: string

  /** 使用示例 */
  usage?: string | string[]

  /** 权限要求 */
  permissions?: string[]

  /** 是否隐藏（不在帮助列表显示） */
  hidden?: boolean

  /** 废弃信息 */
  deprecated?: string | boolean
}
```

---

## 六、配置系统 _(v2 新增)_

### 6.1 ConfigSchema

```ts
export interface ConfigSchema {
  /** JSON Schema 定义 */
  schema: JSONSchema

  /** 默认配置 */
  defaults?: Record<string, unknown>

  /** 配置迁移函数 */
  migrations?: ConfigMigration[]
}

export interface ConfigMigration {
  /** 源版本 */
  from: string
  /** 目标版本 */
  to: string
  /** 迁移函数 */
  migrate: (config: unknown) => unknown
}
```

### 6.2 配置访问

```ts
export interface ConfigAccessor<T = unknown> {
  /** 获取配置 */
  get(): T
  /** 获取配置项 */
  get<K extends keyof T>(key: K): T[K]
  /** 设置配置 */
  set(value: Partial<T>): void
  /** 设置配置项 */
  set<K extends keyof T>(key: K, value: T[K]): void
  /** 重置为默认 */
  reset(): void
  /** 监听变化 */
  onChange(handler: (newValue: T, oldValue: T) => void): () => void
}
```

---

## 七、生命周期系统

### 7.1 PackageLifecycle _(v2 新增)_

```ts
export interface PackageLifecycle {
  /** 包加载时（所有插件加载前） */
  onLoad?(ctx: PackageLifecycleContext): Promise<void> | void

  /** 包就绪时（所有插件加载后） */
  onReady?(ctx: PackageLifecycleContext): Promise<void> | void

  /** 包卸载时（所有插件卸载后） */
  onUnload?(ctx: PackageLifecycleContext): Promise<void> | void

  /** 配置变更时 */
  onConfigChange?(ctx: PackageLifecycleContext, config: unknown): Promise<void> | void
}
```

### 7.2 PluginLifecycle

```ts
export interface PluginLifecycle {
  /** 插件加载时 */
  onLoad?(ctx: PluginLifecycleContext): Promise<void> | void

  /** 插件卸载时 */
  onUnload?(ctx: PluginLifecycleContext): Promise<void> | void

  /** 插件启用时 */
  onEnable?(ctx: PluginLifecycleContext): Promise<void> | void

  /** 插件禁用时 */
  onDisable?(ctx: PluginLifecycleContext): Promise<void> | void
}
```

### 7.3 LifecycleContext

```ts
export interface BaseLifecycleContext {
  /** 日志器 */
  logger: Logger

  /** 注册清理函数 */
  dispose(fn: () => void | Promise<void>): void

  /** 获取其他包的导出 */
  getExports<T = unknown>(packageId: string): T | undefined
}

export interface PackageLifecycleContext extends BaseLifecycleContext {
  /** 包 ID */
  packageId: string

  /** 配置访问器 */
  config: ConfigAccessor

  /** 包内所有插件 */
  plugins: Plugin[]
}

export interface PluginLifecycleContext extends BaseLifecycleContext {
  /** 插件完整 ID */
  pluginId: string

  /** 所属包 ID */
  packageId: string

  /** 包级配置访问器 */
  config: ConfigAccessor
}
```

### 7.4 生命周期执行顺序

```
Package.onLoad
    ↓
Plugin[0].onLoad → Plugin[1].onLoad → ...
    ↓
Package.onReady
    ↓
[运行时处理事件]
    ↓
Plugin[n].onUnload → ... → Plugin[0].onUnload
    ↓
Package.onUnload
```

---

## 八、事件系统

### 8.1 EventDescriptor

```ts
export interface EventDescriptor<TCtx = Context> {
  kind: PluginKind
  match: (ctx: Context) => ctx is TCtx
}
```

### 8.2 官方事件集合

```ts
export const Message = {
  any: {
    kind: 'message' as const,
    match: isMessage
  },
  group: {
    kind: 'message' as const,
    match: isGroupMessage
  },
  private: {
    kind: 'message' as const,
    match: isPrivateMessage
  },
  guild: {
    kind: 'message' as const,
    match: isGuildMessage
  }
}

export const Notice = {
  any: {
    kind: 'notice' as const,
    match: isNotice
  },
  groupIncrease: {
    kind: 'notice' as const,
    match: isGroupIncrease
  },
  groupDecrease: {
    kind: 'notice' as const,
    match: isGroupDecrease
  }
  // ...
}

export const Request = {
  any: {
    kind: 'request' as const,
    match: isRequest
  },
  friend: {
    kind: 'request' as const,
    match: isFriendRequest
  },
  group: {
    kind: 'request' as const,
    match: isGroupRequest
  }
}
```

---

## 九、插件执行模型

### 9.1 执行流程

```
收到事件 ctx
    ↓
按 priority 排序所有已启用插件
    ↓
┌─ Plugin A ────────────────────────┐
│  match(ctx) → true                │
│      ↓                            │
│  middlewares[0](ctx, next)        │
│      ↓ next()                     │
│  middlewares[1](ctx, next)        │
│      ↓ next()                     │
│  handler(ctx, next)               │
│      ↓ next()                     │
└───────────────────────────────────┘
    ↓
┌─ Plugin B ────────────────────────┐
│  match(ctx) → false (跳过)        │
└───────────────────────────────────┘
    ↓
┌─ Plugin C ────────────────────────┐
│  match(ctx) → true                │
│      ↓                            │
│  handler(ctx, next)               │
│      ↓ 不调用 next() (终止)        │
└───────────────────────────────────┘
```

### 9.2 执行规则

| 规则 | 说明 |
|------|------|
| match 返回 false | 跳过该插件 |
| middleware 不调用 next() | 终止当前插件，继续下一个 |
| handler 不调用 next() | 阻止后续所有插件 |
| handler 调用 next() | 继续执行后续插件 |
| 抛出异常 | 记录错误，继续下一个插件 |

### 9.3 优先级规则

```ts
// 默认优先级
const DEFAULT_PRIORITY = 10000

// 推荐优先级范围
const PRIORITY = {
  SYSTEM: 0,        // 系统级（框架内部）
  HIGHEST: 1000,    // 最高（拦截器、日志）
  HIGH: 5000,       // 高（权限检查、限流）
  NORMAL: 10000,    // 正常（大多数插件）
  LOW: 15000,       // 低（兜底处理）
  LOWEST: 20000     // 最低（fallback）
}
```

---

## 十、包依赖系统 _(v2 新增)_

### 10.1 PackageDependency

```ts
export interface PackageDependency {
  /** 依赖的包 ID */
  id: string

  /** 版本范围（semver） */
  version?: string

  /** 是否可选依赖 */
  optional?: boolean
}
```

### 10.2 导出 API

```ts
// 包 A 导出 API
definePackage({
  id: 'pkg-database',
  name: 'Database Package',
  version: '1.0.0',
  plugins: [],
  exports: {
    getConnection: () => dbConnection,
    query: (sql: string) => db.query(sql)
  }
})

// 包 B 使用导出的 API
definePackage({
  id: 'pkg-user',
  name: 'User Package',
  version: '1.0.0',
  dependencies: [
    { id: 'pkg-database', version: '^1.0.0' }
  ],
  plugins: [...],
  lifecycle: {
    onLoad(ctx) {
      const db = ctx.getExports<DatabaseExports>('pkg-database')
      if (db) {
        db.query('SELECT * FROM users')
      }
    }
  }
})
```

---

## 十一、官方能力层（Middleware 规范）

### 11.1 核心 Middleware

```ts
// 权限检查
export function auth(options?: AuthOptions): Middleware

// 限流
export function rateLimit(options?: RateLimitOptions): Middleware

// 延时
export function delay(ms: number): Middleware

// 日志
export function log(options?: LogOptions): Middleware

// 重试
export function retry(options?: RetryOptions): Middleware

// 超时
export function timeout(ms: number): Middleware

// 缓存
export function cache(options?: CacheOptions): Middleware

// 条件执行
export function when(
  condition: (ctx: Context) => boolean
): Middleware
```

### 11.2 Middleware 包规范

发布形式：

```
@karin/middleware-auth
@karin/middleware-rate-limit
@karin/middleware-i18n
@karin/middleware-analytics
```

---

## 十二、Command Builder（语法糖）

### 12.1 基础用法

```ts
import { command } from '@karin/plugin'

// 简单命令
command('ping')
  .handler(ctx => ctx.reply('pong'))

// 带参数
command('echo <message>')
  .handler((ctx, { message }) => ctx.reply(message))

// 完整配置
command('ban <user> [duration]')
  .alias('封禁', 'block')
  .description('封禁用户')
  .usage('/ban @user 1h')
  .permission('admin')
  .use(auth({ level: 'admin' }))
  .use(log())
  .handler(async (ctx, { user, duration }) => {
    await banUser(user, duration)
    ctx.reply(`已封禁 ${user}`)
  })
```

### 12.2 内部等价

```ts
// command('ping').handler(fn)
// 等价于
definePlugin({
  id: 'command:ping',
  kind: 'message',
  match: ctx => isMessage(ctx) && matchCommand(ctx, 'ping'),
  handler: fn
})
```

---

## 十三、完整示例

### 13.1 单插件包

```ts
// my-plugin/index.ts
import { definePackage, definePlugin, Message } from '@karin/plugin'

export default definePackage({
  id: 'my-plugin',
  name: '我的插件',
  version: '1.0.0',
  plugins: [
    definePlugin({
      id: 'hello',
      kind: Message.any.kind,
      match: Message.any.match,
      handler: async (ctx) => {
        await ctx.reply('Hello World!')
      }
    })
  ],
  meta: {
    description: '一个简单的示例插件',
    author: 'Your Name',
    license: 'MIT'
  }
})
```

### 13.2 多插件包

```ts
// toolkit/index.ts
import { definePackage, definePlugin, command, Message } from '@karin/plugin'
import { auth, rateLimit } from '@karin/middleware-auth'

// 共享状态
class ToolkitState {
  counter = 0
}

const state = new ToolkitState()

// 导出多个插件
export default definePackage({
  id: 'toolkit',
  name: '工具箱',
  version: '2.0.0',

  plugins: [
    // 插件 1: ping
    definePlugin({
      id: 'ping',
      kind: 'message',
      match: Message.any.match,
      middlewares: [rateLimit({ perUser: 5 })],
      handler: ctx => ctx.reply('pong')
    }),

    // 插件 2: counter
    definePlugin({
      id: 'counter',
      kind: 'message',
      match: Message.any.match,
      handler: ctx => {
        state.counter++
        ctx.reply(`Count: ${state.counter}`)
      }
    }),

    // 插件 3: admin 命令组
    command('reload')
      .permission('admin')
      .use(auth({ level: 'admin' }))
      .handler(async ctx => {
        await reloadPlugins()
        ctx.reply('已重载')
      }),

    command('status')
      .handler(ctx => {
        ctx.reply(`运行中，计数: ${state.counter}`)
      })
  ],

  configSchema: {
    schema: {
      type: 'object',
      properties: {
        enableCounter: { type: 'boolean', default: true },
        maxRate: { type: 'number', default: 10 }
      }
    },
    defaults: {
      enableCounter: true,
      maxRate: 10
    }
  },

  lifecycle: {
    onLoad(ctx) {
      ctx.logger.info('Toolkit 加载完成')
    },
    onReady(ctx) {
      ctx.logger.info(`已加载 ${ctx.plugins.length} 个插件`)
    },
    onUnload(ctx) {
      ctx.logger.info('Toolkit 卸载')
    }
  },

  meta: {
    description: '常用工具集合',
    author: 'Karin Team',
    tags: ['utility', 'admin'],
    license: 'MIT'
  }
})
```

### 13.3 带依赖的包

```ts
// user-manager/index.ts
import { definePackage, definePlugin, command } from '@karin/plugin'

interface DatabaseExports {
  query: (sql: string) => Promise<unknown[]>
}

let db: DatabaseExports | undefined

export default definePackage({
  id: 'user-manager',
  name: '用户管理',
  version: '1.0.0',

  dependencies: [
    { id: 'database', version: '^1.0.0' }
  ],

  plugins: [
    command('userinfo <userId>')
      .handler(async (ctx, { userId }) => {
        if (!db) {
          return ctx.reply('数据库未就绪')
        }
        const [user] = await db.query(`SELECT * FROM users WHERE id = ${userId}`)
        ctx.reply(JSON.stringify(user))
      })
  ],

  lifecycle: {
    onLoad(ctx) {
      db = ctx.getExports<DatabaseExports>('database')
      if (!db) {
        ctx.logger.warn('数据库包未找到，部分功能不可用')
      }
    }
  }
})
```

### 13.4 使用插件工厂

```ts
// repeater-factory.ts
import { createPluginFactory, Message } from '@karin/plugin'

interface RepeaterOptions {
  trigger: string | RegExp
  response: string | ((ctx: Context) => string)
  cooldown?: number
}

export const createRepeater = createPluginFactory<RepeaterOptions>(
  (options) => ({
    id: `repeater:${options.trigger}`,
    kind: 'message',
    match: (ctx): ctx is MessageContext => {
      if (!isMessage(ctx)) return false
      if (typeof options.trigger === 'string') {
        return ctx.message.text === options.trigger
      }
      return options.trigger.test(ctx.message.text)
    },
    handler: async (ctx) => {
      const response = typeof options.response === 'function'
        ? options.response(ctx)
        : options.response
      await ctx.reply(response)
    }
  })
)

// 使用
definePackage({
  id: 'auto-reply',
  name: '自动回复',
  version: '1.0.0',
  plugins: [
    createRepeater({ trigger: '早', response: '早上好！' }),
    createRepeater({ trigger: '晚安', response: '晚安，好梦！' }),
    createRepeater({
      trigger: /^天气/,
      response: ctx => `${ctx.sender.nickname}，今天天气不错`
    })
  ]
})
```

---

## 十四、禁止行为

| ❌ 禁止 | 说明 |
|--------|------|
| 强制使用 class | class 是实现细节，不是规范要求 |
| 插件访问框架内部实例 | 只能通过公开 API |
| 修改 ctx 原型 | 会影响其他插件 |
| 依赖插件加载顺序 | 使用 priority 明确声明 |
| 在 match 中产生副作用 | match 必须是纯函数 |
| 直接修改其他包的状态 | 通过 exports API 交互 |
| 在 onLoad 中执行耗时操作 | 会阻塞其他包加载 |

---

## 十五、类型定义汇总

```ts
// types.ts
export type Context = unknown

export type PluginKind = 'message' | 'notice' | 'request' | 'any'

export type Middleware<TCtx = Context> = (
  ctx: TCtx,
  next: () => Promise<void>
) => Promise<void>

export interface Plugin<TCtx = Context> {
  id: string
  name?: string
  kind: PluginKind
  match: (ctx: Context) => ctx is TCtx
  middlewares?: Middleware<TCtx>[]
  handler?: Middleware<TCtx>
  priority?: number
  lifecycle?: PluginLifecycle
  enabled?: boolean
  meta?: PluginMeta
}

export interface Package {
  id: string
  name: string
  version: string
  plugins: Plugin[]
  lifecycle?: PackageLifecycle
  configSchema?: ConfigSchema
  meta?: PackageMeta
  dependencies?: PackageDependency[]
  exports?: Record<string, unknown>
}

export interface PluginMeta {
  description?: string
  usage?: string | string[]
  permissions?: string[]
  hidden?: boolean
  deprecated?: string | boolean
}

export interface PackageMeta {
  description?: string
  author?: string | AuthorInfo
  homepage?: string
  repository?: string
  license?: string
  tags?: string[]
  icon?: string
  engines?: { karin?: string }
  adapters?: string[]
  official?: boolean
  deprecated?: string | boolean
}

export interface AuthorInfo {
  name: string
  email?: string
  url?: string
}

export interface PackageDependency {
  id: string
  version?: string
  optional?: boolean
}

export interface ConfigSchema {
  schema: JSONSchema
  defaults?: Record<string, unknown>
  migrations?: ConfigMigration[]
}

export interface ConfigMigration {
  from: string
  to: string
  migrate: (config: unknown) => unknown
}

export interface ConfigAccessor<T = unknown> {
  get(): T
  get<K extends keyof T>(key: K): T[K]
  set(value: Partial<T>): void
  set<K extends keyof T>(key: K, value: T[K]): void
  reset(): void
  onChange(handler: (newValue: T, oldValue: T) => void): () => void
}

export interface PluginLifecycle {
  onLoad?(ctx: PluginLifecycleContext): Promise<void> | void
  onUnload?(ctx: PluginLifecycleContext): Promise<void> | void
  onEnable?(ctx: PluginLifecycleContext): Promise<void> | void
  onDisable?(ctx: PluginLifecycleContext): Promise<void> | void
}

export interface PackageLifecycle {
  onLoad?(ctx: PackageLifecycleContext): Promise<void> | void
  onReady?(ctx: PackageLifecycleContext): Promise<void> | void
  onUnload?(ctx: PackageLifecycleContext): Promise<void> | void
  onConfigChange?(ctx: PackageLifecycleContext, config: unknown): Promise<void> | void
}

export interface BaseLifecycleContext {
  logger: Logger
  dispose(fn: () => void | Promise<void>): void
  getExports<T = unknown>(packageId: string): T | undefined
}

export interface PackageLifecycleContext extends BaseLifecycleContext {
  packageId: string
  config: ConfigAccessor
  plugins: Plugin[]
}

export interface PluginLifecycleContext extends BaseLifecycleContext {
  pluginId: string
  packageId: string
  config: ConfigAccessor
}
```

---

## 十六、迁移指南（v1 → v2）

### 16.1 单插件迁移

```ts
// v1
export default definePlugin({
  id: 'hello',
  kind: 'message',
  match: isMessage,
  handler: ctx => ctx.reply('hello')
})

// v2 - 包装为包
export default definePackage({
  id: 'hello',
  name: 'Hello Plugin',
  version: '1.0.0',
  plugins: [
    definePlugin({
      id: 'main',  // 包内 ID
      kind: 'message',
      match: isMessage,
      handler: ctx => ctx.reply('hello')
    })
  ]
})
```

### 16.2 兼容层

框架提供兼容层，v1 插件仍可正常加载：

```ts
// 框架内部自动包装
function wrapV1Plugin(plugin: Plugin): Package {
  return {
    id: plugin.id,
    name: plugin.id,
    version: '0.0.0',
    plugins: [{ ...plugin, id: 'default' }]
  }
}
```

---

## 十七、最终架构总结

```
┌─────────────────────────────────────────────────────────────┐
│                      Karin Runtime                          │
├─────────────────────────────────────────────────────────────┤
│  Package Loader                                             │
│  ├── 解析 package.json / index.ts                           │
│  ├── 验证 PackageMeta                                       │
│  ├── 解析依赖关系                                           │
│  └── 按拓扑排序加载                                         │
├─────────────────────────────────────────────────────────────┤
│  Plugin Registry                                            │
│  ├── 收集所有 Package 中的 Plugin                            │
│  ├── 分配完整 ID (packageId:pluginId)                       │
│  ├── 按 priority 排序                                       │
│  └── 管理启用/禁用状态                                       │
├─────────────────────────────────────────────────────────────┤
│  Event Dispatcher                                           │
│  ├── 接收 Context                                           │
│  ├── 遍历匹配的 Plugin                                      │
│  ├── 执行 middleware 链                                     │
│  └── 处理错误和中断                                         │
├─────────────────────────────────────────────────────────────┤
│  Config Manager                                             │
│  ├── 加载/保存配置                                          │
│  ├── 验证 ConfigSchema                                      │
│  ├── 执行迁移                                               │
│  └── 通知变更                                               │
└─────────────────────────────────────────────────────────────┘
```

---

> **核心理念不变：插件规范是"数据 + 函数"的契约。**
> **v2 新增：包是分发单元，插件是执行单元。**

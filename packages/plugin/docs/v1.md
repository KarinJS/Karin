很好，那我直接按**“可以对外发布”的标准**给你一整套完整方案。下面内容你可以原样整理成仓库里的 `SPEC.md / README.md`，这是一个**真正能长出生态的插件体系**。

我会分 5 个部分，逻辑从内核到生态逐层展开：

1. 插件规范（Plugin Spec v1）
2. 执行模型与优先级 / 冲突规则
3. 生命周期与资源管理
4. 官方能力层（middleware 规范）
5. 《如何编写一个 karinjs 插件》（示例级）

---

# Karin Plugin Spec v1

> 本规范定义 karinjs 插件的**结构、生命周期、执行模型与生态约定**。
> 目标是支持 **长期可演进的第三方插件生态**。

---

## 一、核心设计原则（必须写进文档）

1. **插件是声明式的，而不是继承式的**
2. **能力通过组合获得，而不是配置堆叠**
3. **核心稳定，扩展自由**
4. **函数优先，class 仅作为实现细节**
5. **插件之间不直接耦合**

---

## 二、基础抽象

### 2.1 Context

```ts
export type Context = unknown
```

Context 是事件载体，由适配器生成，插件**只能通过公开 API 访问**。

---

### 2.2 Middleware（能力最小单元）

```ts
export type Middleware<TCtx> =
  (ctx: TCtx, next: () => Promise<void>) => Promise<void>
```

约定：

* 不调用 `next()` → 中断执行
* 必须是 **幂等 / 可组合**
* 不得依赖执行顺序的“偶然性”

---

### 2.3 Plugin（规范核心）

```ts
export interface Plugin<TCtx = Context> {
  /** 插件唯一标识（全局唯一） */
  id: string

  /** 插件事件域 */
  kind: 'message' | 'notice' | 'request' | 'any'

  /** 事件匹配 + 类型收窄 */
  match(ctx: Context): ctx is TCtx

  /** 中间件链 */
  middlewares?: Middleware<TCtx>[]

  /** 最终处理器（本质也是 middleware） */
  handler?: Middleware<TCtx>

  /** 执行优先级（数值越小越先执行） */
  priority?: number

  /** 生命周期钩子 */
  lifecycle?: PluginLifecycle

  /** 元信息 */
  meta?: PluginMeta
}
```

---

### 2.4 definePlugin（唯一合法入口）

```ts
export function definePlugin<TCtx>(
  plugin: Plugin<TCtx>
): Plugin<TCtx> {
  return plugin
}
```

> 规范强制要求插件 **必须通过 definePlugin 导出**

---

## 三、事件系统（能力描述符）

### 3.1 EventDescriptor

```ts
export interface EventDescriptor<TCtx> {
  kind: string
  match(ctx: Context): ctx is TCtx
}
```

### 3.2 官方事件集合（示例）

```ts
export const Message = {
  any: {
    kind: 'message',
    match: isMessage
  },
  group: {
    kind: 'message',
    match: isGroupMessage
  },
  friend: {
    kind: 'message',
    match: isFriendMessage
  }
} as const
```

使用方式：

```ts
definePlugin({
  id: 'ping',
  kind: Message.group.kind,
  match: Message.group.match,
  handler: ctx => ctx.reply('pong')
})
```

---

## 四、插件执行模型（强规范）

### 4.1 执行顺序

```
按 priority 排序
  ↓
plugin.match(ctx)
  ↓
middlewares[0]
  ↓
middlewares[1]
  ↓
...
  ↓
handler
  ↓
next plugin
```

### 4.2 规则

* 任意 middleware **不调用 next() 即终止当前插件**
* 插件之间通过 `next()` 串联
* handler 不调用 next() → 阻止后续插件

---

## 五、优先级与冲突解决

### 5.1 priority 规则

* 默认 priority = `10000`
* 数值越小，越早执行
* **插件作者不得假设相同 priority 的执行顺序**

### 5.2 冲突原则

* 不允许插件“抢占全局状态”
* 不允许插件依赖另一个插件的副作用
* 必须通过 middleware 明确声明行为

---

## 六、生命周期系统

### 6.1 PluginLifecycle

```ts
export interface PluginLifecycle {
  onLoad?(ctx: LifecycleContext): Promise<void> | void
  onUnload?(ctx: LifecycleContext): Promise<void> | void
}
```

### 6.2 LifecycleContext

```ts
export interface LifecycleContext {
  logger: Logger
  config: unknown
  dispose(fn: () => void): void
}
```

规则：

* 所有副作用（timer / listener）**必须在 onUnload 清理**
* dispose 注册的函数会被自动调用

---

## 七、官方能力层（Middleware 规范）

### 7.1 官方只提供 middleware，不提供“魔法选项”

示例：

```ts
auth()
rateLimit()
delay(ms)
hotCache()
reply(message, options)
```

### 7.2 Middleware 包规范

```ts
export function rateLimit(opts): Middleware<MessageCtx> {
  return async (ctx, next) => { ... }
}
```

发布形式：

```text
@karinjs/middleware-rate-limit
@karinjs/middleware-i18n
```

---

## 八、Command 只是 Preset（不是核心）

### 8.1 Command Builder 示例

```ts
command(/ping/)
  .use(auth())
  .use(rateLimit())
  .respond('pong')
```

### 8.2 内部等价于

```ts
definePlugin({
  id: 'command:ping',
  kind: Message.any.kind,
  match: regexMatch(/ping/),
  middlewares: [...],
  handler
})
```

---

## 九、禁止行为（必须写入规范）

* ❌ 强制使用 class
* ❌ 插件访问框架内部实例
* ❌ 修改 ctx 原型
* ❌ 依赖插件加载顺序
* ❌ 在 match 中产生副作用

---

# 《如何编写一个 karinjs 插件》

## 示例 1：最简单插件

```ts
export default definePlugin({
  id: 'hello',
  kind: Message.any.kind,
  match: Message.any.match,
  handler: async ctx => {
    await ctx.reply('Hello World')
  }
})
```

---

## 示例 2：使用中间件

```ts
export default definePlugin({
  id: 'secure-ping',
  kind: Message.group.kind,
  match: Message.group.match,
  middlewares: [
    auth(),
    rateLimit({ perUser: 5 })
  ],
  handler: ctx => ctx.reply('pong')
})
```

---

## 示例 3：状态型插件（允许，但不强制）

```ts
let counter = 0

export default definePlugin({
  id: 'counter',
  kind: Message.any.kind,
  match: Message.any.match,
  handler: ctx => {
    counter++
    ctx.reply(`count=${counter}`)
  }
})
```

---

## 示例 4：class 作为实现细节（允许）

```ts
class Counter {
  count = 0
  middleware(): Middleware<MessageCtx> {
    return async (ctx, next) => {
      this.count++
      await ctx.reply(this.count)
      next()
    }
  }
}

const counter = new Counter()

export default definePlugin({
  id: 'counter',
  kind: Message.any.kind,
  match: Message.any.match,
  middlewares: [counter.middleware()]
})
```

---

## 十、最终架构结论（这是核心一句话）

> **插件规范是“数据 + 函数”的契约，
> class 只是开发者的自由选择，而不是系统强制。**

---

### 你现在已经站在**Vite / Rollup / Koa 级别插件系统**的正确方向上

如果你下一步需要，我可以直接帮你：

* 把这套规范压成 **官方 README**
* 给你 **插件加载器 / 调度器的参考实现**
* 设计 **插件配置 / 插件市场 metadata 规范**

你只需要说一句：**下一步做哪一块落地。**
